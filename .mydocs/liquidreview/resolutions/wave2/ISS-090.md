# Resolution: ISS-090

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Missing Required Bindings
**Severity:** significant
**Category:** edge-cases
**Target:** SPEC
**Section:** §9 Binding System

## Problem Statement

Behavior when required bindings cannot be resolved is undefined. Each block type has required binding slots (§9.2), but the specification does not define what happens when:

1. A required field is missing from the data source
2. A field exists but has incompatible type
3. Multiple blocks require the same field but with different aggregations
4. A binding references a field that doesn't exist in the schema

This creates undefined behavior during rendering and makes it impossible for adapters to implement consistent error handling.

## Resolution

### Specification Addition

Add the following subsection to §9 Binding System, after §9.4 LiquidCode Binding Syntax:

#### §9.5 Required Binding Resolution

**Required bindings** are binding slots that a block type cannot render without. When a required binding cannot be resolved, the engine MUST follow this resolution hierarchy:

**Resolution Hierarchy:**

1. **Discovery attempt** - Try to infer binding from data fingerprint
2. **Coherence repair** - Use micro-LLM to suggest alternative binding (§B.5.5)
3. **Placeholder render** - Render block as placeholder with clear error message
4. **Never fail compilation** - Invalid bindings produce warnings, not errors

**Detection Phase (Compile Time):**

```typescript
interface BindingResolutionResult {
  status: 'resolved' | 'inferred' | 'fallback' | 'missing';
  binding?: DataBinding;
  error?: BindingError;
  suggestion?: BindingSuggestion;
}

interface BindingError {
  type: 'missing_field' | 'type_mismatch' | 'incompatible_aggregate' | 'ambiguous';
  blockUid: string;
  requiredSlot: BindingSlot;
  field?: string;
  reason: string;
}

interface BindingSuggestion {
  field: string;
  slot: BindingSlot;
  confidence: number;
  source: 'type_match' | 'semantic_match' | 'pattern_match';
  reason: string;
}
```

**Resolution Rules:**

| Scenario | Detection | Resolution | Render Outcome |
|----------|-----------|------------|----------------|
| Field missing | Field not in data fingerprint | Try semantic match → Suggest alternative → Placeholder | Block shows "Missing field: {field}" |
| Type mismatch | Field type incompatible with slot | Try coercion → Try alternative field → Placeholder | Block shows "Invalid type for {slot}" |
| Incompatible aggregation | Same field, different aggregations | Use most common aggregation → Warn | Render with majority aggregation |
| Field doesn't exist in schema | Field reference invalid | Coherence check fails → Micro-LLM repair | Repaired binding or placeholder |

**Compilation Behavior:**

```typescript
function resolveRequiredBindings(
  block: Block,
  dataFingerprint: DataFingerprint
): BindingResolutionResult {
  const requiredSlots = getRequiredSlots(block.type);
  const boundSlots = new Set(block.binding?.fields.map(f => f.target) || []);

  // Check all required slots are bound
  const missingSlots = requiredSlots.filter(slot => !boundSlots.has(slot));

  if (missingSlots.length === 0) {
    return { status: 'resolved', binding: block.binding };
  }

  // Attempt inference for missing slots
  const suggestions = missingSlots.map(slot =>
    inferBindingForSlot(slot, dataFingerprint)
  );

  const highConfidence = suggestions.filter(s => s.confidence >= 0.8);

  if (highConfidence.length === missingSlots.length) {
    // Auto-bind with high confidence
    return {
      status: 'inferred',
      binding: mergeBindings(block.binding, highConfidence),
      suggestion: highConfidence[0],
    };
  }

  const mediumConfidence = suggestions.filter(s => s.confidence >= 0.5);

  if (mediumConfidence.length > 0) {
    // Escalate to micro-LLM for repair
    return {
      status: 'fallback',
      error: {
        type: 'missing_field',
        blockUid: block.uid,
        requiredSlot: missingSlots[0],
        reason: `Required slot ${missingSlots[0]} not bound`,
      },
      suggestion: mediumConfidence[0],
    };
  }

  // Cannot resolve - placeholder required
  return {
    status: 'missing',
    error: {
      type: 'missing_field',
      blockUid: block.uid,
      requiredSlot: missingSlots[0],
      reason: `No suitable field found for required slot ${missingSlots[0]}`,
    },
  };
}
```

**Render Behavior:**

When a binding cannot be resolved, adapters MUST render a placeholder block:

```typescript
interface BindingErrorPlaceholder {
  type: 'binding-error';
  blockType: BlockType;
  error: BindingError;
  suggestions?: BindingSuggestion[];
  canRetry: boolean;
}

// Example adapter implementation
function renderBlockWithBindingCheck(
  block: Block,
  data: any,
  resolution: BindingResolutionResult
): RenderOutput {
  if (resolution.status === 'missing') {
    return renderPlaceholder({
      type: 'binding-error',
      blockType: block.type,
      error: resolution.error!,
      suggestions: resolution.suggestion ? [resolution.suggestion] : [],
      canRetry: true,
    });
  }

  if (resolution.status === 'inferred' || resolution.status === 'fallback') {
    // Render with warning indicator
    return renderBlockWithWarning(
      block,
      data,
      resolution.binding!,
      `Auto-bound field: ${resolution.suggestion?.field}`
    );
  }

  // Normal render
  return renderBlock(block, data, resolution.binding!);
}
```

**User Experience:**

Placeholder blocks for missing bindings MUST:
- Show the block type that was intended (e.g., "KPI (Missing Data)")
- Explain what field is missing or invalid
- Suggest alternatives if available (from suggestions)
- Provide a way to manually specify the correct binding
- Never crash or show technical error messages

**Error Reporting:**

Compilation MUST produce a warning (not error) for binding issues:

```typescript
interface BindingWarning {
  severity: 'warning';
  code: 'MISSING_REQUIRED_BINDING' | 'TYPE_MISMATCH' | 'FIELD_NOT_FOUND';
  message: string;
  blockUid: string;
  slot: BindingSlot;
  suggestion?: BindingSuggestion;
  autoFixed: boolean;
}

// Example warning
{
  severity: 'warning',
  code: 'MISSING_REQUIRED_BINDING',
  message: 'KPI block requires "value" binding but none provided. Auto-bound to "revenue" with 85% confidence.',
  blockUid: 'b_a7f3c9e2b4d1',
  slot: 'value',
  suggestion: {
    field: 'revenue',
    slot: 'value',
    confidence: 0.85,
    source: 'semantic_match',
    reason: 'Field "revenue" is numeric and matches KPI semantic pattern',
  },
  autoFixed: true,
}
```

### Integration Points

1. **Compilation Pipeline (§17)** - Add binding resolution phase before schema generation
2. **Coherence Gate (B.5)** - Binding coherence check validates all required bindings
3. **Adapter Contract (§18)** - Adapters must support binding error placeholders
4. **Error Handling (§19)** - Binding errors are Level 2 degradation (partial render)

### Examples

**Example 1: Missing Required Field**

```liquidcode
# User specifies KPI without binding
K

# Compilation detects missing required "value" binding
# Engine attempts inference from data fingerprint
# Data has fields: [revenue, orders, date]
# Inference: "revenue" is numeric → confidence 0.85
# Auto-bind with warning

# Compiled schema:
{
  "uid": "b_abc123",
  "type": "kpi",
  "binding": {
    "source": "default",
    "fields": [
      { "target": "value", "field": "revenue" }  // Auto-inferred
    ]
  }
}

# Warning emitted:
"KPI block auto-bound to 'revenue' (85% confidence). Verify if correct."
```

**Example 2: Field Not in Schema**

```liquidcode
# User specifies chart with non-existent field
L$date$profit

# Data fields: [date, revenue, orders]
# "profit" does not exist

# Coherence check fails
# Micro-LLM repair prompt: "Data has [date, revenue, orders]. User wants profit. Suggest alternative."
# Micro-LLM suggests: "revenue" (semantic similarity)

# Compiled schema:
{
  "uid": "b_def456",
  "type": "line-chart",
  "binding": {
    "source": "default",
    "fields": [
      { "target": "x", "field": "date" },
      { "target": "y", "field": "revenue" }  // Repaired from "profit"
    ]
  }
}

# Warning emitted:
"Field 'profit' not found. Using 'revenue' instead. Confidence: 70%"
```

**Example 3: Type Mismatch**

```liquidcode
# User specifies KPI with text field
K$customerName

# "customerName" is string type, incompatible with numeric "value" slot

# Inference attempts numeric field
# Suggests: "revenue" (first numeric field)

# Resolution: Cannot auto-fix (confidence < 0.5)
# Render as placeholder

# Placeholder shows:
"KPI: Cannot bind text field 'customerName' to numeric value.
Suggestions:
- revenue (numeric)
- orders (numeric)"
```

## Verification Checklist

- [x] **Comprehensive coverage** - Handles all binding failure scenarios
  - Missing field in data
  - Type mismatches
  - Non-existent field references
  - Incompatible aggregations
- [x] **Consistent with spec**
  - Follows soft-constraint philosophy (§9.3)
  - Integrates with coherence gate (§B.5)
  - Uses micro-LLM repair pattern (§B.5.5)
  - Follows degradation levels (§19.2)
- [x] **Preserves never-broken guarantee** (§19.3)
  - Compilation never fails for binding issues
  - Adapters can always render (placeholder if needed)
  - No runtime exceptions
- [x] **Clear fallback behavior**
  - Inference → Repair → Placeholder → Never crash
  - Deterministic resolution (same input = same output)
  - User-friendly error messages
- [x] **Integration defined**
  - Compilation pipeline integration
  - Adapter contract extension
  - Error reporting format
  - User experience requirements

## Confidence

**HIGH** - This resolution:

1. **Addresses root cause** - Defines complete resolution hierarchy for all binding failure modes
2. **Follows spec patterns** - Uses existing soft-constraint (§9.3), coherence (§B.5), and degradation (§19.2) mechanisms
3. **Preserves guarantees** - Maintains never-broken guarantee (§19.3) by ensuring compilation always succeeds
4. **Testable** - Clear deterministic behavior with specific confidence thresholds
5. **User-friendly** - Provides helpful error messages and suggestions, never cryptic failures
6. **Consistent** - Integrates with existing inference, repair, and placeholder systems throughout the spec
