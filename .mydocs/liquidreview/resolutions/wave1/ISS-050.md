# ISS-050: Position-Derived Identity Stability

## Issue Summary

**Type:** Technical Risk
**Severity:** High
**Location:** Block Addressing System (§8) vs. Interface Algebra (§7)
**Status:** RESOLVED

## Problem Statement

The addressing system (§8) proposes **position-derived addresses** as a zero-token-cost solution:

```liquidcode
@0, @1        # Pure ordinal
@K0, @K1      # Type ordinal
@[0,1]        # Grid position
```

**The Problem:** When mutations occur (add, remove, move blocks), positions shift:

```
Initial state:
  @K0 = Revenue KPI
  @K1 = Orders KPI
  @K2 = Profit KPI

After "Δ-@K0" (remove first KPI):
  @K0 = Orders KPI   ← SHIFTED (was @K1)
  @K1 = Profit KPI   ← SHIFTED (was @K2)
```

**Impact:** Multi-step mutations or delayed operations target the wrong blocks.

### Example Failure Scenario

```liquidcode
# User says: "Remove the Revenue KPI and change the Orders KPI label"

# LLM generates:
Δ[-@K0, ~@K1.label:"Total Orders"]

# Execution:
1. Remove @K0 (Revenue) ✓
2. @K1 now points to Profit (was Orders) ✗
3. Wrong block gets edited
```

## Analysis

### Why This Matters

Position-based addressing is attractive because:
- ✅ Zero tokens to generate (no ID needed in LLM output)
- ✅ Human-readable (@K0 = "first KPI")
- ✅ Natural for UI selection (click a block → get its position)

But it's fragile:
- ❌ Addresses invalidate on insertion/removal
- ❌ Batch operations have order dependencies
- ❌ Undo/redo breaks address continuity
- ❌ Concurrent mutations cause race conditions

### Current Spec Handling

The spec **partially addresses this** in Appendix B.2 (Hardening):

> **B.2 Stable Block Identity (UID System)**
>
> Every block has a stable `uid`. Positional selectors resolve to uids at mutation time.

However:
1. §8 (main addressing chapter) doesn't mention this
2. The resolution algorithm is underspecified
3. No guidance on when to use UIDs vs. positions

## Resolution

### Decision

**ADOPT TWO-PHASE ADDRESSING:** Position-based for generation, UID-based for execution.

### How It Works

```
┌─────────────────────────────────────────────────────┐
│ Phase 1: Generation (LLM Output)                    │
│   LLM uses position-based addresses (cheap tokens)  │
│   Example: Δ~@K1.label:"New"                        │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│ Phase 2: Resolution (Compile Time)                  │
│   Engine resolves @K1 → uid (e.g., b_a7f3c9e2b4d1)  │
│   Locks to UID before execution                     │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│ Phase 3: Execution (Mutation Application)           │
│   Operations target UIDs, immune to position shift  │
└─────────────────────────────────────────────────────┘
```

### Resolution Algorithm

Add this to §8 after §8.3:

```markdown
### 8.3.1 Address Resolution and Locking

**Critical principle:** Position-based addresses are **resolved once** at mutation compile time and **locked to UIDs** for execution.

#### Resolution Process

When the engine receives a mutation:

1. **Parse selectors** - Extract all addresses from LiquidCode
   - `Δ~@K1.label:"New"` → selector: `@K1`

2. **Snapshot current state** - Capture schema before any changes
   - Current schema hash: `h_abc123`
   - @K1 resolves to block with uid: `b_xyz789`

3. **Resolve to UIDs** - Map each selector to uid(s)
   - `@K1` → `b_xyz789` (Orders KPI)

4. **Lock targets** - Store resolution result
   ```typescript
   {
     originalSelector: "@K1",
     resolvedUid: "b_xyz789",
     schemaHash: "h_abc123",
     timestamp: 1640000000
   }
   ```

5. **Execute operations** - All operations use UIDs
   - Modify block `b_xyz789` (not "@K1")

#### Batch Operation Ordering

For batch mutations like `Δ[-@K0, ~@K1.label:"New"]`:

1. **Resolve all selectors against the same snapshot** (pre-mutation state)
   - `@K0` → `b_revenue` (Revenue KPI)
   - `@K1` → `b_orders` (Orders KPI)

2. **Execute operations in dependency order**
   - Removes first (don't affect other targets)
   - Then modifications
   - Then additions (don't shift existing positions)

3. **All operations see stable UIDs** - No mid-batch address drift

#### Example: Stable Multi-Step Mutation

```liquidcode
# User: "Remove Revenue and rename Orders"
Δ[-@K0, ~@K1.label:"Total Orders"]

# Resolution (before execution):
@K0 → b_rev123 (Revenue)
@K1 → b_ord456 (Orders)

# Execution:
1. Remove b_rev123 ✓
2. Modify b_ord456.label ✓ (UID is stable, position has shifted but doesn't matter)

# Result:
✅ Orders KPI (now at position @K0) has label "Total Orders"
```
```

### Update §8.2 Address Hierarchy Table

Add a column for "Stability":

```markdown
| Address Form | Syntax | Meaning | Token Cost | Stability |
|--------------|--------|---------|------------|-----------|
| Pure ordinal | `@0`, `@1` | Nth block in flat order | 1 token | ⚠️ Resolves to UID at mutation time |
| Type ordinal | `@K0`, `@L1` | Nth block of type | 1 token | ⚠️ Resolves to UID at mutation time |
| Grid position | `@[0,1]` | Row, column | 1 token | ⚠️ Resolves to UID at mutation time |
| Binding signature | `@:revenue` | Block bound to field | 2 tokens | ⚠️ Resolves to UID at mutation time |
| Explicit ID | `@#myId` | User-assigned ID | 2 tokens | ✅ Stable (ID is immutable) |
| UID (internal) | `b_xyz789` | System-generated UID | N/A | ✅ Perfectly stable (immutable) |
```

### Add Guidance for When to Use Each

Add this subsection to §8:

```markdown
### 8.7 Addressing Strategy Recommendations

| Use Case | Recommended Address | Reason |
|----------|---------------------|--------|
| **LLM generation** | Position-based (@K0, @[0,1]) | Minimal tokens, human-readable |
| **User interaction** | Position-based | Natural (click → position) |
| **Stored mutations** | Explicit ID (@#myId) | Survives schema changes |
| **API operations** | Explicit ID or UID | Predictable across versions |
| **Undo/redo** | UID (internal) | Immune to all changes |
| **Batch operations** | Position-based (resolved atomically) | Engine handles resolution |

**Key insight:** Position addresses are **generation-friendly**, UID/ID addresses are **execution-stable**. The engine bridges the gap through resolution.
```

## Verification

### Test Cases

Add these to the conformance test suite:

```typescript
// Test: Position stability under mutation
test('position addresses resolve to stable UIDs', () => {
  const schema = compile('#overview;G2x2;K$revenue,K$orders,K$profit');

  // Get UID of second KPI
  const ordersUid = resolveAddress(schema, '@K1').uid;

  // Remove first KPI
  const mutated = applyMutation(schema, 'Δ-@K0');

  // Second KPI is now at position 0, but UID unchanged
  expect(resolveAddress(mutated, '@K0').uid).toBe(ordersUid);
});

// Test: Batch operations resolve against same snapshot
test('batch operations resolve to snapshot, not progressive state', () => {
  const schema = compile('#overview;G2x2;K$revenue,K$orders,K$profit');

  const k0Uid = resolveAddress(schema, '@K0').uid;
  const k1Uid = resolveAddress(schema, '@K1').uid;

  // Both selectors should resolve against initial state
  const ops = parseMutation('Δ[-@K0, ~@K1.label:"New"]');

  expect(ops[0].targetUid).toBe(k0Uid); // Remove revenue
  expect(ops[1].targetUid).toBe(k1Uid); // Modify orders (not profit)
});
```

### Documentation Cross-References

Ensure these sections align:

- ✅ §7 (Interface Algebra) - Mentions addressing but defers to §8
- ✅ §8 (Addressing) - Now includes resolution algorithm
- ✅ §16.2 (Operation History) - Operations store UIDs, not positions
- ✅ §B.2 (Hardening) - Stable UID requirement
- ✅ Appendix A.1 (Quick Reference) - Note that positions resolve to UIDs

## Impact Assessment

### Sections Modified

- **§8.2** - Added "Stability" column to address hierarchy table
- **§8.3.1** (NEW) - Resolution and locking algorithm
- **§8.7** (NEW) - Addressing strategy recommendations

### Breaking Changes

None - this is a **clarification** of how the system must work, not a change to the external API.

### Implementation Requirements

Implementations MUST:

1. **Generate stable UIDs** for all blocks at creation time
   - Format: `b_[a-z0-9]{12}`
   - Immutable for block lifetime

2. **Resolve addresses before execution**
   - Position selectors → UIDs before applying mutations
   - Batch operations resolve against single snapshot

3. **Store UIDs in operation history**
   - Undo/redo operates on UIDs, not positions

4. **Support explicit IDs**
   - User-assigned IDs for stable cross-version references
   - `@#myId` resolves to UID at runtime

## Examples

### Example 1: Safe Removal and Edit

```liquidcode
# Before:
#   @K0 = Revenue (uid: b_rev)
#   @K1 = Orders (uid: b_ord)
#   @K2 = Profit (uid: b_pro)

# Mutation:
Δ[-@K0, ~@K1.label:"Total Orders"]

# Resolution:
@K0 → b_rev
@K1 → b_ord

# Execution:
- Remove b_rev
- Modify b_ord.label (even though it's now at position @K0)

# Result: ✅ Correct
```

### Example 2: Multi-Step Workflow with Explicit IDs

```liquidcode
# Generation with explicit IDs:
#overview;G2x2;K$revenue#main_revenue,K$orders#main_orders

# Later mutation (after many changes):
Δ~@#main_revenue.format:"$0,0.00"

# Resolution:
@#main_revenue → b_xyz789 (stable regardless of position)

# Result: ✅ Always targets the right block
```

## Sign-off

- [x] Resolution algorithm specified
- [x] Two-phase addressing (position → UID) documented
- [x] Batch operation semantics clarified
- [x] Stability guarantees explicit
- [x] Test cases defined
- [x] No breaking changes to external API

---

**Resolved By:** LiquidCode Analysis Team
**Date:** 2025-12-21
**Resolution Type:** Specification Enhancement (Clarification + Algorithm)
