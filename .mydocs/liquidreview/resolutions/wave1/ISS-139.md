# Resolution: ISS-139

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Create Comprehensive Test Suite
**Severity:** Minor
**Target:** SPEC
**Section:** Appendix B.3.3 (expansion)

## Resolution

### Original Content (Lines 2077-2103)
```markdown
#### B.3.3 Conformance Test Suite

Minimum tests for adapter certification:

```typescript
const conformanceTests = [
  // Block rendering
  'renders all 13 core block types',
  'renders placeholder for unknown block type',
  'renders empty state for null data',
  'renders empty state for mismatched data shape',

  // Error handling
  'does not throw on malformed binding',
  'does not throw on invalid signal reference',
  'completes within timeout for large data',
  'recovers from partial data fetch failure',

  // Degradation
  'shows placeholder with reason for unsupported features',
  'maintains layout when some blocks fail',
  'provides fallback for entire schema failure',

  // Signals
  'handles signal with no subscribers',
  'handles signal emit during render',
  'does not deadlock on circular signal reference',
];
```
```

### Replacement Content
```markdown
#### B.3.3 Conformance Test Suite

This section defines the complete test suite for validating LiquidCode implementations. Tests are categorized by component and include acceptance criteria for each.

---

##### B.3.3.1 Test Categories

The test suite is organized into 10 categories:

| Category | Test Count | Purpose |
|----------|------------|---------|
| **Parser Tests** | 50+ | Validate LiquidCode → AST conversion |
| **Compiler Tests** | 30+ | Validate AST → LiquidSchema conversion |
| **Addressing Tests** | 25+ | Validate block selector resolution |
| **Binding Tests** | 20+ | Validate data binding and inference |
| **Signal Tests** | 25+ | Validate signal system behavior |
| **Layout Tests** | 20+ | Validate layout constraint resolution |
| **State Tests** | 15+ | Validate Digital Twin and history |
| **Adapter Tests** | 30+ | Validate adapter conformance |
| **Integration Tests** | 20+ | Validate end-to-end workflows |
| **Performance Tests** | 15+ | Validate latency and token targets |

**Total:** 250+ test cases minimum

---

##### B.3.3.2 Parser Tests (50+ tests)

**Purpose:** Ensure parser correctly converts LiquidCode to AST

**Test groups:**

**A. Generation Syntax (15 tests)**
```typescript
describe('Parser: Generation Syntax', () => {
  it('parses simple archetype', () => {
    expect(parse('#overview')).toMatchAST({ archetype: 'overview' });
  });

  it('parses archetype with layout', () => {
    expect(parse('#overview;G2x2')).toMatchAST({
      archetype: 'overview',
      layout: { type: 'grid', rows: 2, cols: 2 }
    });
  });

  it('parses archetype with blocks', () => {
    expect(parse('#overview;G2x2;K$revenue,L$date$amount')).toMatchAST({
      archetype: 'overview',
      layout: { type: 'grid', rows: 2, cols: 2 },
      blocks: [
        { type: 'kpi', bindings: [{ field: 'revenue' }] },
        { type: 'line-chart', bindings: [{ field: 'date' }, { field: 'amount' }] }
      ]
    });
  });

  it('parses all 13 block type codes', () => {
    const codes = ['K', 'B', 'L', 'P', 'T', 'G', 'S', 'X', 'M', 'C', 'DF', 'SF', 'SI'];
    codes.forEach(code => {
      expect(parse(`#test;S;${code}`)).toHaveBlock(code);
    });
  });

  it('parses block with multiple bindings', () => {
    expect(parse('#test;S;L$date$revenue$orders')).toHaveBindingCount(3);
  });

  // ... 10 more generation syntax tests
});
```

**B. Signal Syntax (10 tests)**
```typescript
describe('Parser: Signal Syntax', () => {
  it('parses signal declaration (ASCII)', () => {
    expect(parse('signal:dateRange:dr=30d,url')).toMatchAST({
      signals: { dateRange: { type: 'dr', default: '30d', persist: 'url' } }
    });
  });

  it('parses signal declaration (Unicode)', () => {
    expect(parse('§dateRange:dr=30d,url')).toMatchAST({
      signals: { dateRange: { type: 'dr', default: '30d', persist: 'url' } }
    });
  });

  it('parses emit signal', () => {
    expect(parse('DF>@dateRange')).toHaveSignalEmit('dateRange');
  });

  it('parses receive signal', () => {
    expect(parse('K$revenue<@dateRange')).toHaveSignalReceive('dateRange');
  });

  it('parses bidirectional signal', () => {
    expect(parse('DF<>@dateRange')).toBothEmitAndReceive('dateRange');
  });

  // ... 5 more signal syntax tests
});
```

**C. Mutation Syntax (15 tests)**
```typescript
describe('Parser: Mutation Syntax', () => {
  it('parses add mutation (ASCII)', () => {
    expect(parse('delta:+K$profit@[1,2]')).toMatchMutation({
      type: 'add',
      block: { type: 'kpi', bindings: [{ field: 'profit' }] },
      position: [1, 2]
    });
  });

  it('parses add mutation (Unicode)', () => {
    expect(parse('Δ+K$profit@[1,2]')).toMatchMutation({
      type: 'add',
      block: { type: 'kpi', bindings: [{ field: 'profit' }] },
      position: [1, 2]
    });
  });

  it('parses remove mutation', () => {
    expect(parse('delta:-@K1')).toMatchMutation({
      type: 'remove',
      target: '@K1'
    });
  });

  it('parses replace mutation', () => {
    expect(parse('delta:@P0->B')).toMatchMutation({
      type: 'replace',
      target: '@P0',
      newType: 'bar-chart'
    });
  });

  it('parses modify mutation', () => {
    expect(parse('delta:~@K0.label:"New Label"')).toMatchMutation({
      type: 'modify',
      target: '@K0',
      property: 'label',
      value: 'New Label'
    });
  });

  it('parses move mutation (ASCII)', () => {
    expect(parse('delta:move:@K0->[1,1]')).toMatchMutation({
      type: 'move',
      target: '@K0',
      position: [1, 1]
    });
  });

  it('parses move mutation (Unicode)', () => {
    expect(parse('Δ↑@K0→[1,1]')).toMatchMutation({
      type: 'move',
      target: '@K0',
      position: [1, 1]
    });
  });

  it('parses batch mutations', () => {
    expect(parse('delta:[-@K1,~@K0.label:"New",+L$trend@[2,0]]')).toHaveMutationCount(3);
  });

  // ... 7 more mutation syntax tests
});
```

**D. Layout Syntax (10 tests)**
```typescript
describe('Parser: Layout Syntax', () => {
  it('parses priority modifier (hero)', () => {
    expect(parse('#test;S;K$revenue!hero')).toHaveBlockPriority('hero');
  });

  it('parses priority modifier (numeric)', () => {
    expect(parse('#test;S;K$revenue!1')).toHaveBlockPriority(1);
  });

  it('parses flexibility modifier', () => {
    expect(parse('#test;S;K$revenue^fixed')).toHaveBlockFlex('fixed');
  });

  it('parses span modifier', () => {
    expect(parse('#test;S;L$trend*full')).toHaveBlockSpan('full');
  });

  it('parses combined modifiers', () => {
    expect(parse('#test;S;K$revenue!hero^fixed*2')).toMatchBlock({
      priority: 'hero',
      flex: 'fixed',
      span: 2
    });
  });

  it('parses group relationship', () => {
    expect(parse('[K$a K$b K$c]=group')).toHaveRelationship('group', 3);
  });

  // ... 4 more layout syntax tests
});
```

**E. Error Handling (10 tests)**
```typescript
describe('Parser: Error Handling', () => {
  it('rejects empty input', () => {
    expect(() => parse('')).toThrow('Empty input');
  });

  it('rejects invalid archetype syntax', () => {
    expect(() => parse('overview')).toThrow('Expected # at start');
  });

  it('rejects double delimiter', () => {
    expect(() => parse('#overview;;K$revenue')).toThrow('Unexpected delimiter');
  });

  it('rejects unknown block type', () => {
    expect(() => parse('#test;S;Z$field')).toThrow('Unknown block type: Z');
  });

  it('provides line and column in error', () => {
    const error = getParseError('#test\n#invalid');
    expect(error).toHaveLineNumber(2);
    expect(error).toHaveColumn(1);
  });

  it('suggests fix for common mistake', () => {
    const error = getParseError('delta~@K0');  // Missing colon
    expect(error.suggestion).toContain('delta:~@K0');
  });

  // ... 4 more error handling tests
});
```

---

##### B.3.3.3 Compiler Tests (30+ tests)

**Purpose:** Ensure compiler correctly converts AST to LiquidSchema

**Test groups:**

**A. Basic Compilation (10 tests)**
```typescript
describe('Compiler: Basic Compilation', () => {
  it('compiles simple AST to schema', () => {
    const ast = { archetype: 'overview', blocks: [{ type: 'kpi' }] };
    const schema = compile(ast);
    expect(schema.version).toBe('2.0');
    expect(schema.blocks).toHaveLength(1);
  });

  it('generates unique UIDs for blocks', () => {
    const ast = { blocks: [{ type: 'kpi' }, { type: 'kpi' }] };
    const schema = compile(ast);
    expect(schema.blocks[0].uid).not.toBe(schema.blocks[1].uid);
    expect(schema.blocks[0].uid).toMatch(/^b_[a-z0-9]{12}$/);
  });

  it('compiles deterministically (same structure)', () => {
    const ast = { blocks: [{ type: 'kpi', bindings: [{ field: 'revenue' }] }] };
    const schema1 = compile(ast);
    const schema2 = compile(ast);
    // UIDs differ, but canonical hash matches
    expect(canonicalize(schema1)).toBe(canonicalize(schema2));
  });

  it('validates schema with Zod', () => {
    const ast = { blocks: [{ type: 'kpi' }] };
    const schema = compile(ast);
    expect(() => LiquidSchemaSchema.parse(schema)).not.toThrow();
  });

  // ... 6 more basic compilation tests
});
```

**B. Signal Compilation (5 tests)**
```typescript
describe('Compiler: Signal Compilation', () => {
  it('creates signal registry from AST', () => {
    const ast = {
      signals: { dateRange: { type: 'dr', default: '30d', persist: 'url' } },
      blocks: []
    };
    const schema = compile(ast);
    expect(schema.signals).toBeDefined();
    expect(schema.signals.dateRange).toMatchObject({ type: 'dateRange', persist: 'url' });
  });

  it('connects emit to registry', () => {
    const ast = {
      signals: { dateRange: { type: 'dr' } },
      blocks: [{ type: 'date-filter', emits: ['dateRange'] }]
    };
    const schema = compile(ast);
    expect(schema.blocks[0].signals.emits[0].signal).toBe('dateRange');
  });

  // ... 3 more signal compilation tests
});
```

**C. Layout Compilation (5 tests)**
```typescript
describe('Compiler: Layout Compilation', () => {
  it('compiles grid layout', () => {
    const ast = { layout: { type: 'grid', rows: 2, cols: 2 } };
    const schema = compile(ast);
    expect(schema.layout.type).toBe('grid');
  });

  it('applies layout modifiers to blocks', () => {
    const ast = { blocks: [{ type: 'kpi', priority: 'hero', flex: 'fixed' }] };
    const schema = compile(ast);
    expect(schema.blocks[0].layout.priority).toBe('hero');
    expect(schema.blocks[0].layout.flex).toBe('fixed');
  });

  // ... 3 more layout compilation tests
});
```

**D. Validation & Errors (10 tests)**
```typescript
describe('Compiler: Validation & Errors', () => {
  it('rejects AST with unresolved signal reference', () => {
    const ast = { blocks: [{ type: 'kpi', receives: ['unknownSignal'] }] };
    expect(() => compile(ast)).toThrow('Signal not in registry: unknownSignal');
  });

  it('rejects AST with invalid block type', () => {
    const ast = { blocks: [{ type: 'invalid' }] };
    expect(() => compile(ast)).toThrow('Invalid block type');
  });

  it('rejects AST with missing required binding', () => {
    const ast = { blocks: [{ type: 'kpi', bindings: [] }] };  // KPI requires value
    expect(() => compile(ast)).toThrow('Missing required binding: value');
  });

  // ... 7 more validation tests
});
```

---

##### B.3.3.4 Addressing Tests (25+ tests)

**Purpose:** Ensure address resolution is correct and stable

**Test groups:**

**A. Basic Resolution (10 tests)**
```typescript
describe('Addressing: Basic Resolution', () => {
  const schema = createTestSchema([
    { uid: 'b_001', type: 'kpi', id: 'main', binding: { fields: [{ field: 'revenue' }] } },
    { uid: 'b_002', type: 'kpi', binding: { fields: [{ field: 'orders' }] } },
    { uid: 'b_003', type: 'line-chart' },
  ]);

  it('resolves explicit ID', () => {
    expect(resolve('@#main', schema)).toEqual(['b_001']);
  });

  it('resolves type ordinal', () => {
    expect(resolve('@K0', schema)).toEqual(['b_001']);
    expect(resolve('@K1', schema)).toEqual(['b_002']);
    expect(resolve('@L0', schema)).toEqual(['b_003']);
  });

  it('resolves binding signature', () => {
    expect(resolve('@:revenue', schema)).toEqual(['b_001']);
  });

  it('resolves pure ordinal', () => {
    expect(resolve('@0', schema)).toEqual(['b_001']);
    expect(resolve('@1', schema)).toEqual(['b_002']);
  });

  it('resolves grid position', () => {
    const gridSchema = { ...schema, layout: { type: 'grid', rows: 2, cols: 2 } };
    expect(resolve('@[0,0]', gridSchema)).toEqual(['b_001']);  // Assuming position
  });

  // ... 5 more basic resolution tests
});
```

**B. Wildcard Resolution (10 tests)**
```typescript
describe('Addressing: Wildcard Resolution', () => {
  it('resolves type wildcard', () => {
    expect(resolve('@K*', schema)).toEqual(['b_001', 'b_002']);
  });

  it('resolves column wildcard', () => {
    expect(resolve('@[*,0]', gridSchema)).toMatchArrayContaining([/* blocks in column 0 */]);
  });

  it('resolves binding wildcard', () => {
    expect(resolve('@:*revenue*', schema)).toMatchArrayContaining(['b_001']);
  });

  // ... 7 more wildcard tests
});
```

**C. Priority & Ambiguity (5 tests)**
```typescript
describe('Addressing: Priority & Ambiguity', () => {
  it('prioritizes explicit ID over position', () => {
    const schema = {
      blocks: [
        { uid: 'b_001', id: 'first', /* ... */ },
        { uid: 'b_002', id: 'second', /* ... */ }
      ]
    };
    expect(resolve('@#first', schema)).toEqual(['b_001']);  // Not @0
  });

  it('detects ambiguous singular selector', () => {
    const result = resolve('@K*', schema);  // Returns multiple
    expect(result.length).toBeGreaterThan(1);
    expect(() => resolveSingular('@K*', schema)).toThrow('Ambiguous selector');
  });

  // ... 3 more priority/ambiguity tests
});
```

---

##### B.3.3.5 Binding Tests (20+ tests)

**Purpose:** Ensure binding system correctly matches data to slots

**Test groups:**

**A. Type Matching (8 tests)**
```typescript
describe('Binding: Type Matching', () => {
  it('matches number to value slot', () => {
    expect(matchType('number', 'value')).toBe(true);
  });

  it('matches date to x slot', () => {
    expect(matchType('date', 'x')).toBe(true);
  });

  it('matches string to category slot', () => {
    expect(matchType('string', 'category')).toBe(true);
  });

  it('rejects number for category slot', () => {
    expect(matchType('number', 'category')).toBe(false);
  });

  // ... 4 more type matching tests
});
```

**B. Semantic Matching (6 tests)**
```typescript
describe('Binding: Semantic Matching', () => {
  it('scores "revenue" high for value slot', () => {
    expect(semanticScore('revenue', 'value')).toBeGreaterThan(0.7);
  });

  it('scores "order_date" high for x slot', () => {
    expect(semanticScore('order_date', 'x')).toBeGreaterThan(0.7);
  });

  it('scores "region" high for category slot', () => {
    expect(semanticScore('region', 'category')).toBeGreaterThan(0.7);
  });

  // ... 3 more semantic matching tests
});
```

**C. Suggestion System (6 tests)**
```typescript
describe('Binding: Suggestion System', () => {
  const data = { date: [/* dates */], revenue: [/* numbers */], region: [/* strings */] };

  it('suggests correct bindings for KPI', () => {
    const suggestions = suggestBindings('kpi', fingerprintData(data));
    expect(suggestions).toContainBinding({ slot: 'value', field: 'revenue', score: '>0.8' });
  });

  it('suggests correct bindings for line chart', () => {
    const suggestions = suggestBindings('line-chart', fingerprintData(data));
    expect(suggestions).toContainBinding({ slot: 'x', field: 'date' });
    expect(suggestions).toContainBinding({ slot: 'y', field: 'revenue' });
  });

  it('respects user explicit bindings over suggestions', () => {
    const userBinding = { slot: 'value', field: 'region' };  // Odd but explicit
    expect(applyBinding(userBinding, suggestions)).toBe(userBinding);  // User wins
  });

  // ... 3 more suggestion tests
});
```

---

##### B.3.3.6 Signal Tests (25+ tests)

**Purpose:** Ensure signal system behaves correctly

**Test groups:**

**A. Registry & Runtime (8 tests)**
```typescript
describe('Signals: Registry & Runtime', () => {
  it('creates registry from definitions', () => {
    const registry = new SignalRegistry({
      dateRange: { type: 'dateRange', default: { start: '2024-01-01', end: '2024-12-31' } }
    });
    expect(registry.get('dateRange')).toBeDefined();
  });

  it('gets default value before emit', () => {
    const runtime = createSignalRuntime(registry);
    expect(runtime.get('dateRange')).toEqual({ start: '2024-01-01', end: '2024-12-31' });
  });

  it('sets and gets signal value', () => {
    runtime.set('dateRange', { start: '2024-06-01', end: '2024-06-30' });
    expect(runtime.get('dateRange')).toEqual({ start: '2024-06-01', end: '2024-06-30' });
  });

  it('subscribes to signal changes', () => {
    const callback = jest.fn();
    runtime.subscribe('dateRange', callback);
    runtime.set('dateRange', { start: '2024-07-01', end: '2024-07-31' });
    expect(callback).toHaveBeenCalledWith({ start: '2024-07-01', end: '2024-07-31' });
  });

  // ... 4 more registry/runtime tests
});
```

**B. Persistence (7 tests)**
```typescript
describe('Signals: Persistence', () => {
  it('serializes to URL', () => {
    runtime.set('dateRange', { start: '2024-06-01', end: '2024-06-30' });
    const url = runtime.persistToURL();
    expect(url).toContain('dateRange=');
  });

  it('deserializes from URL', () => {
    const url = '?dateRange=2024-06-01,2024-06-30';
    const restored = SignalRuntime.fromURL(url, registry);
    expect(restored.get('dateRange')).toEqual({ start: '2024-06-01', end: '2024-06-30' });
  });

  it('persists to session storage', () => {
    runtime.set('category', 'Electronics');
    runtime.persistToSession();
    expect(sessionStorage.getItem('signals.category')).toBe('"Electronics"');
  });

  // ... 4 more persistence tests
});
```

**C. Emit & Receive (5 tests)**
```typescript
describe('Signals: Emit & Receive', () => {
  it('emits signal on block interaction', () => {
    const emitter = { type: 'date-filter', emits: [{ signal: 'dateRange', trigger: 'onChange' }] };
    const callback = jest.fn();
    runtime.subscribe('dateRange', callback);
    emitSignal(emitter, 'dateRange', { start: '2024-08-01', end: '2024-08-31' });
    expect(callback).toHaveBeenCalled();
  });

  it('receives signal and updates binding', () => {
    const receiver = { type: 'line-chart', receives: [{ signal: 'dateRange', target: 'filter.date' }] };
    runtime.set('dateRange', { start: '2024-06-01', end: '2024-06-30' });
    const updatedBinding = receiveSignal(receiver, runtime);
    expect(updatedBinding.filter.date).toEqual({ start: '2024-06-01', end: '2024-06-30' });
  });

  // ... 3 more emit/receive tests
});
```

**D. Edge Cases (5 tests)**
```typescript
describe('Signals: Edge Cases', () => {
  it('handles signal with no subscribers', () => {
    expect(() => runtime.set('orphanSignal', 'value')).not.toThrow();
  });

  it('handles emit during render', () => {
    // Emit while component is rendering
    expect(() => emitSignal(block, 'signal', 'value')).not.toThrow();
  });

  it('detects circular signal dependency', () => {
    const circular = {
      signals: {
        a: { type: 'custom' },
        b: { type: 'custom' }
      },
      blocks: [
        { emits: [{ signal: 'a' }], receives: [{ signal: 'b' }] },
        { emits: [{ signal: 'b' }], receives: [{ signal: 'a' }] }
      ]
    };
    expect(detectCircularSignals(circular)).toBe(true);
  });

  // ... 2 more edge case tests
});
```

---

##### B.3.3.7 Layout Tests (20+ tests)

**Purpose:** Ensure layout system resolves constraints correctly

**Test groups:**

**A. Priority System (5 tests)**
```typescript
describe('Layout: Priority System', () => {
  it('hero blocks always visible', () => {
    const layout = resolveLayout(schema, { breakpoint: 'compact' });
    const heroBlocks = layout.visibleBlocks.filter(uid => getBlock(uid).layout.priority === 'hero');
    expect(heroBlocks.length).toBeGreaterThan(0);
  });

  it('detail blocks hidden on compact', () => {
    const layout = resolveLayout(schema, { breakpoint: 'compact' });
    const detailBlocks = schema.blocks.filter(b => b.layout.priority === 'detail');
    expect(layout.hiddenBlocks).toContainAll(detailBlocks.map(b => b.uid));
  });

  // ... 3 more priority tests
});
```

**B. Flexibility System (5 tests)**
```typescript
describe('Layout: Flexibility System', () => {
  it('fixed blocks maintain size', () => {
    const layout = resolveLayout(schema, { width: 800 });
    const fixedBlock = schema.blocks.find(b => b.layout.flex === 'fixed');
    expect(layout.cells.find(c => c.blockId === fixedBlock.uid).width).toBe(fixedBlock.layout.size.ideal);
  });

  it('grow blocks expand to fill space', () => {
    const layout = resolveLayout(schema, { width: 1400 });
    const growBlock = schema.blocks.find(b => b.layout.flex === 'grow');
    expect(layout.cells.find(c => c.blockId === growBlock.uid).width).toBeGreaterThan(growBlock.layout.size.ideal);
  });

  // ... 3 more flexibility tests
});
```

**C. Responsive Transformation (5 tests)**
```typescript
describe('Layout: Responsive Transformation', () => {
  it('transforms grid to stack on mobile', () => {
    const layout = resolveLayout(schema, { breakpoint: 'compact', width: 375 });
    expect(layout.layout).toBe('stack');  // Grid → Stack
  });

  it('maintains grid on desktop', () => {
    const layout = resolveLayout(schema, { breakpoint: 'expanded', width: 1400 });
    expect(layout.layout).toBe('grid');
  });

  // ... 3 more responsive tests
});
```

**D. Constraint Solver (5 tests)**
```typescript
describe('Layout: Constraint Solver', () => {
  it('solves constraints in reasonable time', () => {
    const start = performance.now();
    resolveLayout(complexSchema, { width: 1200 });
    const duration = performance.now() - start;
    expect(duration).toBeLessThan(100);  // <100ms
  });

  it('terminates with conflicting constraints', () => {
    const conflicting = {
      blocks: [
        { layout: { flex: 'fixed', size: { ideal: 500 } } },
        { layout: { flex: 'fixed', size: { ideal: 500 } } },
        { layout: { flex: 'fixed', size: { ideal: 500 } } }
      ]
    };
    // Total 1500px in 1000px container
    expect(() => resolveLayout(conflicting, { width: 1000 })).not.toThrow();
    // Should use fallback layout
  });

  // ... 3 more solver tests
});
```

---

##### B.3.3.8 State Tests (15+ tests)

**Purpose:** Ensure Digital Twin and history work correctly

**Test groups:**

**A. Digital Twin (5 tests)**
```typescript
describe('State: Digital Twin', () => {
  it('initializes with schema', () => {
    const twin = new DigitalTwin(initialSchema);
    expect(twin.schema).toEqual(initialSchema);
    expect(twin.operationCount).toBe(0);
  });

  it('applies mutation and updates state', () => {
    const mutation = { type: 'modify', targetUid: 'b_001', property: 'label', value: 'New' };
    twin.apply(mutation);
    expect(twin.schema.blocks[0].label).toBe('New');
    expect(twin.operationCount).toBe(1);
  });

  // ... 3 more twin tests
});
```

**B. Operation History (5 tests)**
```typescript
describe('State: Operation History', () => {
  it('tracks operations in history', () => {
    twin.apply(mutation1);
    twin.apply(mutation2);
    expect(twin.history.operations.length).toBe(2);
  });

  it('undoes last operation', () => {
    twin.undo();
    expect(twin.schema.blocks[0].label).toBeUndefined();
    expect(twin.operationCount).toBe(1);
  });

  it('redoes undone operation', () => {
    twin.redo();
    expect(twin.schema.blocks[0].label).toBe('New');
    expect(twin.operationCount).toBe(2);
  });

  // ... 2 more history tests
});
```

**C. Snapshot Addressing (5 tests)**
```typescript
describe('State: Snapshot Addressing', () => {
  it('retrieves snapshot at index', () => {
    twin.apply(mutation1);
    twin.apply(mutation2);
    twin.apply(mutation3);
    const snapshot2 = twin.history.snapshot(2);
    expect(snapshot2).toBeDefined();
    // Snapshot2 should have mutation1 and mutation2 applied
  });

  it('queries block at snapshot', () => {
    const block = querySnapshot(twin, '@K0', 2);
    expect(block).toBeDefined();
  });

  // ... 3 more snapshot tests
});
```

---

##### B.3.3.9 Adapter Tests (30+ tests)

**Purpose:** Ensure adapters conform to contract and render correctly

**Minimum tests for adapter certification (from §B.3):**

```typescript
const conformanceTests = [
  // Block rendering (13 tests, one per block type)
  'renders kpi block',
  'renders bar-chart block',
  'renders line-chart block',
  'renders pie-chart block',
  'renders data-table block',
  'renders grid layout',
  'renders stack layout',
  'renders text block',
  'renders metric-group block',
  'renders comparison block',
  'renders date-filter block',
  'renders select-filter block',
  'renders search-input block',

  // Error handling (4 tests)
  'renders placeholder for unknown block type',
  'renders empty state for null data',
  'renders empty state for mismatched data shape',
  'does not throw on malformed binding',

  // Signals (4 tests)
  'does not throw on invalid signal reference',
  'handles signal with no subscribers',
  'handles signal emit during render',
  'does not deadlock on circular signal reference',

  // Performance (2 tests)
  'completes within timeout for large data',
  'recovers from partial data fetch failure',

  // Degradation (3 tests)
  'shows placeholder with reason for unsupported features',
  'maintains layout when some blocks fail',
  'provides fallback for entire schema failure',

  // Accessibility (4 tests)
  'all blocks have ARIA labels',
  'keyboard navigation works',
  'focus indicators visible',
  'color contrast meets WCAG AA',
];

// Total: 30 conformance tests
```

**Additional adapter tests:**
```typescript
describe('Adapter: React Specific', () => {
  it('renders valid React elements', () => {
    const element = adapter.render(schema, data);
    expect(React.isValidElement(element)).toBe(true);
  });

  it('updates on data change', () => {
    const { rerender } = render(<LiquidAdapter schema={schema} data={data1} />);
    expect(screen.getByText('100')).toBeTruthy();
    rerender(<LiquidAdapter schema={schema} data={data2} />);
    expect(screen.getByText('200')).toBeTruthy();
  });

  // ... more React-specific tests
});
```

---

##### B.3.3.10 Integration Tests (20+ tests)

**Purpose:** Validate end-to-end workflows

**Test scenarios:**

```typescript
describe('Integration: Full Pipeline', () => {
  it('generates and renders sales dashboard', async () => {
    const liquidCode = '#overview;G2x2;K$revenue,K$orders,L$date$revenue,T$orders';
    const data = loadSampleData('sales');

    const tokens = tokenize(liquidCode);
    const ast = parse(tokens);
    const schema = compile(ast);
    const element = adapter.render(schema, data);

    expect(element).toBeTruthy();
    expect(schema.blocks).toHaveLength(4);
    expect(element.find('.kpi')).toHaveLength(2);
    expect(element.find('.line-chart')).toHaveLength(1);
    expect(element.find('.data-table')).toHaveLength(1);
  });

  it('applies mutation and re-renders', () => {
    const twin = new DigitalTwin(initialSchema);
    const mutation = parse('delta:~@K0.label:"Updated"');

    twin.apply(mutation);
    const element = adapter.render(twin.schema, data);

    expect(element).toHaveTextContent('Updated');
  });

  it('signals propagate through full system', () => {
    const schema = compileWithSignals(liquidCode);
    const runtime = adapter.createSignalRuntime(schema.signals);
    const { container } = render(<LiquidAdapter schema={schema} data={data} runtime={runtime} />);

    // Change date filter
    fireEvent.change(container.querySelector('input[type="date"]'), {
      target: { value: '2024-06-01' }
    });

    // Signal propagates to chart
    expect(runtime.get('dateRange').start).toBe('2024-06-01');
    // Chart re-renders with filtered data
    expect(container.querySelector('.line-chart')).toHaveFilteredData();
  });

  // ... 17 more integration tests
});
```

---

##### B.3.3.11 Performance Tests (15+ tests)

**Purpose:** Validate claimed performance metrics (§1.1)

**Test targets:**

```typescript
describe('Performance: Latency Targets', () => {
  it('parses in <10ms (P95)', () => {
    const durations = runBenchmark(() => parse(tokenize(sampleCode)), 100);
    expect(percentile(durations, 95)).toBeLessThan(10);
  });

  it('compiles in <50ms (P95)', () => {
    const durations = runBenchmark(() => compile(sampleAST), 100);
    expect(percentile(durations, 95)).toBeLessThan(50);
  });

  it('resolves address in <1ms (P95)', () => {
    const durations = runBenchmark(() => resolve('@K0', schema), 1000);
    expect(percentile(durations, 95)).toBeLessThan(1);
  });

  it('renders in <100ms (P95)', () => {
    const durations = runBenchmark(() => adapter.render(schema, data), 50);
    expect(percentile(durations, 95)).toBeLessThan(100);
  });

  it('full pipeline <200ms (P95, no LLM)', () => {
    const durations = runBenchmark(() => {
      const tokens = tokenize(code);
      const ast = parse(tokens);
      const schema = compile(ast);
      adapter.render(schema, data);
    }, 50);
    expect(percentile(durations, 95)).toBeLessThan(200);
  });
});

describe('Performance: Token Counts', () => {
  it('generation <60 tokens (P99)', () => {
    const samples = generateSamples('overview', 100);
    const tokenCounts = samples.map(code => tokenize(code).length);
    expect(percentile(tokenCounts, 99)).toBeLessThan(60);
  });

  it('mutation <15 tokens (P99)', () => {
    const samples = generateMutations(100);
    const tokenCounts = samples.map(code => tokenize(code).length);
    expect(percentile(tokenCounts, 99)).toBeLessThan(15);
  });
});

describe('Performance: Resource Usage', () => {
  it('bundle size <100KB (adapter)', () => {
    const bundleSize = measureBundleSize('@liquidcode/adapter-react');
    expect(bundleSize).toBeLessThan(100 * 1024);
  });

  it('memory usage <50MB (10-block dashboard)', () => {
    const memBefore = process.memoryUsage().heapUsed;
    const schema = compile(largeDashboard);
    adapter.render(schema, largeData);
    const memAfter = process.memoryUsage().heapUsed;
    expect(memAfter - memBefore).toBeLessThan(50 * 1024 * 1024);
  });
});
```

---

##### B.3.3.12 Test Execution

**Running the test suite:**

```bash
# All tests
npm test

# Category-specific
npm test -- parser
npm test -- compiler
npm test -- adapter

# Conformance only
npm test -- conformance

# Performance benchmarks
npm test -- performance --benchmark

# Coverage report
npm test -- --coverage
```

**Coverage targets:**
- Overall: ≥80% line coverage
- Core packages (parser, compiler): ≥85%
- Adapter: ≥70% (rendering varies by platform)

**CI/CD integration:**
```yaml
# .github/workflows/test.yml
name: Test Suite
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm test -- --coverage
      - run: npm test -- conformance
      - run: npm test -- performance
```

---

##### B.3.3.13 Test Data

**Sample datasets for testing:**

```typescript
// Time series data
const timeSeries = {
  date: ['2024-01-01', '2024-02-01', '2024-03-01', /* ... */],
  revenue: [12000, 15000, 14500, /* ... */],
  orders: [120, 150, 145, /* ... */],
};

// Comparison data
const comparison = {
  category: ['Q1', 'Q2', 'Q3', 'Q4'],
  current: [100, 120, 110, 130],
  previous: [90, 110, 105, 120],
};

// Funnel data
const funnel = {
  stage: ['Awareness', 'Interest', 'Decision', 'Action'],
  count: [10000, 5000, 1000, 500],
  percentage: [100, 50, 10, 5],
};

// Large dataset (for performance tests)
const largeData = {
  date: Array(1000).fill(0).map((_, i) => new Date(2024, 0, i + 1)),
  values: Array(1000).fill(0).map(() => Math.random() * 10000),
};

// Edge case data
const edgeCases = {
  nulls: [null, null, null],
  empty: [],
  missingFields: { date: [/* ... */] },  // Missing 'revenue'
  wrongTypes: { date: [1, 2, 3], revenue: ['a', 'b', 'c'] },  // Wrong types
};
```

---

##### B.3.3.14 Summary

The comprehensive test suite includes **250+ test cases** across 10 categories:

| Category | Tests | Purpose |
|----------|-------|---------|
| Parser | 50+ | Syntax correctness |
| Compiler | 30+ | AST → schema validity |
| Addressing | 25+ | Resolution accuracy |
| Binding | 20+ | Data matching |
| Signals | 25+ | Reactivity |
| Layout | 20+ | Constraint solving |
| State | 15+ | History & undo |
| Adapter | 30+ | Conformance |
| Integration | 20+ | End-to-end |
| Performance | 15+ | Latency & tokens |

**Total: 250+ tests**

**Acceptance criteria for implementations:**
- All conformance tests pass (30/30)
- ≥90% of category tests pass
- Performance tests meet spec targets (§1.1)
- ≥80% code coverage

Implementations passing this test suite are certified as **LiquidCode v2 compliant**.
```

## Verification Checklist
- [x] Change addresses the identified issue
- [x] No new inconsistencies introduced
- [x] Cross-references remain valid
- [x] Interface signatures unchanged (or documented)
- [x] Normative language (MUST/SHOULD/MAY) consistent

## Side Effects
- [ ] None
- [x] Expands existing section B.3.3 (replaces minimal test list with comprehensive suite)
- [x] Cross-reference from Appendix C (Implementation Guide) to this section for testing strategy
- [x] Cross-reference from Appendix D (Reference Implementation) to this section for conformance requirements
- [x] May impact test execution requirements for implementations

## Dependencies
- [ ] No dependencies on other issues
- [x] References Implementation Guide (Appendix C / ISS-136) for testing phases
- [x] References Reference Implementation (Appendix D / ISS-137) for test targets
- [x] References all core spec sections (§1, §5-§18, Appendix B)
- [ ] Blocks: None

## Confidence
**HIGH** - This comprehensive test suite expansion transforms the minimal 14-test list into a structured 250+ test specification with clear categories, acceptance criteria, and coverage targets. The test suite is organized by component, includes concrete test examples with code snippets, defines performance benchmarks aligned with spec claims (§1.1), and provides tooling guidance. This enables objective validation of LiquidCode implementations and adapter conformance.
