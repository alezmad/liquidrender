# Resolution: ISS-077 - Layout Constraint Solver Non-Termination

**Issue ID:** ISS-077
**Severity:** Critical
**Target Document:** `.mydocs/liquidcode/LIQUIDCODE-SPEC-v2.md`
**Review Source:** 08-edge-cases-failure-modes.md (Failure 2)
**Date:** 2025-12-21

---

## Problem Statement

**Current State:** The layout constraint solver lacks termination guarantees and conflict resolution when blocks have unsatisfiable minimum size requirements.

**Trigger Example:**
```liquidcode
# Three fixed blocks, each requiring 500px minimum
K1^fixed.min:500
K2^fixed.min:500
K3^fixed.min:500
# Total minimum: 1500px
# SlotContext.width: 400px
```

**Impact:**
- Solver loops indefinitely trying to satisfy unsatisfiable constraints
- Render timeout (5s default, §B.3.2)
- Falls back to placeholder, but timeout is user-hostile
- Resource exhaustion if many concurrent renders

**Current Handling:**
- §11: No mention of unsatisfiable constraints or solver termination
- PRD FR-LY-9: "Blocks can declare minimum and maximum size hints" but no conflict resolution
- §B.3.2: Timeout exists but is a last resort

---

## Resolution

### 1. Add Constraint Solver Algorithm to §11.12 (New Subsection)

Add the following after §11.11 (Responsive Transformation Rules):

```markdown
### 11.12 Layout Constraint Solver

#### 11.12.1 Solver Objective

The layout constraint solver computes concrete dimensions for all visible blocks given:
- **Input:** Block layout properties (priority, flexibility, size hints)
- **Context:** SlotContext (available width/height, breakpoint)
- **Output:** LayoutPlan with concrete dimensions for each block

**Guarantees:**
1. **Termination:** Solver MUST complete within maximum iterations (default: 1000)
2. **Feasibility:** Solver MUST produce a valid layout even if constraints conflict
3. **Priority Preservation:** Higher-priority blocks receive space first
4. **Graceful Degradation:** Unsatisfiable constraints result in block hiding, not failure

#### 11.12.2 Solver Algorithm

```typescript
interface SolverConfig {
  maxIterations: number;           // Default: 1000
  minBlockWidth: number;            // Default: 80px
  minBlockHeight: number;           // Default: 60px
  enableProgressiveRelaxation: boolean;  // Default: true
}

interface SolverState {
  iteration: number;
  remainingSpace: { width: number; height: number };
  allocations: Map<string, BlockAllocation>;
  unallocated: Block[];
  relaxationLevel: number;         // 0-4, higher = more relaxed
}

interface BlockAllocation {
  blockUid: string;
  width: number;
  height: number;
  row: number;
  column: number;
  rowSpan: number;
  colSpan: number;
  visible: boolean;
  reason?: string;                 // Why hidden if not visible
}

function solveLayout(
  schema: LiquidSchema,
  context: SlotContext,
  config: SolverConfig = DEFAULT_SOLVER_CONFIG
): LayoutPlan {
  const state: SolverState = initializeSolverState(schema, context);
  const priorityGroups = groupBlocksByPriority(schema.blocks);

  // Phase 1: Validate total minimum requirements
  const validationResult = validateMinimumRequirements(priorityGroups, context);
  if (!validationResult.feasible) {
    return applyProgressiveRelaxation(schema, context, validationResult, config);
  }

  // Phase 2: Allocate by priority
  for (const [priority, blocks] of priorityGroups) {
    for (const block of blocks) {
      if (state.iteration >= config.maxIterations) {
        console.warn(`Layout solver hit max iterations (${config.maxIterations})`);
        break;
      }

      const allocation = allocateBlock(block, state, context, config);
      if (allocation.visible) {
        state.allocations.set(block.uid, allocation);
        updateRemainingSpace(state, allocation);
      } else {
        state.unallocated.push(block);
      }

      state.iteration++;
    }
  }

  // Phase 3: Convert to LayoutPlan
  return buildLayoutPlan(state, context);
}
```

#### 11.12.3 Minimum Requirements Validation

Before attempting layout, validate that minimum requirements can be satisfied:

```typescript
interface ValidationResult {
  feasible: boolean;
  totalMinWidth: number;
  totalMinHeight: number;
  availableWidth: number;
  availableHeight: number;
  conflictingBlocks: ConflictInfo[];
}

interface ConflictInfo {
  blockUid: string;
  priority: number;
  minWidth: number;
  minHeight: number;
  reason: 'width' | 'height' | 'both';
}

function validateMinimumRequirements(
  priorityGroups: Map<number, Block[]>,
  context: SlotContext
): ValidationResult {
  let totalMinWidth = 0;
  let totalMinHeight = 0;
  const conflicting: ConflictInfo[] = [];

  // Calculate minimums by priority (only for fixed/required blocks)
  for (const [priority, blocks] of priorityGroups) {
    // Only hero (1) and primary (2) priorities count as required
    if (priority <= 2) {
      for (const block of blocks) {
        const minSize = getMinimumSize(block);

        // Fixed blocks contribute to total minimum
        if (block.layout?.flex === 'fixed') {
          totalMinWidth += minSize.width;
          totalMinHeight += minSize.height;

          // Check if this block alone exceeds available space
          if (minSize.width > context.width || minSize.height > context.height) {
            conflicting.push({
              blockUid: block.uid,
              priority,
              minWidth: minSize.width,
              minHeight: minSize.height,
              reason: minSize.width > context.width && minSize.height > context.height
                ? 'both'
                : minSize.width > context.width ? 'width' : 'height',
            });
          }
        }
      }
    }
  }

  return {
    feasible: totalMinWidth <= context.width && totalMinHeight <= context.height,
    totalMinWidth,
    totalMinHeight,
    availableWidth: context.width,
    availableHeight: context.height,
    conflictingBlocks: conflicting,
  };
}

function getMinimumSize(block: Block): { width: number; height: number } {
  // Use explicit minimums if provided
  if (block.layout?.size?.min) {
    const min = block.layout.size.min;
    return {
      width: typeof min === 'number' ? min : parseSize(min, 'width'),
      height: typeof min === 'number' ? min : parseSize(min, 'height'),
    };
  }

  // Fall back to intrinsic block minimums (§11.9)
  const intrinsic = INTRINSIC_BLOCK_SIZES[block.type];
  return {
    width: intrinsic?.minWidth ?? 100,
    height: intrinsic?.height ?? 80,
  };
}
```

#### 11.12.4 Progressive Relaxation

When constraints are unsatisfiable, apply progressive relaxation:

```typescript
function applyProgressiveRelaxation(
  schema: LiquidSchema,
  context: SlotContext,
  validation: ValidationResult,
  config: SolverConfig
): LayoutPlan {
  // Relaxation strategy: Drop lowest-priority blocks first
  const blocksInPriorityOrder = sortBlocksByPriority(schema.blocks);
  const relaxationSteps = [
    { level: 0, name: 'Drop detail blocks', dropPriorities: [4] },
    { level: 1, name: 'Drop secondary blocks', dropPriorities: [3, 4] },
    { level: 2, name: 'Drop all except primary', dropPriorities: [2, 3, 4] },
    { level: 3, name: 'Drop all except hero', dropPriorities: [1, 2, 3, 4] },
    { level: 4, name: 'Emergency fallback', dropPriorities: [0, 1, 2, 3, 4] },
  ];

  for (const step of relaxationSteps) {
    const remainingBlocks = blocksInPriorityOrder.filter(
      b => !step.dropPriorities.includes(getPriorityNumeric(b.layout?.priority))
    );

    const revalidation = validateMinimumRequirements(
      groupBlocksByPriority(remainingBlocks),
      context
    );

    if (revalidation.feasible) {
      console.warn(
        `Layout constraints relaxed: ${step.name}. ` +
        `Dropped ${schema.blocks.length - remainingBlocks.length} blocks.`
      );

      // Solve with reduced block set
      const plan = solveLayout(
        { ...schema, blocks: remainingBlocks },
        context,
        config
      );

      // Mark dropped blocks as hidden
      for (const block of schema.blocks) {
        if (!remainingBlocks.includes(block)) {
          plan.hiddenBlocks.push(block.uid);
        }
      }

      return plan;
    }
  }

  // Level 4: Emergency fallback - show nothing or single-block fallback
  return createFallbackPlan(schema, context, validation);
}

function getPriorityNumeric(priority?: BlockLayout['priority']): number {
  if (priority === 'hero') return 1;
  if (priority === 'primary') return 2;
  if (priority === 'secondary') return 3;
  if (priority === 'detail') return 4;
  return typeof priority === 'number' ? priority : 2;  // Default: primary
}

function createFallbackPlan(
  schema: LiquidSchema,
  context: SlotContext,
  validation: ValidationResult
): LayoutPlan {
  // Find highest-priority block that can fit
  const blocksByPriority = sortBlocksByPriority(schema.blocks);

  for (const block of blocksByPriority) {
    const minSize = getMinimumSize(block);
    if (minSize.width <= context.width && minSize.height <= context.height) {
      // Show only this block
      return {
        breakpoint: context.breakpoint,
        visibleBlocks: [block.uid],
        collapsedBlocks: [],
        hiddenBlocks: schema.blocks.filter(b => b.uid !== block.uid).map(b => b.uid),
        grid: [{
          blockId: block.uid,
          row: 0,
          column: 0,
          rowSpan: 1,
          colSpan: 1,
          width: Math.min(minSize.width, context.width),
          height: Math.min(minSize.height, context.height),
        }],
      };
    }
  }

  // Absolute worst case: Show error block
  return {
    breakpoint: context.breakpoint,
    visibleBlocks: [],
    collapsedBlocks: [],
    hiddenBlocks: schema.blocks.map(b => b.uid),
    grid: [],
    error: {
      code: 'LAYOUT_UNSATISFIABLE',
      message: 'Cannot satisfy minimum layout requirements for available space',
      details: {
        requiredWidth: validation.totalMinWidth,
        requiredHeight: validation.totalMinHeight,
        availableWidth: validation.availableWidth,
        availableHeight: validation.availableHeight,
      },
    },
  };
}
```

#### 11.12.5 Iteration Limit Enforcement

```typescript
function allocateBlock(
  block: Block,
  state: SolverState,
  context: SlotContext,
  config: SolverConfig
): BlockAllocation {
  // Hard check: iteration limit
  if (state.iteration >= config.maxIterations) {
    return {
      blockUid: block.uid,
      width: 0,
      height: 0,
      row: 0,
      column: 0,
      rowSpan: 0,
      colSpan: 0,
      visible: false,
      reason: 'Solver iteration limit exceeded',
    };
  }

  // Attempt allocation
  const minSize = getMinimumSize(block);

  if (state.remainingSpace.width < minSize.width ||
      state.remainingSpace.height < minSize.height) {
    return {
      blockUid: block.uid,
      width: 0,
      height: 0,
      row: 0,
      column: 0,
      rowSpan: 0,
      colSpan: 0,
      visible: false,
      reason: 'Insufficient remaining space',
    };
  }

  // Calculate actual allocation based on flex behavior
  const { width, height } = calculateDimensions(block, state, context);

  return {
    blockUid: block.uid,
    width,
    height,
    row: calculateRow(state),
    column: calculateColumn(state),
    rowSpan: 1,
    colSpan: calculateColSpan(block, context),
    visible: true,
  };
}
```

#### 11.12.6 Configuration

Default solver configuration:

```typescript
const DEFAULT_SOLVER_CONFIG: SolverConfig = {
  maxIterations: 1000,
  minBlockWidth: 80,
  minBlockHeight: 60,
  enableProgressiveRelaxation: true,
};

// Exposed for adapter customization
interface LiquidAdapter<T> {
  // ... existing methods ...

  // NEW: Adapter can override solver config
  readonly layoutSolverConfig?: Partial<SolverConfig>;
}
```

#### 11.12.7 Performance Characteristics

| Scenario | Iterations | Time (est.) | Outcome |
|----------|------------|-------------|---------|
| Simple grid (4 blocks) | 4-10 | <1ms | Perfect fit |
| Complex dashboard (50 blocks) | 50-200 | <10ms | Full layout |
| Unsatisfiable constraints | 1000 (max) | <100ms | Progressive relaxation |
| Pathological case | 1000 (max) | <100ms | Fallback plan |

**Worst-case guarantee:** O(n × k) where n = block count, k = max iterations
**Typical case:** O(n) single-pass allocation
```

---

### 2. Update §11.11 Cross-Reference

Modify §11.11.4 (Transformation Algorithm) to reference new solver:

**At line 1119, change:**

```markdown
6. Generate adapted layout
```

**To:**

```markdown
6. Generate adapted layout using constraint solver (§11.12)
```

---

### 3. Update LayoutPlan Interface in §11.14

Add error field to LayoutPlan (line 1190):

**Before:**
```typescript
interface LayoutPlan {
  breakpoint: Breakpoint;
  visibleBlocks: string[];
  collapsedBlocks: string[];
  hiddenBlocks: string[];
  grid: GridCell[];
}
```

**After:**
```typescript
interface LayoutPlan {
  breakpoint: Breakpoint;
  visibleBlocks: string[];
  collapsedBlocks: string[];
  hiddenBlocks: string[];
  grid: GridCell[];
  error?: LayoutError;          // NEW: Present if layout unsatisfiable
}

interface LayoutError {
  code: 'LAYOUT_UNSATISFIABLE' | 'SOLVER_TIMEOUT' | 'CONSTRAINT_CONFLICT';
  message: string;
  details: Record<string, any>;
}
```

---

### 4. Update Conformance Tests (§B.3.3)

Add layout solver tests at line 2100:

```typescript
  // Layout solver
  'completes layout within iteration limit',
  'produces valid layout for satisfiable constraints',
  'applies progressive relaxation for unsatisfiable constraints',
  'never exceeds solver timeout',
  'drops lowest-priority blocks first when space insufficient',
```

---

## Implementation Checklist

- [ ] Add §11.12 with complete solver algorithm
- [ ] Update §11.11.4 to reference solver
- [ ] Add LayoutError to LayoutPlan interface (§11.14)
- [ ] Add DEFAULT_SOLVER_CONFIG to normative types (§B.6.1)
- [ ] Update conformance tests (§B.3.3)
- [ ] Add solver config to LiquidAdapter interface (§18.1)
- [ ] Update hardening checklist (§B.7)

---

## Testing Strategy

### Test Cases

1. **Satisfiable constraints:**
   ```liquidcode
   # 3 KPIs, 200px each, in 800px container
   K1^fixed.min:200
   K2^fixed.min:200
   K3^fixed.min:200
   ```
   Expected: All visible, perfect fit

2. **Unsatisfiable constraints - relaxation needed:**
   ```liquidcode
   # 3 fixed blocks, 500px each, in 400px container
   K1!hero^fixed.min:500
   K2!primary^fixed.min:500
   K3!secondary^fixed.min:500
   ```
   Expected: K3 dropped, K1+K2 shown or further relaxation

3. **Iteration limit test:**
   - Schema with 1500 blocks
   - Expected: Completes in <1000 iterations or applies relaxation

4. **Pathological conflict:**
   ```liquidcode
   # Single block larger than container
   K1^fixed.min:2000  # Container width: 400px
   ```
   Expected: Fallback plan with error

5. **Mixed flexibility:**
   ```liquidcode
   K1!hero^fixed.min:200
   L1^grow
   K2^shrink
   ```
   Expected: K1 gets 200px, L1 grows, K2 shrinks if needed

---

## Migration Impact

**Breaking Change:** No

Existing schemas without explicit minimums use intrinsic sizes (§11.9). Behavior improves (guaranteed termination) but doesn't break.

**Migration Path:** None needed.

**Adapter Impact:** Adapters should implement solver configuration if custom limits are needed.

---

## Cross-References

- §11.9: Intrinsic Block Sizes
- §11.11: Responsive Transformation Rules
- §11.14: Adapter Responsibility (LayoutPlan)
- §18.1: Adapter Interface
- §B.3.2: Adapter Conformance (timeout)
- §B.3.3: Conformance Test Suite

---

## Specification Diff

### New Section: §11.12

**Location:** After line 1120 (end of §11.11)

**Insert:** Full content of §11.12 as specified above (~450 lines)

### Modified Section: §11.11.4

**Location:** Line 1119

**Change:** Add reference to §11.12 solver

### Modified Section: §11.14

**Location:** Line 1190

**Change:** Add LayoutError to LayoutPlan interface

### Modified Section: §B.3.3

**Location:** Line 2100

**Change:** Add 5 layout solver conformance tests

---

## Resolution Status

- [x] Problem analyzed
- [x] Solution designed
- [x] Specification content written
- [x] Cross-references identified
- [x] Test cases defined
- [ ] Approved for merge
- [ ] Applied to SPEC document

---

**Resolution Author:** Claude Opus 4.5
**Review Required:** Yes - Critical change affecting layout guarantee
