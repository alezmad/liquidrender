# Resolution: ISS-102

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Snapshot Addressing Non-Existent History
**Severity:** significant
**Target:** SPEC
**Section:** §8.5 Snapshot Addressing, §16.2 Operation History

## Resolution

### Original Content

From §8.5:
```liquidcode
# Address block as it was after operation 3
@snapshot:3.@K0

# Compare current to previous
?diff(@snapshot:-1, @current)
```

From §16.2:
```typescript
interface OperationHistory {
  operations: AppliedOperation[];
  maxSize: number;               // Undo depth limit

  push(op: Operation): void;
  undo(): Operation | null;
  redo(): Operation | null;
  snapshot(index: number): LiquidSchema;
}
```

**No specification for:**
- Handling negative indices beyond history length (e.g., `@snapshot:-100` when only 10 operations)
- Handling positive indices beyond current state (e.g., `@snapshot:50` when only 20 operations)
- Handling snapshot:0 (before any operations)
- Error handling vs graceful fallback
- What "index" means (absolute operation number vs history array index)

### Replacement Content

**Replace §8.5 Snapshot Addressing with comprehensive specification:**

#### 8.5 Snapshot Addressing

Reference historical schema states for comparison, rollback, or debugging.

**8.5.1 Snapshot Index Semantics**

```typescript
interface SnapshotAddress {
  index: number;                 // Snapshot index (semantics below)
  blockAddress?: string;         // Optional block selector within snapshot
}

// Index semantics:
// - Positive (1, 2, 3, ...): Absolute operation count
//   @snapshot:1 = state after first operation
//   @snapshot:5 = state after fifth operation
//
// - Zero (0): Initial state (before any operations)
//   @snapshot:0 = schema as originally compiled
//
// - Negative (-1, -2, -3, ...): Relative to current
//   @snapshot:-1 = state after previous operation (current - 1)
//   @snapshot:-5 = state five operations ago (current - 5)
```

**8.5.2 Snapshot Resolution Algorithm**

```typescript
interface SnapshotResolutionResult {
  schema: LiquidSchema | null;
  index: number;                 // Resolved absolute index
  error?: SnapshotError;
}

enum SnapshotError {
  INDEX_OUT_OF_BOUNDS = 'index_out_of_bounds',
  HISTORY_TOO_SHORT = 'history_too_short',
  HISTORY_PRUNED = 'history_pruned',
  SNAPSHOT_NOT_AVAILABLE = 'snapshot_not_available',
}

function resolveSnapshot(
  index: number,
  history: OperationHistory,
  twin: DigitalTwin
): SnapshotResolutionResult {
  const currentIndex = twin.operationCount;

  // Resolve negative indices
  const absoluteIndex = index >= 0 ? index : currentIndex + index;

  // Check bounds
  if (absoluteIndex < 0) {
    return {
      schema: null,
      index: absoluteIndex,
      error: SnapshotError.INDEX_OUT_OF_BOUNDS,
    };
  }

  if (absoluteIndex > currentIndex) {
    return {
      schema: null,
      index: absoluteIndex,
      error: SnapshotError.INDEX_OUT_OF_BOUNDS,
    };
  }

  // Special case: index 0 = initial state
  if (absoluteIndex === 0) {
    const initialSchema = history.getInitialSchema();
    if (!initialSchema) {
      return {
        schema: null,
        index: 0,
        error: SnapshotError.SNAPSHOT_NOT_AVAILABLE,
      };
    }
    return {
      schema: initialSchema,
      index: 0,
    };
  }

  // Check if snapshot is available (history may be pruned)
  const oldestAvailable = Math.max(0, currentIndex - history.maxSize);

  if (absoluteIndex < oldestAvailable) {
    return {
      schema: null,
      index: absoluteIndex,
      error: SnapshotError.HISTORY_PRUNED,
    };
  }

  // Retrieve snapshot
  try {
    const schema = history.snapshot(absoluteIndex);
    return {
      schema,
      index: absoluteIndex,
    };
  } catch (error) {
    return {
      schema: null,
      index: absoluteIndex,
      error: SnapshotError.SNAPSHOT_NOT_AVAILABLE,
    };
  }
}
```

**8.5.3 Bounds Checking Examples**

| Current State | Snapshot Request | Absolute Index | Result |
|---------------|------------------|----------------|--------|
| 10 operations | `@snapshot:5` | 5 | ✅ Valid (returns state after op 5) |
| 10 operations | `@snapshot:-1` | 9 | ✅ Valid (previous operation) |
| 10 operations | `@snapshot:-10` | 0 | ✅ Valid (initial state) |
| 10 operations | `@snapshot:-11` | -1 | ❌ Out of bounds (before initial) |
| 10 operations | `@snapshot:15` | 15 | ❌ Out of bounds (future state) |
| 10 operations | `@snapshot:0` | 0 | ✅ Valid (initial state) |
| 0 operations | `@snapshot:-1` | -1 | ❌ Out of bounds (no history) |
| 0 operations | `@snapshot:0` | 0 | ✅ Valid (current = initial) |

**8.5.4 History Pruning**

When history exceeds `maxSize`, oldest operations are pruned:

```typescript
interface OperationHistory {
  operations: AppliedOperation[];
  maxSize: number;               // Undo depth limit (default: 50)
  initialSchema: LiquidSchema;   // REQUIRED: preserve initial state
  prunedCount: number;           // How many operations pruned

  push(op: Operation): void;
  undo(): Operation | null;
  redo(): Operation | null;
  snapshot(index: number): LiquidSchema;
  getInitialSchema(): LiquidSchema;         // NEW
  getOldestAvailableIndex(): number;        // NEW
}

function pushOperation(
  history: OperationHistory,
  op: AppliedOperation
): void {
  history.operations.push(op);

  // Prune if exceeding maxSize
  if (history.operations.length > history.maxSize) {
    const pruned = history.operations.shift();
    history.prunedCount++;

    // Log pruning for transparency
    logger.debug('Pruned oldest operation', {
      operation: pruned.operation,
      newOldestIndex: history.prunedCount,
    });
  }
}

function getOldestAvailableIndex(history: OperationHistory): number {
  // Account for pruned operations
  return history.prunedCount;
}
```

**8.5.5 Error Handling Strategies**

When snapshot resolution fails:

```typescript
type FallbackStrategy =
  | 'return_null'       // Return null (default)
  | 'return_current'    // Return current state
  | 'return_closest'    // Return closest available snapshot
  | 'throw_error';      // Throw error (for programmatic use)

function resolveSnapshotWithFallback(
  index: number,
  history: OperationHistory,
  twin: DigitalTwin,
  strategy: FallbackStrategy = 'return_null'
): LiquidSchema | null {
  const result = resolveSnapshot(index, history, twin);

  if (result.schema) {
    return result.schema;
  }

  // Handle error based on strategy
  switch (strategy) {
    case 'return_null':
      return null;

    case 'return_current':
      return twin.schema;

    case 'return_closest':
      return resolveClosestSnapshot(result.index, history, twin);

    case 'throw_error':
      throw new SnapshotResolutionError(result.error, result.index);
  }
}

function resolveClosestSnapshot(
  requestedIndex: number,
  history: OperationHistory,
  twin: DigitalTwin
): LiquidSchema {
  const currentIndex = twin.operationCount;
  const oldestIndex = getOldestAvailableIndex(history);

  // Clamp to available range
  const clampedIndex = Math.max(
    oldestIndex,
    Math.min(requestedIndex, currentIndex)
  );

  if (clampedIndex === 0) {
    return history.getInitialSchema();
  }

  return history.snapshot(clampedIndex);
}
```

**8.5.6 LiquidCode Syntax Extensions**

```liquidcode
# Basic snapshot addressing
@snapshot:5.@K0              # Block K0 at operation 5
@snapshot:-1.@[0,0]          # Block at [0,0] one operation ago
@snapshot:0.@:revenue        # Block bound to revenue in initial state

# With fallback strategy
@snapshot:5.@K0?current      # If snapshot 5 unavailable, use current
@snapshot:-100.@K0?closest   # Use closest available if -100 out of range

# Queries using snapshots
?@snapshot:3                 # Get entire schema at operation 3
?diff(@snapshot:-1, @current)  # Diff previous vs current

# Mutations referencing history (rare, but supported)
Δ+@snapshot:5.@K0            # Add copy of K0 as it was at operation 5
```

**8.5.7 Snapshot Addressing in Queries**

```typescript
interface SnapshotQuery {
  type: 'snapshot' | 'diff';
  snapshots: number[];       // Snapshot indices to query
  blockAddress?: string;     // Optional block selector
}

// Example: Compare schema at two points in time
function queryDiff(
  snapshot1Index: number,
  snapshot2Index: number,
  history: OperationHistory,
  twin: DigitalTwin
): SchemaDiff | null {
  const s1 = resolveSnapshot(snapshot1Index, history, twin);
  const s2 = resolveSnapshot(snapshot2Index, history, twin);

  if (!s1.schema || !s2.schema) {
    return null;  // Or handle error
  }

  return calculateSchemaDiff(s1.schema, s2.schema);
}

interface SchemaDiff {
  blocksAdded: Block[];
  blocksRemoved: Block[];
  blocksModified: Array<{
    before: Block;
    after: Block;
    changes: PropertyChange[];
  }>;
  signalsChanged: SignalChange[];
}
```

**8.5.8 Enhanced OperationHistory Interface**

```typescript
interface OperationHistory {
  operations: AppliedOperation[];
  maxSize: number;
  initialSchema: LiquidSchema;       // REQUIRED: always preserved
  prunedCount: number;               // Track pruned operations

  // Core operations
  push(op: AppliedOperation): void;
  undo(): AppliedOperation | null;
  redo(): AppliedOperation | null;

  // Snapshot access
  snapshot(index: number): LiquidSchema;  // Throws if unavailable
  snapshotSafe(
    index: number,
    fallback?: FallbackStrategy
  ): LiquidSchema | null;

  // Metadata
  getInitialSchema(): LiquidSchema;
  getCurrentIndex(): number;
  getOldestAvailableIndex(): number;
  isSnapshotAvailable(index: number): boolean;

  // Range queries
  getAvailableRange(): { oldest: number; current: number };
  listOperations(from: number, to: number): AppliedOperation[];
}

// Implementation
class OperationHistoryImpl implements OperationHistory {
  // ... fields ...

  snapshot(index: number): LiquidSchema {
    const result = resolveSnapshot(index, this, this.twin);

    if (!result.schema) {
      throw new SnapshotResolutionError(
        result.error || SnapshotError.SNAPSHOT_NOT_AVAILABLE,
        result.index
      );
    }

    return result.schema;
  }

  snapshotSafe(
    index: number,
    fallback: FallbackStrategy = 'return_null'
  ): LiquidSchema | null {
    return resolveSnapshotWithFallback(index, this, this.twin, fallback);
  }

  isSnapshotAvailable(index: number): boolean {
    const absoluteIndex = index >= 0 ? index : this.getCurrentIndex() + index;
    const oldestAvailable = this.getOldestAvailableIndex();
    const currentIndex = this.getCurrentIndex();

    return absoluteIndex >= oldestAvailable && absoluteIndex <= currentIndex;
  }

  getAvailableRange(): { oldest: number; current: number } {
    return {
      oldest: this.getOldestAvailableIndex(),
      current: this.getCurrentIndex(),
    };
  }
}
```

**8.5.9 User-Facing Error Messages**

When snapshot addressing fails in user-facing contexts:

```typescript
function formatSnapshotError(
  error: SnapshotError,
  requestedIndex: number,
  history: OperationHistory
): string {
  const range = history.getAvailableRange();

  switch (error) {
    case SnapshotError.INDEX_OUT_OF_BOUNDS:
      if (requestedIndex < 0) {
        return `Snapshot index ${requestedIndex} is before initial state. ` +
               `Available range: ${range.oldest} to ${range.current}.`;
      } else {
        return `Snapshot index ${requestedIndex} is in the future. ` +
               `Current state is at index ${range.current}.`;
      }

    case SnapshotError.HISTORY_PRUNED:
      return `Snapshot ${requestedIndex} is no longer available (history pruned). ` +
             `Oldest available snapshot: ${range.oldest}.`;

    case SnapshotError.HISTORY_TOO_SHORT:
      return `Not enough history for snapshot ${requestedIndex}. ` +
             `Only ${range.current} operations have been performed.`;

    case SnapshotError.SNAPSHOT_NOT_AVAILABLE:
      return `Snapshot ${requestedIndex} could not be retrieved.`;
  }
}
```

**8.5.10 Testing Scenarios**

```typescript
// Test: Negative index beyond history
test('snapshot -100 when only 10 operations', () => {
  const history = createHistory(10);
  const result = resolveSnapshot(-100, history, twin);
  expect(result.error).toBe(SnapshotError.INDEX_OUT_OF_BOUNDS);
  expect(result.schema).toBeNull();
});

// Test: Positive index in future
test('snapshot 50 when only 20 operations', () => {
  const history = createHistory(20);
  const result = resolveSnapshot(50, history, twin);
  expect(result.error).toBe(SnapshotError.INDEX_OUT_OF_BOUNDS);
  expect(result.schema).toBeNull();
});

// Test: Snapshot 0 (initial state)
test('snapshot 0 returns initial schema', () => {
  const history = createHistory(10);
  const result = resolveSnapshot(0, history, twin);
  expect(result.schema).toEqual(history.initialSchema);
});

// Test: History pruning
test('snapshot beyond pruned history', () => {
  const history = createHistory(100, { maxSize: 50 });
  // Oldest available is now operation 50
  const result = resolveSnapshot(25, history, twin);
  expect(result.error).toBe(SnapshotError.HISTORY_PRUNED);
});

// Test: Fallback to closest
test('snapshot with closest fallback', () => {
  const history = createHistory(10);
  const schema = resolveSnapshotWithFallback(-100, history, twin, 'return_closest');
  expect(schema).toEqual(history.initialSchema);  // Clamped to 0
});
```

**Add to §16.2 Operation History:**

Update interface definition to include new methods from §8.5.8.

**Add to Appendix B Hardening Checklist:**
- [ ] Snapshot addressing handles negative indices beyond history
- [ ] Snapshot addressing handles positive indices beyond current state
- [ ] Snapshot 0 always returns initial schema (never pruned)
- [ ] History pruning preserves initial schema
- [ ] Error messages indicate available snapshot range
- [ ] Fallback strategies implemented (null, current, closest, throw)
- [ ] Snapshot availability check before resolution

## Verification Checklist
- [x] Edge case fully specified (all out-of-bounds scenarios)
- [x] Behavior deterministic (resolution algorithm + fallback strategies)
- [x] Error handling defined (4 error types + 4 fallback strategies)
- [x] Examples provided where helpful (bounds table, 5 test scenarios, error messages)

## Confidence
**HIGH** - This resolution:
1. Defines clear semantics for positive, negative, and zero indices
2. Provides comprehensive bounds checking algorithm
3. Specifies history pruning while preserving initial state
4. Defines 4 fallback strategies for different use cases
5. Includes user-friendly error messages with available ranges
6. Provides enhanced OperationHistory interface with safety methods
7. Includes 5 concrete test scenarios covering all edge cases
8. Handles both programmatic and user-facing error contexts
