# ISS-021: SlotContext Field Type Mismatch

**Issue Type:** Inconsistency
**Severity:** High
**Status:** Resolved
**Date:** 2025-12-21

---

## Problem Statement

The `SlotContext` interface is defined in two locations with different field types:

- **Location A (§11.10):** Defines `breakpoint` as a string union type
- **Location B (B.6.1):** Defines `breakpoint` as a Breakpoint type alias

**Conflict:** The field type representations differ, creating ambiguity about which is authoritative.

---

## Analysis

### Location A: §11.10 Slot Context (Embedded Rendering)

**Line 1067-1081**

```typescript
interface SlotContext {
  // Available space
  width: number;
  height: number | 'auto';

  // Breakpoint (adapter-determined)
  breakpoint: 'compact' | 'standard' | 'expanded';

  // Constraints
  minBlockWidth?: number;
  orientation?: 'any' | 'portrait' | 'landscape';

  // Parent coordination
  parentSignals?: SignalRegistry;
}
```

**Key characteristics:**
- Inline union type for `breakpoint`
- Inline union type for `orientation`
- No separate type alias

### Location B: B.6.1 Complete Type Definitions

**Line 2446-2455**

```typescript
interface SlotContext {
  width: number;
  height: number | 'auto';
  breakpoint: Breakpoint;
  minBlockWidth?: number;
  orientation?: 'any' | 'portrait' | 'landscape';
  parentSignals?: SignalRegistry;
}

type Breakpoint = 'compact' | 'standard' | 'expanded';
```

**Key characteristics:**
- References `Breakpoint` type alias
- Includes separate `Breakpoint` type definition
- More structured approach

### Actual Difference

The **semantic** difference is:

1. **§11.10:** Uses inline union `'compact' | 'standard' | 'expanded'`
2. **B.6.1:** Uses type alias `Breakpoint` which resolves to the same union

**Additionally:**
- Comments in §11.10 are more detailed
- Field ordering is identical
- All field types are equivalent

---

## Resolution

### Authoritative Source

**B.6.1 is authoritative** for the following reasons:

1. **Explicit normative status:** Appendix B states: "These are **normative requirements** for production-grade implementations."

2. **Section title:** "B.6.1 Complete Type Definitions" with the comment:
   ```typescript
   /**
    * LiquidSchema v2.0 - Normative Type Definitions
    * All implementations MUST conform to these types.
    */
   ```

3. **Better type reuse:** The `Breakpoint` type is defined separately and can be referenced elsewhere (e.g., in `BreakpointThresholds`, adapter metadata, responsive config).

4. **Validation requirements:** Section B.6.3 states "All schemas MUST pass Zod validation" and references these types.

### Required Changes

**Update §11.10** to align with B.6.1's type structure while preserving helpful comments.

#### Update §11.10

**Location:** §11.10 Slot Context (Embedded Rendering), lines 1067-1081

**Before:**
```typescript
interface SlotContext {
  // Available space
  width: number;
  height: number | 'auto';

  // Breakpoint (adapter-determined)
  breakpoint: 'compact' | 'standard' | 'expanded';

  // Constraints
  minBlockWidth?: number;
  orientation?: 'any' | 'portrait' | 'landscape';

  // Parent coordination
  parentSignals?: SignalRegistry;
}
```

**After:**
```typescript
interface SlotContext {
  // Available space
  width: number;
  height: number | 'auto';

  // Breakpoint (adapter-determined)
  breakpoint: Breakpoint;

  // Constraints
  minBlockWidth?: number;
  orientation?: 'any' | 'portrait' | 'landscape';

  // Parent coordination
  parentSignals?: SignalRegistry;
}

type Breakpoint = 'compact' | 'standard' | 'expanded';
```

**Change summary:**
1. Replace inline union `'compact' | 'standard' | 'expanded'` with type alias `Breakpoint`
2. Add `Breakpoint` type definition after the interface
3. Preserve all comments for readability

---

## Impact Analysis

### Breaking Changes

**None.** This is a representational change only. The runtime type is identical:

```typescript
// Before (§11.10)
breakpoint: 'compact' | 'standard' | 'expanded'

// After (aligned with B.6.1)
breakpoint: Breakpoint  // where Breakpoint = 'compact' | 'standard' | 'expanded'
```

TypeScript treats these as equivalent.

### Benefits

1. **Consistency:** Single source of truth for `Breakpoint` type
2. **Reusability:** `Breakpoint` can be imported/referenced elsewhere
3. **Maintainability:** Change breakpoint values in one place
4. **Clarity:** Type alias documents that breakpoints are a named concept

### Existing References to Breakpoint

The `Breakpoint` type is already referenced in other parts of B.6.1:

**BreakpointThresholds (line 2457-2461):**
```typescript
interface BreakpointThresholds {
  compact: number;   // <600px default
  standard: number;  // <1200px default
  expanded: number;  // ≥1200px default
}
```

**Note:** This interface uses the breakpoint names as keys, reinforcing that `Breakpoint` should be a named type.

---

## Validation

### Type Equivalence Check

```typescript
// Runtime equivalence
type InlineVersion = 'compact' | 'standard' | 'expanded';
type AliasedVersion = Breakpoint;

// These are assignable to each other
const test1: InlineVersion = 'compact';
const test2: AliasedVersion = test1; // ✓ valid
const test3: InlineVersion = test2;  // ✓ valid
```

### Zod Schema

The validation schema should use the type alias:

```typescript
const BreakpointSchema = z.enum(['compact', 'standard', 'expanded']);

const SlotContextSchema = z.object({
  width: z.number(),
  height: z.union([z.number(), z.literal('auto')]),
  breakpoint: BreakpointSchema,
  minBlockWidth: z.number().optional(),
  orientation: z.enum(['any', 'portrait', 'landscape']).optional(),
  parentSignals: SignalRegistrySchema.optional(),
});
```

---

## Implementation Guidance

### For TypeScript Implementations

```typescript
// Export the Breakpoint type for reuse
export type Breakpoint = 'compact' | 'standard' | 'expanded';

// Use it in SlotContext
export interface SlotContext {
  width: number;
  height: number | 'auto';
  breakpoint: Breakpoint;  // Type-safe reference
  minBlockWidth?: number;
  orientation?: 'any' | 'portrait' | 'landscape';
  parentSignals?: SignalRegistry;
}

// Can be reused in other interfaces
export interface AdapterMetadata {
  // ...
  breakpointThresholds?: BreakpointThresholds;
}

export interface BreakpointThresholds {
  compact: number;
  standard: number;
  expanded: number;
}
```

### For Adapters

Adapters determining breakpoints should use the type:

```typescript
function determineBreakpoint(width: number, thresholds?: BreakpointThresholds): Breakpoint {
  const compact = thresholds?.compact ?? 600;
  const standard = thresholds?.standard ?? 1200;

  if (width < compact) return 'compact';
  if (width < standard) return 'standard';
  return 'expanded';
}
```

---

## Documentation Updates

### File: LIQUIDCODE-SPEC-v2.md

**Section:** §11.10 Slot Context (Embedded Rendering)

**Change Type:** Type consistency update (non-breaking)

**Lines to Update:** 1067-1081

**Diff:**
```diff
 interface SlotContext {
   // Available space
   width: number;
   height: number | 'auto';

   // Breakpoint (adapter-determined)
-  breakpoint: 'compact' | 'standard' | 'expanded';
+  breakpoint: Breakpoint;

   // Constraints
   minBlockWidth?: number;
   orientation?: 'any' | 'portrait' | 'landscape';

   // Parent coordination
   parentSignals?: SignalRegistry;
 }
+
+type Breakpoint = 'compact' | 'standard' | 'expanded';
```

---

## Testing Requirements

### Conformance Tests

```typescript
describe('SlotContext type consistency', () => {
  test('breakpoint field accepts all valid values', () => {
    const contexts: SlotContext[] = [
      { width: 400, height: 'auto', breakpoint: 'compact' },
      { width: 800, height: 600, breakpoint: 'standard' },
      { width: 1400, height: 900, breakpoint: 'expanded' },
    ];

    contexts.forEach(ctx => {
      expect(SlotContextSchema.safeParse(ctx).success).toBe(true);
    });
  });

  test('breakpoint field rejects invalid values', () => {
    const invalid = { width: 400, height: 'auto', breakpoint: 'invalid' };
    expect(SlotContextSchema.safeParse(invalid).success).toBe(false);
  });

  test('Breakpoint type is exported and usable', () => {
    const bp: Breakpoint = 'compact';
    const ctx: SlotContext = { width: 400, height: 'auto', breakpoint: bp };
    expect(ctx.breakpoint).toBe('compact');
  });
});
```

### Migration Validation

```typescript
// Ensure existing code continues to work
test('inline union still works after migration', () => {
  // Old style (should still compile)
  const oldStyle: { breakpoint: 'compact' | 'standard' | 'expanded' } = {
    breakpoint: 'compact'
  };

  // New style
  const newStyle: { breakpoint: Breakpoint } = {
    breakpoint: 'compact'
  };

  // Should be assignable to each other
  const test1: typeof oldStyle = newStyle;
  const test2: typeof newStyle = oldStyle;

  expect(test1.breakpoint).toBe(test2.breakpoint);
});
```

---

## Checklist

- [x] Identified authoritative source (B.6.1)
- [x] Verified type semantic equivalence
- [x] Defined required update to §11.10
- [x] Confirmed no breaking changes
- [x] Created validation tests
- [x] Documented benefits of type alias
- [x] Specified implementation guidance

---

## Related Issues

- **ISS-020:** Block Type Code Conflicts (resolved in same wave)
- **Potential future issue:** Orientation might benefit from similar type alias treatment

---

## Recommendations

### Future Consistency Improvement

Consider applying the same pattern to `orientation`:

```typescript
type Orientation = 'any' | 'portrait' | 'landscape';

interface SlotContext {
  // ...
  orientation?: Orientation;
  // ...
}
```

This would provide:
- Consistent use of type aliases throughout the spec
- Better autocomplete in IDEs
- Single source of truth for each domain concept

**However:** This is not required for this resolution. Can be addressed in a future consistency pass.

---

## Conclusion

**Resolution:** §11.10 must be updated to use the `Breakpoint` type alias instead of inline union type, aligning with the normative definition in B.6.1. This is a non-breaking representational change that improves type reusability and consistency. The update preserves all comments and semantics while establishing B.6.1 as the single source of truth for type definitions.
