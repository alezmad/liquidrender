# ISS-113: Binding Slot Extensibility

**Issue Type:** Extension Gap
**Category:** Extensibility and Evolution
**Priority:** High
**Affects:** Binding System (Section 9), Block Type Extensibility

---

## Problem Statement

LiquidCode v2 defines a fixed set of binding slots:
- `x`, `y`, `value`, `label`, `category`, `series`, `color`, `stack`, `trend`, `icon`, `compare`, `current`, `previous`, `format`, `data`, `columns`, `pageSize`

Custom block types (using `custom:${string}` prefix) cannot define their own binding slots. This prevents:

1. **Specialized visualizations** from having domain-appropriate bindings (e.g., Gantt chart needs `startDate`, `endDate`, `dependency`)
2. **LiquidCode encoding** of custom block bindings (parser doesn't know custom slots exist)
3. **Binding validation** specific to custom block requirements
4. **First-class domain blocks** - custom types are second-class citizens

### Example Failure

```typescript
// I create a custom Gantt chart block
catalog.register({
  type: 'custom:gantt',
  category: 'atomic',
  bindings: ???  // Can't define 'startDate', 'endDate', 'dependency' slots
});

// LiquidCode can't encode it properly
custom:gantt$taskName$startDate$endDate
// ❌ Parser doesn't recognize these slots!
// ❌ Validation doesn't know what's required!
// ❌ LLM has no guidance on slot semantics!
```

### Real-World Use Cases

| Block Type | Custom Slots Needed |
|------------|---------------------|
| Gantt chart | `task`, `startDate`, `endDate`, `dependency`, `milestone`, `progress` |
| Network diagram | `source`, `target`, `weight`, `nodeLabel`, `edgeLabel` |
| Sankey diagram | `from`, `to`, `flow`, `stage` |
| Timeline | `event`, `timestamp`, `duration`, `category`, `icon` |
| Heatmap | `xAxis`, `yAxis`, `intensity`, `label` |
| Treemap | `parent`, `value`, `label`, `color` |
| Funnel | `stage`, `value`, `conversionRate` |

---

## Resolution

### Extension Mechanism

Add a **Binding Slot Registry** tied to block type definitions, allowing custom blocks to declare their own typed binding slots.

### Implementation

#### 1. Binding Slot Definition Interface

```typescript
interface BindingSlotDefinition {
  // Identification
  name: string;                        // e.g., 'startDate'

  // Constraints
  required: boolean;                   // Must be provided?
  valueType: SlotValueType;           // Expected data type

  // Validation
  accepts?: (value: any) => boolean;   // Custom validation

  // Metadata
  description: string;                 // Human-readable purpose
  examples?: string[];                 // Example field names
  defaultTransform?: string;           // Default LiquidExpr transform
}

type SlotValueType =
  | 'string'
  | 'number'
  | 'date'
  | 'boolean'
  | 'array'
  | 'object'
  | 'string[]'
  | 'number[]'
  | 'enum';

interface EnumSlotDefinition extends BindingSlotDefinition {
  valueType: 'enum';
  allowedValues: string[];
}
```

#### 2. Enhanced Block Type Registration

```typescript
interface CustomBlockSpec {
  // Basic block info
  type: BlockType;                     // e.g., 'custom:gantt'
  category: BlockCategory;

  // Slot definitions (NEW)
  slots: BindingSlotDefinition[];

  // Optional capabilities
  signals?: SignalCapability[];
  layout?: LayoutCapability;

  // Metadata
  version: string;
  description?: string;
  documentation?: string;
}

// Registration API
interface BlockCatalog {
  register(spec: CustomBlockSpec): void;
  get(type: BlockType): CustomBlockSpec | undefined;
  getSlots(type: BlockType): BindingSlotDefinition[];
  validateBinding(type: BlockType, binding: DataBinding): ValidationResult;
}
```

#### 3. Usage Example: Gantt Chart

```typescript
// Register custom Gantt chart block with custom slots
engine.catalog.register({
  type: 'custom:gantt',
  version: '1.0.0',
  category: 'atomic',

  // Define custom binding slots
  slots: [
    {
      name: 'task',
      required: true,
      valueType: 'string',
      description: 'Task name or identifier',
      examples: ['taskName', 'title', 'name']
    },
    {
      name: 'startDate',
      required: true,
      valueType: 'date',
      description: 'Task start date',
      examples: ['startDate', 'start', 'beginDate']
    },
    {
      name: 'endDate',
      required: true,
      valueType: 'date',
      description: 'Task end date',
      examples: ['endDate', 'end', 'completionDate'],
      accepts: (value) => value > binding.startDate  // Custom validation
    },
    {
      name: 'dependency',
      required: false,
      valueType: 'string',
      description: 'ID of task this depends on',
      examples: ['dependsOn', 'prerequisite', 'parentTask']
    },
    {
      name: 'progress',
      required: false,
      valueType: 'number',
      description: 'Completion percentage (0-100)',
      examples: ['percentComplete', 'progress'],
      accepts: (value) => value >= 0 && value <= 100
    },
    {
      name: 'assignee',
      required: false,
      valueType: 'string',
      description: 'Person assigned to task',
      examples: ['assignee', 'owner', 'responsible']
    }
  ],

  description: 'Project timeline visualization showing tasks, dependencies, and progress'
});
```

#### 4. LiquidCode Syntax for Custom Slots

Extend the parser to handle custom block types with registered slots:

```liquidcode
# Gantt chart with custom slots
custom:gantt$task$startDate$endDate$dependency$progress

# Network diagram with custom slots
custom:network$source$target$weight$nodeLabel

# Sankey with custom slots
custom:sankey$from$to$flow
```

Parser logic:
```typescript
function parseBlockBinding(code: string, catalog: BlockCatalog): Block {
  const [typeCode, ...fieldBindings] = code.split('$');
  const blockType = resolveBlockType(typeCode);

  // Get slot definitions for this block type
  const slotDefs = catalog.getSlots(blockType);

  if (slotDefs.length === 0) {
    // Core block type - use hardcoded slot mapping
    return parseStandardBlock(blockType, fieldBindings);
  }

  // Custom block type - map fields to declared slots
  const fields: FieldBinding[] = [];

  for (let i = 0; i < Math.min(fieldBindings.length, slotDefs.length); i++) {
    const slotDef = slotDefs[i];
    const fieldName = fieldBindings[i];

    fields.push({
      target: slotDef.name,
      field: fieldName,
      transform: slotDef.defaultTransform
    });
  }

  return {
    uid: generateUID(),
    type: blockType,
    binding: {
      source: 'data',
      fields
    }
  };
}
```

#### 5. Binding Validation

```typescript
function validateBlockBinding(
  block: Block,
  catalog: BlockCatalog
): ValidationResult {
  const errors: ValidationError[] = [];
  const slotDefs = catalog.getSlots(block.type);

  if (!slotDefs) {
    return { valid: true, errors: [] };  // Core block, validated elsewhere
  }

  const boundSlots = new Set(
    block.binding?.fields.map(f => f.target) || []
  );

  // Check required slots are bound
  for (const slotDef of slotDefs.filter(s => s.required)) {
    if (!boundSlots.has(slotDef.name)) {
      errors.push({
        field: `blocks[${block.uid}].binding`,
        message: `Required slot '${slotDef.name}' not bound for ${block.type}`
      });
    }
  }

  // Check bound slots are valid
  for (const field of block.binding?.fields || []) {
    const slotDef = slotDefs.find(s => s.name === field.target);

    if (!slotDef) {
      errors.push({
        field: `blocks[${block.uid}].binding.${field.target}`,
        message: `Unknown slot '${field.target}' for ${block.type}. Available: ${slotDefs.map(s => s.name).join(', ')}`
      });
      continue;
    }

    // Type validation (if data available)
    // Custom validation via slotDef.accepts()
  }

  return { valid: errors.length === 0, errors };
}
```

#### 6. Discovery Engine Integration

Enable slot-aware binding suggestions:

```typescript
interface BindingSuggestion {
  slot: string;                        // Slot name
  field: string;                       // Data field name
  score: number;                       // 0-1 confidence
  reasons: ScoringSignal[];
}

function suggestBindings(
  blockType: BlockType,
  dataFingerprint: DataFingerprint,
  catalog: BlockCatalog
): BindingSuggestion[] {
  const slotDefs = catalog.getSlots(blockType);
  const suggestions: BindingSuggestion[] = [];

  for (const slotDef of slotDefs) {
    for (const field of dataFingerprint.fields) {
      const score = scoreFieldForSlot(slotDef, field);

      if (score > 0.3) {  // Threshold
        suggestions.push({
          slot: slotDef.name,
          field: field.name,
          score,
          reasons: [
            { source: 'type', weight: 0.4, reason: 'Types match' },
            { source: 'semantic', weight: 0.3, reason: 'Name similarity' },
            { source: 'example', weight: 0.2, reason: 'Matches example pattern' }
          ]
        });
      }
    }
  }

  return suggestions.sort((a, b) => b.score - a.score);
}

function scoreFieldForSlot(
  slotDef: BindingSlotDefinition,
  field: DataField
): number {
  let score = 0;

  // Type match
  if (slotDef.valueType === field.type) {
    score += 0.4;
  }

  // Semantic match (name similarity)
  if (slotDef.examples?.some(ex =>
    field.name.toLowerCase().includes(ex.toLowerCase())
  )) {
    score += 0.3;
  }

  // Pattern match (e.g., date fields for date slots)
  if (slotDef.valueType === 'date' && field.name.match(/date|time|timestamp/i)) {
    score += 0.2;
  }

  return Math.min(score, 1.0);
}
```

---

## Migration Path

### Phase 1: Add Slot Registry (v2.1, Non-Breaking)
- Introduce `BindingSlotDefinition` interface
- Add `slots` field to `CustomBlockSpec`
- Core blocks continue to use hardcoded slot mappings
- All existing schemas continue to work

### Phase 2: Core Block Migration (v2.2, Internal)
- Migrate core blocks to use slot registry internally
- No external API change
- Enables unified validation and suggestion logic

### Phase 3: Community Adoption (v2.3-2.9)
- Document custom slot definition
- Publish domain-specific block packages
- Example: `@liquidcode/project-management` (Gantt, PERT, etc.)

### Phase 4: Deprecate Implicit Slots (v3.0)
- All block types (core + custom) must declare slots
- Backward compatibility maintained via auto-generated definitions

---

## Benefits

### Domain Extensibility
Custom blocks become first-class citizens with proper binding semantics.

### Type Safety
Compile-time validation of binding completeness and correctness.

### Better LLM Guidance
LLM context includes slot definitions, enabling better binding suggestions.

### Discovery Engine Improvement
Slot metadata (examples, descriptions) improves binding inference quality.

### Ecosystem Growth
Domain packages can ship block definitions with proper slot schemas.

---

## Examples

### Network Diagram Block

```typescript
engine.catalog.register({
  type: 'custom:network',
  version: '1.0.0',
  category: 'atomic',
  slots: [
    {
      name: 'source',
      required: true,
      valueType: 'string',
      description: 'Source node identifier',
      examples: ['from', 'source', 'parent']
    },
    {
      name: 'target',
      required: true,
      valueType: 'string',
      description: 'Target node identifier',
      examples: ['to', 'target', 'child']
    },
    {
      name: 'weight',
      required: false,
      valueType: 'number',
      description: 'Edge weight or strength',
      examples: ['weight', 'value', 'strength']
    },
    {
      name: 'nodeLabel',
      required: false,
      valueType: 'string',
      description: 'Display label for nodes',
      examples: ['label', 'name', 'title']
    },
    {
      name: 'color',
      required: false,
      valueType: 'string',
      description: 'Node or edge color',
      examples: ['color', 'category', 'type']
    }
  ]
});

// LiquidCode usage
custom:network$from$to$strength$name$category
```

### Sankey Diagram Block

```typescript
engine.catalog.register({
  type: 'custom:sankey',
  version: '1.0.0',
  category: 'atomic',
  slots: [
    {
      name: 'from',
      required: true,
      valueType: 'string',
      description: 'Source stage or category',
      examples: ['from', 'source', 'stage']
    },
    {
      name: 'to',
      required: true,
      valueType: 'string',
      description: 'Target stage or category',
      examples: ['to', 'target', 'nextStage']
    },
    {
      name: 'flow',
      required: true,
      valueType: 'number',
      description: 'Flow volume between stages',
      examples: ['value', 'amount', 'count', 'flow']
    },
    {
      name: 'color',
      required: false,
      valueType: 'string',
      description: 'Flow color or category',
      examples: ['color', 'category', 'type']
    }
  ]
});

// LiquidCode usage
custom:sankey$stage$nextStage$value$type
```

---

## Testing Requirements

```typescript
describe('Binding Slot Registry', () => {
  it('registers custom block slots', () => {
    catalog.register({
      type: 'custom:gantt',
      slots: [{ name: 'task', required: true, valueType: 'string', description: 'Task' }]
    });

    const slots = catalog.getSlots('custom:gantt');
    expect(slots).toHaveLength(1);
    expect(slots[0].name).toBe('task');
  });

  it('validates required slots are bound', () => {
    const block = {
      type: 'custom:gantt',
      binding: {
        fields: [
          { target: 'task', field: 'taskName' }
          // Missing required 'startDate' and 'endDate'
        ]
      }
    };

    const result = validateBlockBinding(block, catalog);
    expect(result.valid).toBe(false);
    expect(result.errors).toContainEqual(
      expect.objectContaining({ message: expect.stringContaining('startDate') })
    );
  });

  it('suggests bindings based on slot definitions', () => {
    const suggestions = suggestBindings(
      'custom:gantt',
      { fields: [
        { name: 'taskTitle', type: 'string' },
        { name: 'startDate', type: 'date' },
        { name: 'endDate', type: 'date' }
      ]},
      catalog
    );

    expect(suggestions).toContainEqual(
      expect.objectContaining({
        slot: 'task',
        field: 'taskTitle',
        score: expect.any(Number)
      })
    );
  });
});
```

---

## Documentation Requirements

### Developer Guide Section

**Title:** "Custom Block Binding Slots"

**Contents:**
1. When to define custom slots
2. Slot definition API reference
3. Slot types and validation
4. Binding suggestion integration
5. Examples for common visualizations
6. Publishing domain block packages

### API Reference

- `CustomBlockSpec.slots` field
- `BindingSlotDefinition` interface
- `BlockCatalog.getSlots()` method
- Slot validation functions

---

## Implementation Checklist

- [ ] Define `BindingSlotDefinition` interface
- [ ] Add `slots` field to `CustomBlockSpec`
- [ ] Implement slot registry in `BlockCatalog`
- [ ] Extend parser to handle custom slots
- [ ] Implement binding validation
- [ ] Integrate with discovery engine suggestions
- [ ] Write conformance tests
- [ ] Document custom slot definition
- [ ] Create example block packages

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** Medium (extends block registration API)
**Breaking Changes:** None (additive feature)
**Version Target:** v2.1

**Rationale Integration:** Custom blocks need custom semantics. Without binding slot extensibility, custom blocks are crippled - they exist but can't properly express their data requirements. This resolves the gap and enables true domain-specific block ecosystems.
