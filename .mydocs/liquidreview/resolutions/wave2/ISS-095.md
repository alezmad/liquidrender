# Resolution: ISS-095

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Layout with Zero-Width Container
**Severity:** significant
**Category:** edge-cases
**Target:** SPEC
**Section:** §11 Layout & Responsiveness System

## Problem Statement

Behavior with zero or negative container dimensions is undefined. The specification defines slot context (§11.10) and responsive breakpoints (§11.11) but does not specify what happens when:

1. Container width is 0 (hidden parent, collapsed sidebar)
2. Container width is negative (impossible but may occur from bugs)
3. Container height is 0 (fully scrolled, lazy loading)
4. Container dimensions change to/from zero dynamically
5. Nested containers have zero dimensions while parent is visible

Without defined behavior, adapters may:
- Attempt to render into zero space (layout thrashing)
- Divide by zero in layout calculations
- Waste CPU rendering invisible content
- Have inconsistent behavior on show/hide

## Resolution

### Specification Addition

Add the following subsection to §11 Layout & Responsiveness System, after §11.16 Priority Conflict Resolution:

#### §11.17 Zero and Invalid Dimensions

When slot context has zero or invalid dimensions, the system applies **minimum viable constraints** and **lazy rendering** strategies.

**Dimension Validation:**

All container dimensions are validated and clamped to safe ranges:

```typescript
interface DimensionConstraints {
  minWidth: number;      // Minimum viable width (default: 320px)
  minHeight: number;     // Minimum viable height (default: 200px)
  maxWidth: number;      // Maximum reasonable width (default: 7680px - 8K)
  maxHeight: number;     // Maximum reasonable height (default: 4320px - 8K)
}

const DEFAULT_CONSTRAINTS: DimensionConstraints = {
  minWidth: 320,    // iPhone SE width
  minHeight: 200,   // Minimum for meaningful content
  maxWidth: 7680,   // 8K display width
  maxHeight: 4320,  // 8K display height
};

function validateDimensions(
  width: number,
  height: number | 'auto',
  constraints: DimensionConstraints = DEFAULT_CONSTRAINTS
): ValidatedDimensions {
  const warnings: string[] = [];

  // Validate width
  let validatedWidth = width;

  if (!isFinite(width) || width < 0) {
    validatedWidth = constraints.minWidth;
    warnings.push(`Invalid width ${width}, using minimum: ${constraints.minWidth}px`);
  } else if (width === 0) {
    validatedWidth = constraints.minWidth;
    warnings.push(`Zero width detected, using minimum: ${constraints.minWidth}px`);
  } else if (width > constraints.maxWidth) {
    validatedWidth = constraints.maxWidth;
    warnings.push(`Width ${width}px exceeds maximum, clamping to ${constraints.maxWidth}px`);
  } else if (width < constraints.minWidth) {
    validatedWidth = constraints.minWidth;
    warnings.push(`Width ${width}px below minimum, using ${constraints.minWidth}px`);
  }

  // Validate height
  let validatedHeight = height;

  if (height !== 'auto') {
    if (!isFinite(height) || height < 0) {
      validatedHeight = constraints.minHeight;
      warnings.push(`Invalid height ${height}, using minimum: ${constraints.minHeight}px`);
    } else if (height === 0) {
      validatedHeight = 'auto'; // Zero height → auto (content-based)
      warnings.push('Zero height detected, using auto height');
    } else if (height > constraints.maxHeight) {
      validatedHeight = constraints.maxHeight;
      warnings.push(`Height ${height}px exceeds maximum, clamping to ${constraints.maxHeight}px`);
    }
  }

  return {
    width: validatedWidth,
    height: validatedHeight,
    warnings,
    isZeroWidth: width === 0,
    isZeroHeight: height === 0,
  };
}

interface ValidatedDimensions {
  width: number;
  height: number | 'auto';
  warnings: string[];
  isZeroWidth: boolean;
  isZeroHeight: boolean;
}
```

**Zero-Width Handling Strategy:**

When container width is zero or near-zero, apply **lazy rendering** to avoid wasted work:

```typescript
interface RenderDecision {
  shouldRender: boolean;
  reason: string;
  deferredUntil?: 'visibility' | 'resize';
}

function shouldRenderInContainer(
  context: SlotContext,
  schema: LiquidSchema
): RenderDecision {
  const validated = validateDimensions(context.width, context.height);

  // Zero width: defer rendering until visible
  if (validated.isZeroWidth) {
    return {
      shouldRender: false,
      reason: 'Container width is zero (likely hidden or collapsed)',
      deferredUntil: 'visibility',
    };
  }

  // Very small width: defer rendering
  if (validated.width < 100) {
    return {
      shouldRender: false,
      reason: `Container width ${validated.width}px too small for meaningful content`,
      deferredUntil: 'resize',
    };
  }

  // Normal case: render
  return {
    shouldRender: true,
    reason: 'Container has valid dimensions',
  };
}
```

**Lazy Rendering Implementation:**

Adapters MUST implement lazy rendering for zero-width containers:

```typescript
interface LazyRenderState {
  schema: LiquidSchema;
  context: SlotContext;
  rendered: boolean;
  observer?: ResizeObserver | IntersectionObserver;
}

class LazyLiquidRenderer {
  private state: LazyRenderState;

  constructor(schema: LiquidSchema, context: SlotContext) {
    this.state = {
      schema,
      context,
      rendered: false,
    };

    // Check if should render immediately
    const decision = shouldRenderInContainer(context, schema);

    if (decision.shouldRender) {
      this.render();
    } else {
      this.setupLazyRender(decision.deferredUntil);
    }
  }

  private setupLazyRender(trigger: 'visibility' | 'resize') {
    if (trigger === 'visibility') {
      // Wait for container to become visible
      this.state.observer = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting) {
            this.render();
            this.state.observer?.disconnect();
          }
        },
        { threshold: 0.01 }
      );
      this.state.observer.observe(this.containerElement);
    } else {
      // Wait for container to resize
      this.state.observer = new ResizeObserver(
        (entries) => {
          const { width } = entries[0].contentRect;
          if (width >= 100) {
            this.render();
            this.state.observer?.disconnect();
          }
        }
      );
      this.state.observer.observe(this.containerElement);
    }
  }

  private render() {
    if (this.state.rendered) return;

    // Update context with current dimensions
    const rect = this.containerElement.getBoundingClientRect();
    this.state.context = {
      ...this.state.context,
      width: rect.width,
      height: rect.height,
    };

    // Render schema
    const output = this.adapter.renderWithContext(
      this.state.schema,
      this.data,
      this.state.context
    );

    this.containerElement.appendChild(output);
    this.state.rendered = true;
  }
}
```

**Zero-Height Handling:**

Zero height is less problematic (content can determine height), but still validated:

```typescript
function handleZeroHeight(
  height: number | 'auto'
): number | 'auto' {
  if (height === 0) {
    // Zero height → use auto (content-based)
    return 'auto';
  }

  if (height === 'auto') {
    // Already auto, no change needed
    return 'auto';
  }

  // Specific height, use as-is
  return height;
}
```

**Minimum Viable Layout:**

When forced to render in constrained space, use minimum viable layout:

```typescript
interface MinimumViableLayout {
  columns: number;
  visibleBlocks: number;
  strategy: 'single-column' | 'icon-only' | 'placeholder';
}

function getMinimumViableLayout(
  width: number,
  blocks: Block[]
): MinimumViableLayout {
  if (width < 100) {
    // Too small for any content
    return {
      columns: 1,
      visibleBlocks: 0,
      strategy: 'placeholder',
    };
  }

  if (width < 200) {
    // Only icon-sized blocks
    return {
      columns: 1,
      visibleBlocks: 1,
      strategy: 'icon-only',
    };
  }

  if (width < 320) {
    // Single column, compact
    return {
      columns: 1,
      visibleBlocks: Math.min(blocks.length, 3),
      strategy: 'single-column',
    };
  }

  // Normal layout possible
  return {
    columns: Math.floor(width / 200), // ~200px per column
    visibleBlocks: blocks.length,
    strategy: 'single-column',
  };
}
```

**Dynamic Dimension Changes:**

When container dimensions change from/to zero, re-evaluate rendering:

```typescript
class DynamicDimensionHandler {
  private currentWidth: number = 0;
  private currentHeight: number | 'auto' = 'auto';
  private rendered: boolean = false;

  onResize(width: number, height: number | 'auto') {
    const wasZero = this.currentWidth === 0;
    const isZero = width === 0;

    this.currentWidth = width;
    this.currentHeight = height;

    if (wasZero && !isZero) {
      // Became visible: render
      this.render();
    } else if (!wasZero && isZero) {
      // Became hidden: optionally cleanup
      this.cleanup();
    } else if (!isZero) {
      // Normal resize: update layout
      this.updateLayout();
    }
  }

  private render() {
    if (this.rendered) return;

    const decision = shouldRenderInContainer(
      { width: this.currentWidth, height: this.currentHeight, ... },
      this.schema
    );

    if (decision.shouldRender) {
      this.doRender();
      this.rendered = true;
    }
  }

  private cleanup() {
    // Optional: remove DOM nodes for hidden containers
    // Trade-off: memory vs. re-render cost
    if (this.shouldCleanupOnHide()) {
      this.removeDOMNodes();
      this.rendered = false;
    }
  }
}
```

**Nested Container Handling:**

Nested containers (slots within slots) inherit parent visibility:

```typescript
function shouldRenderNestedContainer(
  parentContext: SlotContext,
  nestedContext: SlotContext
): RenderDecision {
  // If parent is zero-width, nested is also zero-width
  if (parentContext.width === 0) {
    return {
      shouldRender: false,
      reason: 'Parent container is hidden (width 0)',
      deferredUntil: 'visibility',
    };
  }

  // Check nested dimensions independently
  return shouldRenderInContainer(nestedContext, schema);
}
```

**Adapter Contract Extension:**

Add to §18 Adapter Interface Contract:

```typescript
interface LiquidAdapter<RenderOutput> {
  // ... existing methods ...

  // Lazy rendering support
  supportsDeferredRender: boolean;

  // Render placeholder for zero-width container
  renderZeroWidthPlaceholder(schema: LiquidSchema): RenderOutput;

  // Update layout on dimension change
  updateLayout(context: SlotContext): void;
}
```

**Error Handling:**

Zero-width is not an error, but a normal state requiring lazy rendering:

```typescript
interface DimensionWarning {
  severity: 'info' | 'warning';
  code: 'ZERO_WIDTH' | 'ZERO_HEIGHT' | 'INVALID_DIMENSION' | 'BELOW_MINIMUM';
  dimension: 'width' | 'height';
  value: number;
  action: string;
}

// Example warnings
{
  severity: 'info',
  code: 'ZERO_WIDTH',
  dimension: 'width',
  value: 0,
  action: 'Deferring render until container becomes visible',
}

{
  severity: 'warning',
  code: 'BELOW_MINIMUM',
  dimension: 'width',
  value: 150,
  action: 'Using minimum width 320px for layout calculations',
}
```

### Integration Points

1. **Layout System (§11)** - Dimension validation integrated into responsive transformation
2. **Slot Context (§11.10)** - Validation applied to all slot contexts
3. **Adapter Contract (§18)** - Adapters implement lazy rendering
4. **Compilation Pipeline (§17)** - No impact (runtime concern only)

### Examples

**Example 1: Hidden Container (Zero Width)**

```javascript
// Container is hidden (display: none or width: 0)
const context = {
  width: 0,
  height: 200,
  breakpoint: 'standard',
};

// Adapter behavior:
const decision = shouldRenderInContainer(context, schema);
// decision = { shouldRender: false, reason: 'Container width is zero', deferredUntil: 'visibility' }

// Setup observer to wait for visibility
const observer = new IntersectionObserver((entries) => {
  if (entries[0].isIntersecting) {
    // Container became visible, render now
    render(schema, data, { ...context, width: entries[0].contentRect.width });
  }
});
```

**Example 2: Collapsed Sidebar (Very Small Width)**

```javascript
// Sidebar collapsed to 60px
const context = {
  width: 60,
  height: 800,
  breakpoint: 'compact',
};

// Dimension validation:
const validated = validateDimensions(60, 800);
// validated = { width: 320, height: 800, warnings: ['Width 60px below minimum, using 320px'] }

// Layout calculation uses minimum width
const layout = getMinimumViableLayout(320, schema.blocks);
// layout = { columns: 1, visibleBlocks: 3, strategy: 'single-column' }

// But actual render width is 60px (CSS overflow: hidden)
// Result: Shows icon-only view or placeholder
```

**Example 3: Dynamically Shown Container**

```javascript
// Initially hidden
let context = { width: 0, height: 0, breakpoint: 'compact' };

// User clicks to show sidebar
// Container transitions from width: 0 → 300
context = { width: 300, height: 800, breakpoint: 'standard' };

// Dimension change handler:
dimensionHandler.onResize(300, 800);
// - Detects transition from zero to non-zero
// - Triggers render
// - Schema compiled with context { width: 300, height: 800 }
```

**Example 4: Nested Container with Hidden Parent**

```javascript
// Parent container hidden
const parentContext = { width: 0, height: 0 };

// Nested container has non-zero dimensions (from CSS)
const nestedContext = { width: 400, height: 600 };

// Should render nested?
const decision = shouldRenderNestedContainer(parentContext, nestedContext);
// decision = { shouldRender: false, reason: 'Parent container is hidden (width 0)' }

// Wait for parent to become visible before rendering nested
```

**Example 5: Invalid Dimensions (Negative)**

```javascript
// Bug produces negative width (impossible but defensive)
const context = { width: -100, height: 300 };

// Validation:
const validated = validateDimensions(-100, 300);
// validated = {
//   width: 320,
//   height: 300,
//   warnings: ['Invalid width -100, using minimum: 320px']
// }

// Render proceeds with minimum width
// No crash, graceful fallback
```

## Verification Checklist

- [x] **All invalid dimension cases handled**
  - Zero width
  - Zero height
  - Negative dimensions
  - Extremely large dimensions
  - Below minimum viable
- [x] **Lazy rendering strategy**
  - Deferred render for zero-width containers
  - Intersection observer for visibility
  - Resize observer for dimension changes
  - Cleanup on hide (optional)
- [x] **Graceful fallbacks**
  - Minimum viable layout for small containers
  - Auto height for zero height
  - Clamping for extreme values
- [x] **No math errors**
  - No divide by zero
  - No negative layout dimensions
  - Safe calculation ranges
- [x] **Dynamic handling**
  - Transitions from zero to non-zero
  - Transitions from non-zero to zero
  - Nested container visibility inheritance

## Confidence

**HIGH** - This resolution:

1. **Addresses root cause** - Defines complete handling for all invalid dimension scenarios
2. **Performance-optimized** - Lazy rendering avoids wasted work for hidden containers
3. **Graceful degradation** - Minimum viable layout for constrained spaces
4. **No crashes** - All dimensions validated and clamped to safe ranges
5. **Dynamic-friendly** - Handles show/hide transitions smoothly
6. **Testable** - Clear validation rules and decision points
7. **Follows web standards** - Uses IntersectionObserver and ResizeObserver (standard APIs)
8. **Nested-aware** - Handles nested containers with hidden parents correctly
