# ISS-121: Tiered Resolution Strategy Changes

**Issue Type:** Evolution Risk
**Category:** Extensibility and Evolution
**Priority:** Low
**Affects:** Tiered Resolution System (Section 13), Discovery Engine (Section 12)

---

## Problem Statement

Current tiered resolution (v2.0) has 4 tiers:

```
1. Cache (40% hit rate)
2. Semantic (50%)
3. Composition (9%)
4. LLM (1%)
```

This strategy will evolve as we learn from usage:

### Likely Future Changes

**V3.0 (2027):**
```
1. Cache (40%)
2. User History (25%) ← NEW tier
3. Semantic (15%)
4. ML Model (10%) ← NEW (local, not LLM)
5. Composition (9%)
6. LLM (1%)
```

**V4.0 (2029):**
```
1. Cache (45%)
2. User History + ML (30%)
3. Semantic (15%)
4. Composition (9%)
5. LLM (1%)
6. Multimodal LLM (visual mockups) ← NEW
```

### Impact Analysis

| Change | User Impact | Internal Impact |
|--------|-------------|-----------------|
| Add tier | None (transparent) | Internal only |
| Reorder tiers | Performance change | Internal only |
| Remove tier | Performance regression possible | Internal only |
| Change tier logic | Behavior change | Could affect output |

**Key insight:** As long as public API (`engine.resolve(intent)`) stays the same, tier changes are **internal implementation details**.

---

## Resolution

### Strategy: Abstraction + Configuration

Make tier system pluggable so it can evolve without breaking changes.

### Implementation

#### 1. Resolution Tier Interface

```typescript
interface ResolutionTier {
  // Metadata
  name: string;
  version: string;
  priority: number;  // Lower = higher priority (tier 1 = priority 1)

  // Resolution
  resolve(
    intent: Intent,
    context: ResolutionContext
  ): Promise<ResolutionResult | null>;

  // Performance
  estimatedLatency: number;  // ms (for tier ordering)
  estimatedHitRate?: number;  // 0-1 (for monitoring)

  // Lifecycle
  initialize?(): Promise<void>;
  shutdown?(): Promise<void>;
}

interface Intent {
  text: string;                    // User's natural language intent
  dataFingerprint: DataFingerprint;  // Data schema
  context?: Record<string, any>;   // Additional context
}

interface ResolutionContext {
  userId?: string;
  sessionId?: string;
  history?: ResolutionHistory[];
  preferences?: UserPreferences;
}

interface ResolutionResult {
  schema: LiquidSchema;
  source: string;                  // Tier name
  confidence: number;              // 0-1
  latency: number;                 // ms
  metadata?: Record<string, any>;
}
```

#### 2. Tier Registry

```typescript
class ResolutionTierRegistry {
  private tiers: Map<string, ResolutionTier> = new Map();

  register(tier: ResolutionTier): void {
    this.tiers.set(tier.name, tier);
  }

  unregister(name: string): void {
    this.tiers.delete(name);
  }

  getTiers(): ResolutionTier[] {
    // Return tiers sorted by priority
    return Array.from(this.tiers.values())
      .sort((a, b) => a.priority - b.priority);
  }

  get(name: string): ResolutionTier | undefined {
    return this.tiers.get(name);
  }
}
```

#### 3. Pluggable Resolution Engine

```typescript
class ResolutionEngine {
  constructor(
    private registry: ResolutionTierRegistry,
    private config: ResolutionConfig = {}
  ) {}

  async resolve(intent: Intent, context: ResolutionContext): Promise<LiquidSchema> {
    const tiers = this.registry.getTiers();
    const results: ResolutionAttempt[] = [];

    for (const tier of tiers) {
      // Skip tier if disabled
      if (this.config.disabledTiers?.includes(tier.name)) {
        continue;
      }

      const startTime = Date.now();

      try {
        const result = await tier.resolve(intent, context);

        if (result) {
          // Tier succeeded
          const latency = Date.now() - startTime;

          this.logSuccess(tier, result, latency);
          this.updateMetrics(tier, true, latency);

          return result.schema;
        }

        // Tier returned null (miss), try next tier
        results.push({ tier: tier.name, result: 'miss' });

      } catch (error) {
        // Tier failed, try next tier
        results.push({ tier: tier.name, result: 'error', error });
        this.logError(tier, error);
      }
    }

    // All tiers missed
    throw new ResolutionError(
      'All resolution tiers failed',
      { attempts: results }
    );
  }

  // Configuration
  configure(config: ResolutionConfig): void {
    this.config = { ...this.config, ...config };
  }
}

interface ResolutionConfig {
  disabledTiers?: string[];        // Tiers to skip
  tierTimeout?: number;            // Max time per tier (ms)
  requireMinConfidence?: number;   // Minimum confidence threshold
  parallelTiers?: boolean;         // Try tiers in parallel (risky!)
}
```

#### 4. Built-in Tiers (V2.0)

```typescript
// Tier 1: Cache
class CacheTier implements ResolutionTier {
  name = 'cache';
  version = '2.0.0';
  priority = 1;
  estimatedLatency = 5;
  estimatedHitRate = 0.4;

  constructor(private storage: FragmentStorage) {}

  async resolve(intent: Intent, context: ResolutionContext): Promise<ResolutionResult | null> {
    const key = this.generateCacheKey(intent);
    const cached = await this.storage.get(key);

    if (!cached) return null;

    return {
      schema: cached.schema,
      source: 'cache',
      confidence: 1.0,
      latency: 5,
      metadata: { cacheKey: key }
    };
  }

  private generateCacheKey(intent: Intent): CacheKey {
    return {
      intentHash: hash(intent.text),
      dataFingerprint: intent.dataFingerprint.hash,
      scope: 'interface'
    };
  }
}

// Tier 2: Semantic Search
class SemanticSearchTier implements ResolutionTier {
  name = 'semantic';
  version = '2.0.0';
  priority = 2;
  estimatedLatency = 50;
  estimatedHitRate = 0.5;

  async resolve(intent: Intent, context: ResolutionContext): Promise<ResolutionResult | null> {
    const embedding = await this.embedIntent(intent.text);
    const matches = await this.storage.search(embedding, 10);

    if (matches.length === 0 || matches[0].similarity < 0.85) {
      return null;  // No good match
    }

    const best = matches[0];

    // Apply adaptations if needed
    const adapted = await this.applyAdaptations(
      best.fragment.schema,
      intent,
      best.adaptations
    );

    return {
      schema: adapted,
      source: 'semantic',
      confidence: best.similarity,
      latency: 50,
      metadata: { similarity: best.similarity, adaptations: best.adaptations }
    };
  }
}

// Tier 3: Composition
class CompositionTier implements ResolutionTier {
  name = 'composition';
  version = '2.0.0';
  priority = 3;
  estimatedLatency = 100;
  estimatedHitRate = 0.09;

  async resolve(intent: Intent, context: ResolutionContext): Promise<ResolutionResult | null> {
    const pattern = this.detectPattern(intent);
    if (!pattern) return null;

    const fragments = await this.findFragments(pattern);
    if (fragments.length === 0) return null;

    const composed = await this.composer.compose(fragments, intent);

    return {
      schema: composed,
      source: 'composition',
      confidence: 0.8,
      latency: 100,
      metadata: { pattern: pattern.name, fragments: fragments.length }
    };
  }
}

// Tier 4: LLM Generation
class LLMGenerationTier implements ResolutionTier {
  name = 'llm';
  version = '2.0.0';
  priority = 4;
  estimatedLatency = 500;
  estimatedHitRate = 1.0;  // Always succeeds (fallback)

  async resolve(intent: Intent, context: ResolutionContext): Promise<ResolutionResult> {
    const liquidCode = await this.llm.generate({
      prompt: this.buildPrompt(intent),
      maxTokens: 100
    });

    const schema = this.compiler.compile(liquidCode);

    return {
      schema,
      source: 'llm',
      confidence: 0.9,
      latency: 500,
      metadata: { tokens: liquidCode.length }
    };
  }
}
```

#### 5. New Tier Example (V3.0): User History

```typescript
class UserHistoryTier implements ResolutionTier {
  name = 'user-history';
  version = '3.0.0';
  priority = 2;  // Between cache and semantic
  estimatedLatency = 30;
  estimatedHitRate = 0.25;

  async resolve(intent: Intent, context: ResolutionContext): Promise<ResolutionResult | null> {
    if (!context.userId) return null;

    // Find user's previous interfaces with similar intent
    const history = await this.getUserHistory(context.userId);
    const similar = this.findSimilarIntents(intent, history);

    if (similar.length === 0) return null;

    const mostRecent = similar[0];

    // Adapt to current data
    const adapted = await this.adaptToData(
      mostRecent.schema,
      intent.dataFingerprint
    );

    return {
      schema: adapted,
      source: 'user-history',
      confidence: 0.85,
      latency: 30,
      metadata: { historicalMatch: mostRecent.id }
    };
  }
}

// Register new tier in v3.0
engine.resolution.registerTier(new UserHistoryTier());
```

---

## Configuration Examples

### Default Configuration (V2.0)

```typescript
const engine = new LiquidEngine({
  resolution: {
    tiers: [
      new CacheTier(storage),
      new SemanticSearchTier(storage, embedder),
      new CompositionTier(storage, composer),
      new LLMGenerationTier(llmProvider)
    ]
  }
});
```

### Custom Configuration (V3.0)

```typescript
const engine = new LiquidEngine({
  resolution: {
    tiers: [
      new CacheTier(storage),
      new UserHistoryTier(userStore),       // NEW
      new SemanticSearchTier(storage),
      new MLModelTier(localModel),          // NEW
      new CompositionTier(storage, composer),
      new LLMGenerationTier(llmProvider)
    ],
    config: {
      disabledTiers: [],
      tierTimeout: 5000,
      requireMinConfidence: 0.7
    }
  }
});
```

### Disabled Tiers (Cost Optimization)

```typescript
// Disable expensive LLM tier, rely on cache/semantic
const engine = new LiquidEngine({
  resolution: {
    config: {
      disabledTiers: ['llm']  // Fall back to error instead of LLM
    }
  }
});
```

---

## Monitoring & Analytics

### Tier Performance Metrics

```typescript
interface TierMetrics {
  tier: string;
  attempts: number;
  successes: number;
  failures: number;
  hitRate: number;
  avgLatency: number;
  p50Latency: number;
  p99Latency: number;
}

class ResolutionAnalytics {
  getTierMetrics(): TierMetrics[] {
    return this.tiers.map(tier => ({
      tier: tier.name,
      attempts: this.metrics[tier.name].attempts,
      successes: this.metrics[tier.name].successes,
      failures: this.metrics[tier.name].failures,
      hitRate: this.metrics[tier.name].successes / this.metrics[tier.name].attempts,
      avgLatency: this.metrics[tier.name].totalLatency / this.metrics[tier.name].attempts,
      p50Latency: this.percentile(tier.name, 0.5),
      p99Latency: this.percentile(tier.name, 0.99)
    }));
  }
}
```

### Tier Effectiveness Dashboard

```typescript
// Example output
{
  "period": "2025-12-01 to 2025-12-31",
  "totalRequests": 10000,
  "tiers": [
    {
      "tier": "cache",
      "hitRate": 0.42,
      "avgLatency": 4.2,
      "cost": 0
    },
    {
      "tier": "user-history",
      "hitRate": 0.24,
      "avgLatency": 28,
      "cost": 0
    },
    {
      "tier": "semantic",
      "hitRate": 0.18,
      "avgLatency": 52,
      "cost": 0.001  // Embedding cost
    },
    {
      "tier": "composition",
      "hitRate": 0.10,
      "avgLatency": 95,
      "cost": 0
    },
    {
      "tier": "llm",
      "hitRate": 0.06,
      "avgLatency": 480,
      "cost": 0.05  // Per request
    }
  ]
}
```

---

## Migration Path

### Phase 1: Tier Abstraction (v2.1)
- Implement `ResolutionTier` interface
- Migrate existing tiers to interface
- No functional change (refactor only)

### Phase 2: Registry System (v2.2)
- Add tier registry
- Configuration options
- Monitoring infrastructure

### Phase 3: New Tiers (v3.0+)
- User history tier (v3.0)
- ML model tier (v3.0)
- Multimodal tier (v4.0)

---

## Benefits

### Internal Flexibility
Add/remove/reorder tiers without breaking changes.

### Performance Tuning
Configure tier behavior per deployment.

### Cost Optimization
Disable expensive tiers if budget-constrained.

### Experimentation
A/B test different tier configurations.

### Transparency
Monitoring shows which tiers are effective.

---

## Testing Requirements

```typescript
describe('Tiered Resolution', () => {
  it('tries tiers in priority order', async () => {
    const tiers = [
      createMockTier('cache', 1, null),      // Miss
      createMockTier('semantic', 2, null),   // Miss
      createMockTier('llm', 3, schema)       // Hit
    ];

    const result = await engine.resolve(intent, context);

    expect(result).toEqual(schema);
    expect(tiers[0].resolve).toHaveBeenCalled();
    expect(tiers[1].resolve).toHaveBeenCalled();
    expect(tiers[2].resolve).toHaveBeenCalled();
  });

  it('stops at first successful tier', async () => {
    const tiers = [
      createMockTier('cache', 1, null),      // Miss
      createMockTier('semantic', 2, schema),  // Hit!
      createMockTier('llm', 3, schema)       // Not called
    ];

    const result = await engine.resolve(intent, context);

    expect(result).toEqual(schema);
    expect(tiers[2].resolve).not.toHaveBeenCalled();
  });

  it('respects disabled tiers', async () => {
    engine.configure({ disabledTiers: ['llm'] });

    const tiers = [
      createMockTier('cache', 1, null),
      createMockTier('llm', 2, schema)
    ];

    await expect(engine.resolve(intent, context))
      .rejects.toThrow('All resolution tiers failed');

    expect(tiers[1].resolve).not.toHaveBeenCalled();
  });
});
```

---

## Documentation Requirements

### Resolution System Guide

**Title:** "Understanding Tiered Resolution"

**Contents:**
1. How resolution works (tier waterfall)
2. Built-in tiers and when they trigger
3. Configuring tiers
4. Disabling tiers
5. Monitoring tier performance
6. Custom tier development

---

## Implementation Checklist

- [ ] Define `ResolutionTier` interface
- [ ] Implement `ResolutionTierRegistry`
- [ ] Refactor existing tiers to interface
- [ ] Add configuration system
- [ ] Implement monitoring/metrics
- [ ] Document tier system
- [ ] Create custom tier guide

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** Low (internal abstraction)
**Breaking Changes:** None (public API unchanged)
**Version Target:** v2.1 (infrastructure), v3.0+ (new tiers)

**Rationale Integration:** The tiered resolution system will evolve as we learn from usage. Making it pluggable and configurable allows internal evolution without breaking the public API (`engine.resolve(intent)`). Users don't care how resolution works, only that it's fast and accurate. This abstraction preserves that contract.

**Philosophy:** **Resolution is a black box.** Users provide intent, engine returns schema. The internal tier strategy can change freely as long as the contract holds.
