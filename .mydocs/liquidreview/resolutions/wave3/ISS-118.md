# ISS-118: Block Primitive Evolution

**Issue Type:** Evolution Risk
**Category:** Extensibility and Evolution
**Priority:** Low
**Affects:** Core Architecture (Section 3), The Three Primitives (Section 4)

---

## Problem Statement

LiquidCode's core claim: **"Any interface can be expressed with three primitives: Block, Slot, Signal"**

This is a strong architectural commitment. What if, after 3-5 years of usage, we discover patterns that don't fit?

### Potential Fourth Primitives

Scenarios that might require new primitives:

1. **Portals** - Blocks that render in multiple locations simultaneously
2. **Contexts** - Shared state that affects multiple blocks but isn't a signal
3. **Constraints** - Layout relationships that cross block boundaries
4. **Streams** - Real-time data flows that aren't signals
5. **Annotations** - Metadata layers over existing blocks

### Example: Portal Use Case

```typescript
// User wants a block to appear in sidebar AND in main content
// Slots can't express this (a block can only be in one slot at a time)

// Hypothetical syntax
{
  uid: 'b1',
  type: 'kpi',
  portal: {
    locations: ['@sidebar', '@header']  // Render in multiple places
  }
}
```

### Example: Context Use Case

```typescript
// User wants to set a theme that affects all blocks
// Signals are for user interaction, not passive environment

// Hypothetical syntax
{
  context: {
    theme: {
      name: 'dark',
      colors: { primary: '#fff', secondary: '#888' }
    }
  },
  blocks: [
    // All blocks inherit theme context
  ]
}
```

---

## Resolution

### Strategy: Resist Adding Primitives

The three primitives (Block, Slot, Signal) are **intentionally minimal**. Adding a fourth primitive is a **last resort**, requiring extraordinary justification.

### Implementation

#### 1. Evaluation Framework

Before adding a fourth primitive, the feature must:

1. **Cannot be expressed** with existing primitives (even awkwardly)
2. **Appears in >20%** of real-world interfaces
3. **Fundamentally different** from Block/Slot/Signal semantics
4. **Community consensus** among adapter authors and users
5. **Benefits justify** breaking change and complexity

#### 2. Portal Alternative: Signal-Based Rendering

Portals can be expressed with signals + special slot types:

```typescript
// No fourth primitive needed - use signals!

// Block emits its rendered content as a signal
{
  uid: 'b1',
  type: 'kpi',
  binding: { value: 'revenue' },
  signals: {
    emits: [
      {
        signal: '@renderedContent',
        trigger: 'onRender',
        transform: 'self.render()'  // Emit own render output
      }
    ]
  }
}

// Slots receive and re-render the content
{
  uid: 'sidebar',
  type: 'stack',
  slots: {
    children: [
      {
        uid: 'portal-target-1',
        type: 'portal-slot',  // Special block type
        signals: {
          receives: [
            {
              signal: '@renderedContent',
              target: 'content'
            }
          ]
        }
      }
    ]
  }
}

// Result: b1 renders once, content appears in multiple portal-slots
```

**Assessment:** Portal handled via custom block type (`portal-slot`), no new primitive.

#### 3. Context Alternative: Interface-Level Signals

Contexts are just interface-scoped signals with auto-receive:

```typescript
// No fourth primitive needed - use signals with auto-inheritance!

{
  version: '2.0.0',
  signals: {
    '@theme': {
      type: 'custom',  // Or register 'theme' signal type
      default: { mode: 'dark', colors: {...} },
      persist: 'local'
    }
  },
  // All blocks auto-receive @theme (inherited)
  blocks: [
    {
      type: 'kpi',
      // No explicit receives needed - inherits parent @theme
    }
  ]
}
```

**Assessment:** Context handled via signal inheritance (Section 10.7), no new primitive.

#### 4. Constraints Alternative: Relationship System

Layout constraints are already in the spec (Section 11.5):

```typescript
// Existing: Relationship system
{
  layout: {
    relationship: {
      type: 'compare',  // Equal heights
      with: ['@K1', '@K2']
    }
  }
}
```

If more complex constraints needed, extend relationship types, don't add primitive.

**Assessment:** Constraints handled via layout system, no new primitive.

#### 5. Decision Tree for Fourth Primitive

```
New pattern emerges in wild
    ↓
Can it be expressed with Block/Slot/Signal?
    ├─ Yes → Document pattern, add to cookbook
    └─ No (awkward/impossible)
        ↓
        Does it appear in >20% of interfaces?
            ├─ No → Niche case, custom block type OK
            └─ Yes
                ↓
                Can we extend existing primitives?
                    ├─ Yes → Extend (e.g., new signal type, new slot behavior)
                    └─ No
                        ↓
                        Community RFC + 6-month feedback period
                            ↓
                        Consensus reached?
                            ├─ No → Don't add
                            └─ Yes
                                ↓
                            Prototype in v(X).experimental
                                ↓
                            Production usage for 1 year
                                ↓
                            Proven essential?
                                ├─ No → Deprecate experimental
                                └─ Yes → Promote to core primitive in v(X+1).0
```

#### 6. Primitive Extension (Not Addition)

Instead of adding primitives, **extend existing ones**:

**Block Extensions:**
- New block types (already supported via `custom:${string}`)
- New block capabilities (e.g., `virtualized`, `lazy-loaded`)

**Slot Extensions:**
- Named slots already flexible
- Add slot types if needed (e.g., `portal-slot`, `conditional-slot`)

**Signal Extensions:**
- Custom signal types (ISS-112)
- Signal scoping and inheritance (already in spec)
- Signal transformations

**Justification:** Extensions are non-breaking, primitives are breaking.

#### 7. Pattern Cookbook

Maintain a **Pattern Cookbook** documenting how to express common needs with existing primitives:

```markdown
# LiquidCode Pattern Cookbook

## Portal Pattern
**Need:** Render block in multiple locations
**Solution:** Use portal-slot custom block + content signal

## Theme Pattern
**Need:** Global styling context
**Solution:** Use interface-level signal with inheritance

## Conditional Rendering Pattern
**Need:** Show/hide blocks based on conditions
**Solution:** Use signal + visibility binding

## Master-Detail Pattern
**Need:** Selection in one block affects another
**Solution:** Use selection signal + filter binding
```

This prevents "pattern blindness" where users think they need new primitives when existing ones suffice.

---

## Monitoring Strategy

### Usage Analytics

Track interface patterns that might indicate primitive gaps:

```typescript
interface PrimitiveUsageAnalytics {
  // Primitives used
  blockCount: number;
  slotDepth: number;
  signalCount: number;

  // Workaround indicators (possible primitive gaps)
  customBlockTypes: string[];           // Heavy custom block usage?
  deepSlotNesting: number;              // >5 levels = trying to fake something?
  circularSignalReferences: number;     // Signals used for non-signal purposes?
  complexTransforms: string[];          // Hacks in LiquidExpr?

  // Adapter feedback
  unsupportedPatterns: string[];        // Patterns adapters struggle to render
  placeholderUsage: number;             // High = missing block types
}
```

If analytics show persistent workarounds in 20%+ of interfaces, investigate.

### Community Feedback Loop

```typescript
// Quarterly primitive review
interface PrimitiveReview {
  period: string;                       // "2025-Q4"
  totalInterfaces: number;
  patternFrequency: Map<string, number>;  // Which patterns are common?
  workaroundRate: number;               // % using workarounds
  communityRequests: FourthPrimitiveRequest[];
}

interface FourthPrimitiveRequest {
  proposedPrimitive: string;            // "Context", "Portal", etc.
  frequency: number;                    // How many users request it
  existingSolution?: string;            // Can it be done today?
  costBenefit: number;                  // Complexity vs utility
}
```

If a pattern appears in >20% of quarterly reviews for 4 consecutive quarters, trigger RFC process.

---

## Migration Path (If Fourth Primitive Needed)

**Hypothetical:** "Context" primitive proves necessary in 2028

### Phase 1: Experimental Feature (v3.5)

```typescript
// V3.5: Add as experimental, opt-in feature
{
  version: '3.5.0',
  features: {
    experimentalContexts: true  // Must opt-in
  },
  contexts: {  // New top-level field
    theme: { mode: 'dark', colors: {...} }
  },
  blocks: [...]
}
```

### Phase 2: Stabilization (v3.6-3.9)

- Gather feedback on experimental contexts
- Refine semantics
- Document patterns
- Adapter support

### Phase 3: Core Primitive (v4.0)

```typescript
// V4.0: Contexts promoted to fourth primitive
interface LiquidSchema {
  // The four primitives
  blocks: Block[];      // Primitive 1
  slots: SlotMap;       // Primitive 2 (implicit in blocks)
  signals: SignalRegistry;  // Primitive 3
  contexts: ContextRegistry;  // Primitive 4 (NEW)
}
```

**Migration v3.x → v4.0:**
- Schemas without contexts: no change
- Schemas with contexts: already using them (experimental flag removed)

---

## Testing Requirements

### Primitive Completeness Tests

```typescript
describe('Three Primitives Completeness', () => {
  it('expresses portal pattern without fourth primitive', () => {
    const schema = createPortalPattern();  // Using signals + custom block
    expect(isValidSchema(schema)).toBe(true);
    expect(getPrimitiveCount(schema)).toBe(3);  // Still just 3
  });

  it('expresses context pattern without fourth primitive', () => {
    const schema = createContextPattern();  // Using signal inheritance
    expect(isValidSchema(schema)).toBe(true);
  });

  it('expresses all cookbook patterns', () => {
    const patterns = loadCookbookPatterns();
    patterns.forEach(pattern => {
      expect(canExpressWithThreePrimitives(pattern)).toBe(true);
    });
  });
});
```

---

## Documentation Requirements

### Pattern Cookbook

**Title:** "Common Interface Patterns with Three Primitives"

**Contents:**
1. Portal pattern (multi-location rendering)
2. Theme pattern (global context)
3. Master-detail pattern (selection)
4. Conditional rendering
5. Real-time updates
6. Multi-tab synchronization
7. Nested dashboards
8. Progressive disclosure

Each pattern shows:
- Problem statement
- Solution using Block/Slot/Signal
- Example LiquidCode
- Why a fourth primitive isn't needed

---

## Implementation Checklist

- [ ] Create pattern cookbook documentation
- [ ] Implement primitive usage analytics
- [ ] Set up quarterly primitive review process
- [ ] Document RFC process for primitive additions
- [ ] Create experimental feature flag system
- [ ] Write completeness tests for common patterns

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** Low (defensive strategy, no immediate changes)
**Breaking Changes:** None (preserves three primitives)
**Version Target:** Ongoing monitoring, no specific version

**Rationale Integration:** The three-primitive claim is a **core architectural strength**. Adding a fourth primitive should be extraordinarily rare and require overwhelming evidence. This resolution establishes guardrails to prevent premature primitive addition while acknowledging it may eventually be necessary.

**Philosophy:** **Primitives are not features.** They are fundamental building blocks. Keep them minimal. Extend them creatively. Add new ones only when absolutely unavoidable.
