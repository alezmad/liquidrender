# Resolution: ISS-076 - Signal Circular Dependency Deadlock

**Issue ID:** ISS-076
**Severity:** Critical
**Target Document:** `.mydocs/liquidcode/LIQUIDCODE-SPEC-v2.md`
**Review Source:** 08-edge-cases-failure-modes.md (Failure 1)
**Date:** 2025-12-21

---

## Problem Statement

**Current State:** The specification lacks detection and prevention mechanisms for circular signal dependencies, creating a critical failure mode where signal propagation can deadlock the system.

**Trigger Example:**
```liquidcode
§signalA:custom
§signalB:custom
Block1<@signalA>@signalB
Block2<@signalB>@signalA
```

**Impact:**
- Infinite loop during signal propagation
- Runtime hangs, adapter never completes render
- Host application becomes unresponsive
- **CRITICAL:** Violates "never crash host runtime" guarantee (§B.3.1)

**Current Handling:**
- §10: No mention of cycle detection
- §B.3.3: Conformance test says "does not deadlock on circular signal reference" but doesn't specify HOW to prevent it

---

## Resolution

### 1. Add Cycle Detection to §10.8 (New Subsection)

Add the following after §10.7 (Signal Inheritance):

```markdown
### 10.8 Signal Cycle Detection and Prevention

**Problem:** Circular signal dependencies can cause infinite propagation loops, violating the render guarantee.

**Example cycle:**
```liquidcode
§filterA:filter
§filterB:filter
Block1<@filterA>@filterB    # Receives A, emits B
Block2<@filterB>@filterA    # Receives B, emits A
```

#### 10.8.1 Compile-Time Cycle Detection

The compiler MUST detect cycles in signal dependencies before allowing schema validation to pass.

**Algorithm:**

```typescript
interface SignalNode {
  blockUid: string;
  emits: string[];
  receives: string[];
}

function detectSignalCycles(schema: LiquidSchema): CycleDetectionResult {
  const graph = buildSignalDependencyGraph(schema);
  const visited = new Set<string>();
  const recursionStack = new Set<string>();
  const cycles: string[][] = [];

  for (const node of graph.nodes) {
    if (!visited.has(node.blockUid)) {
      detectCyclesDFS(node, graph, visited, recursionStack, [], cycles);
    }
  }

  return {
    hasCycles: cycles.length > 0,
    cycles: cycles,
    affectedBlocks: Array.from(new Set(cycles.flat())),
  };
}

function detectCyclesDFS(
  node: SignalNode,
  graph: SignalGraph,
  visited: Set<string>,
  recursionStack: Set<string>,
  path: string[],
  cycles: string[][]
): void {
  visited.add(node.blockUid);
  recursionStack.add(node.blockUid);
  path.push(node.blockUid);

  // For each signal this block emits, find blocks that receive it
  for (const emittedSignal of node.emits) {
    for (const dependent of graph.getReceiversOf(emittedSignal)) {
      if (!visited.has(dependent.blockUid)) {
        detectCyclesDFS(dependent, graph, visited, recursionStack, path, cycles);
      } else if (recursionStack.has(dependent.blockUid)) {
        // Found a cycle
        const cycleStart = path.indexOf(dependent.blockUid);
        cycles.push(path.slice(cycleStart).concat(dependent.blockUid));
      }
    }
  }

  path.pop();
  recursionStack.delete(node.blockUid);
}
```

**Validation Rule:**

If `detectSignalCycles(schema).hasCycles === true`, compilation MUST fail with error:

```typescript
interface SignalCycleError extends CompilationError {
  code: 'SIGNAL_CYCLE_DETECTED';
  message: string;
  cycles: SignalCycle[];
}

interface SignalCycle {
  path: string[];        // Block UIDs in cycle
  signals: string[];     // Signal names in cycle
  breakSuggestion: SignalBreakpoint[];
}

interface SignalBreakpoint {
  blockUid: string;
  signal: string;
  action: 'remove-emit' | 'remove-receive';
  reason: string;
}
```

**Error Message Example:**
```
Signal cycle detected:
  Block b_abc123 emits @filterA
  → Block b_def456 receives @filterA, emits @filterB
  → Block b_abc123 receives @filterB (CYCLE)

Suggestion: Remove either:
  - Block b_abc123 emission of @filterB, OR
  - Block b_def456 reception of @filterA
```

#### 10.8.2 Runtime Safety Net

Even with compile-time detection, the runtime MUST protect against cycles (defense in depth).

**Mechanism: Signal Generation Tracking**

```typescript
interface SignalRuntime {
  // ... existing methods ...

  // NEW: Generation-based propagation
  emit(signalName: string, value: any, sourceBlockUid: string): void;

  // Internal tracking
  private propagationDepth: Map<string, number>;
  private maxPropagationDepth: number = 10;  // Configurable
}

// Implementation
class SafeSignalRuntime implements SignalRuntime {
  private propagationDepth = new Map<string, number>();
  private maxPropagationDepth = 10;

  emit(signalName: string, value: any, sourceBlockUid: string): void {
    const depthKey = `${signalName}:${sourceBlockUid}`;
    const currentDepth = this.propagationDepth.get(depthKey) || 0;

    if (currentDepth >= this.maxPropagationDepth) {
      console.error(
        `Signal propagation depth limit exceeded for @${signalName} from ${sourceBlockUid}. ` +
        `Possible cycle detected. Halting propagation.`
      );
      return;  // Stop propagation, don't crash
    }

    this.propagationDepth.set(depthKey, currentDepth + 1);

    try {
      // Perform actual signal emission
      this.notifyReceivers(signalName, value);
    } finally {
      // Reset depth after propagation completes
      this.propagationDepth.set(depthKey, currentDepth);
    }
  }
}
```

**Fallback Behavior:**

When runtime detects excessive propagation depth:
1. Log error with cycle information
2. Stop further propagation
3. Render interface with last-known signal values
4. Display warning in development mode

**Production vs. Development:**
- **Development:** Throw visible error with cycle path
- **Production:** Log silently, halt propagation gracefully

#### 10.8.3 Signal Versioning (Alternative Approach)

For systems requiring more sophisticated cycle handling, implement signal generations:

```typescript
interface SignalValue<T> {
  value: T;
  generation: number;     // Increment on each emit
  timestamp: number;
  source: string;         // Block UID that emitted
}

interface SignalReception {
  signal: string;
  target: string;
  transform?: string;
  lastProcessedGeneration?: number;  // NEW: Track what we've seen
}

// Receivers only react to NEW generations
function shouldProcessSignal(
  reception: SignalReception,
  signalValue: SignalValue<any>
): boolean {
  const lastProcessed = reception.lastProcessedGeneration ?? -1;
  return signalValue.generation > lastProcessed;
}
```

This prevents re-processing the same signal value, breaking cycles naturally.

#### 10.8.4 Conformance Test Update

Update conformance test (§B.3.3) to be specific:

**Before:**
```typescript
'does not deadlock on circular signal reference',
```

**After:**
```typescript
// Compile-time detection
'rejects schema with circular signal dependencies at compile time',
'provides actionable error message with cycle path',
'suggests specific fixes to break cycle',

// Runtime protection
'halts signal propagation at depth limit without crashing',
'renders last-known values when cycle detected at runtime',
'logs cycle detection in development mode',
```

#### 10.8.5 LiquidCode Implications

Cycle detection is purely a compilation concern. No LiquidCode syntax changes needed.

However, error messages SHOULD reference LiquidCode syntax for clarity:

```
Error: Signal cycle detected in schema

Path:
  DF (date-filter) >@dateRange
  → T (data-table) <@dateRange >@rowSelect
  → DF (date-filter) <@rowSelect (CYCLE BACK TO START)

Suggested fix:
  Remove: DF emission of @rowSelect
  Or remove: T reception of @dateRange
```
```

---

### 2. Add Reference to Appendix B.5 (Coherence Gate)

Add a note in §B.5.3 (Signal Coherence) about cycle detection:

**Insert after line 2264 (in `checkSignalCoherence` function):**

```typescript
  // Check for circular dependencies
  const cycleCheck = detectSignalCycles(fragment);
  if (cycleCheck.hasCycles) {
    return {
      pass: false,
      confidence: 0,
      repairs: [],
      reason: `Signal cycle detected: ${cycleCheck.cycles[0].path.join(' → ')}`,
    };
  }
```

---

## Implementation Checklist

- [ ] Add §10.8 with cycle detection algorithm
- [ ] Add `detectSignalCycles()` to normative schema (§B.6.1)
- [ ] Update SignalRuntime interface with depth tracking
- [ ] Add SignalCycleError to error taxonomy (§19.1)
- [ ] Update conformance tests (§B.3.3)
- [ ] Add cycle detection to coherence gate (§B.5.3)
- [ ] Update hardening checklist (§B.7)

---

## Testing Strategy

### Test Cases

1. **Simple cycle (2 blocks):**
   ```liquidcode
   §sigA:custom
   §sigB:custom
   Block1<@sigA>@sigB
   Block2<@sigB>@sigA
   ```
   Expected: Compilation error with cycle path

2. **Transitive cycle (3 blocks):**
   ```liquidcode
   §sigA:custom
   §sigB:custom
   §sigC:custom
   Block1>@sigA
   Block2<@sigA>@sigB
   Block3<@sigB>@sigC
   Block1<@sigC  # Closes cycle
   ```
   Expected: Compilation error

3. **Self-loop:**
   ```liquidcode
   §signal:custom
   Block1<@signal>@signal
   ```
   Expected: Compilation error

4. **Valid signal flow (no cycle):**
   ```liquidcode
   §filter:filter
   DF>@filter
   K<@filter
   L<@filter
   T<@filter
   ```
   Expected: Pass validation

5. **Runtime depth limit:**
   - Mock a cycle that evades compile-time detection (bug in detector)
   - Verify runtime halts at depth 10
   - Verify no crash

---

## Migration Impact

**Breaking Change:** No

Schemas without cycles continue to work. Schemas with cycles (previously undefined behavior) now fail validation with clear error messages.

**Migration Path:** None needed for valid schemas.

**Adapter Impact:** Minimal. Adapters should update SignalRuntime implementation to include depth tracking for defense in depth.

---

## Cross-References

- §10.2: Signal Declaration
- §10.3: Signal Connections
- §B.3.1: Render Contract (never crash guarantee)
- §B.3.3: Conformance Test Suite
- §B.5.3: Signal Coherence
- §19.1: Error Categories

---

## Specification Diff

### New Section: §10.8

**Location:** After line 870 (end of §10.7)

**Insert:** Full content of §10.8 as specified above (~200 lines)

### Modified Section: §B.5.3

**Location:** Line 2264

**Change:** Add cycle check before signal coherence validation

### Modified Section: §B.3.3

**Location:** Line 2101

**Change:** Replace single conformance test with three specific tests

---

## Resolution Status

- [x] Problem analyzed
- [x] Solution designed
- [x] Specification content written
- [x] Cross-references identified
- [x] Test cases defined
- [ ] Approved for merge
- [ ] Applied to SPEC document

---

**Resolution Author:** Claude Opus 4.5
**Review Required:** Yes - Critical change affecting core safety guarantee
