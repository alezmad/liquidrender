# ISS-073: Render Guarantee Testability - Document B.3 Testing

**Issue Type:** Architectural Soundness (Minor)
**Severity:** Medium
**Section:** Appendix B.3
**Status:** Resolved

## Problem Statement

Appendix B.3 defines a render guarantee ("valid schemas render without crashing") but doesn't fully specify:
- How to test the guarantee across adapters
- What constitutes a "valid" placeholder vs render failure
- How to handle adapter timeout/hang scenarios
- Conformance test suite requirements

## Root Cause

B.3 establishes the contract but lacks executable test specifications and conformance validation.

## Resolution

Enhance **Appendix B.3** with complete conformance test suite and validation methodology:

---

### B.3.4 Conformance Test Suite Specification (ENHANCED)

#### Test Categories

The conformance suite consists of **5 categories** with **40 total tests**:

**Category 1: Block Rendering (15 tests)**

```typescript
describe('Block Rendering', () => {
  // Test 1-13: Core block types
  for (const blockType of CORE_BLOCK_TYPES) {
    test(`renders ${blockType} with valid data`, () => {
      const schema = createSchema({ type: blockType, binding: validBinding[blockType] });
      const result = adapter.render(schema, validData[blockType]);

      expect(result).toBeDefined();
      expect(result).not.toThrow();
      expect(isValidRenderOutput(result)).toBe(true);
    });
  }

  // Test 14: Unknown block type
  test('renders placeholder for unknown block type', () => {
    const schema = createSchema({ type: 'custom:unknown-widget' });
    const result = adapter.render(schema, {});

    expect(result).toBeDefined();
    expect(isPlaceholder(result)).toBe(true);
    expect(getPlaceholderReason(result)).toContain('unknown');
  });

  // Test 15: Block without required binding
  test('renders empty state for missing binding', () => {
    const schema = createSchema({ type: 'kpi', binding: null });
    const result = adapter.render(schema, {});

    expect(result).toBeDefined();
    expect(isEmptyState(result)).toBe(true);
  });
});
```

**Category 2: Error Handling (10 tests)**

```typescript
describe('Error Handling', () => {
  test('does not throw on malformed binding', () => {
    const schema = createSchema({
      type: 'kpi',
      binding: { fields: [{ target: 'invalid-slot', field: 'revenue' }] }
    });

    expect(() => adapter.render(schema, validData)).not.toThrow();
  });

  test('does not throw on invalid signal reference', () => {
    const schema = createSchema({
      signals: {},  // No signals declared
      blocks: [{
        type: 'kpi',
        signals: { receives: [{ signal: 'undeclared', target: 'value' }] }
      }]
    });

    expect(() => adapter.render(schema, validData)).not.toThrow();
  });

  test('completes within timeout for large data', async () => {
    const largeData = generateLargeDataset(10_000);  // 10K rows
    const schema = createSchema({ type: 'data-table', binding: tableBinding });

    const timeout = adapter.metadata.renderTimeout || 5000;
    const result = await Promise.race([
      adapter.render(schema, largeData),
      sleep(timeout).then(() => 'TIMEOUT'),
    ]);

    expect(result).not.toBe('TIMEOUT');
  });

  test('recovers from partial data fetch failure', () => {
    const partialData = { revenue: [1, 2, null, 4] };  // Null in data
    const schema = createSchema({ type: 'line-chart', binding: chartBinding });

    expect(() => adapter.render(schema, partialData)).not.toThrow();
  });

  test('handles null data gracefully', () => {
    const schema = createValidSchema();
    expect(() => adapter.render(schema, null)).not.toThrow();
  });

  test('handles empty data gracefully', () => {
    const schema = createValidSchema();
    expect(() => adapter.render(schema, {})).not.toThrow();
  });

  test('handles mismatched data shape', () => {
    const schema = createSchema({ type: 'bar-chart', binding: { fields: [{ target: 'x', field: 'category' }] } });
    const wrongData = { revenue: 100 };  // Expected category field

    expect(() => adapter.render(schema, wrongData)).not.toThrow();
  });

  test('handles circular references in data', () => {
    const circular: any = { a: 1 };
    circular.self = circular;

    const schema = createValidSchema();
    expect(() => adapter.render(schema, circular)).not.toThrow();
  });

  test('handles deeply nested data', () => {
    const deepData = createNestedObject(100);  // 100 levels deep
    const schema = createValidSchema();

    expect(() => adapter.render(schema, deepData)).not.toThrow();
  });

  test('handles unicode and special characters', () => {
    const unicodeData = { label: 'ðŸš€ Revenue (â‚¬)' };
    const schema = createValidSchema();

    expect(() => adapter.render(schema, unicodeData)).not.toThrow();
  });
});
```

**Category 3: Degradation (5 tests)**

```typescript
describe('Degradation', () => {
  test('shows placeholder with reason for unsupported features', () => {
    const schema = createSchema({
      type: 'kpi',
      customFeature: 'unsupported-by-adapter'  // Hypothetical unsupported feature
    });

    const result = adapter.render(schema, validData);
    if (isPlaceholder(result)) {
      expect(getPlaceholderReason(result)).toBeTruthy();
      expect(getPlaceholderReason(result).length).toBeGreaterThan(0);
    }
  });

  test('maintains layout when some blocks fail', () => {
    const schema = createSchema({
      type: 'grid',
      slots: {
        children: [
          createBlock({ type: 'kpi', binding: validBinding }),
          createBlock({ type: 'unknown-block' }),  // This will fail
          createBlock({ type: 'kpi', binding: validBinding }),
        ]
      }
    });

    const result = adapter.render(schema, validData);
    expect(result).toBeDefined();

    // Should render 2 KPIs + 1 placeholder, not crash entire grid
    const rendered = getRenderedBlocks(result);
    expect(rendered.length).toBe(3);
  });

  test('provides fallback for entire schema failure', () => {
    // Corrupt schema that passes validation but fails at render
    const corruptSchema = createCorruptButValidSchema();

    const result = adapter.render(corruptSchema, validData);
    expect(result).toBeDefined();
    expect(isFallbackTemplate(result)).toBe(true);
  });

  test('fallback includes error details', () => {
    const corruptSchema = createCorruptButValidSchema();
    const result = adapter.render(corruptSchema, validData);

    if (isFallbackTemplate(result)) {
      const error = getFallbackError(result);
      expect(error).toBeTruthy();
      expect(error.message).toBeTruthy();
    }
  });

  test('fallback allows retry mechanism', () => {
    const corruptSchema = createCorruptButValidSchema();
    const result = adapter.render(corruptSchema, validData);

    if (isFallbackTemplate(result)) {
      expect(hasRetryAction(result)).toBe(true);
    }
  });
});
```

**Category 4: Signals (5 tests)**

```typescript
describe('Signals', () => {
  test('handles signal with no subscribers', () => {
    const schema = createSchema({
      signals: { orphan: { type: 'selection', default: [] } },
      blocks: [createBlock({ type: 'kpi' })]  // No signal connections
    });

    expect(() => adapter.render(schema, validData)).not.toThrow();
  });

  test('handles signal emit during render', () => {
    const schema = createSchema({
      signals: { dateRange: { type: 'dateRange', default: '30d' } },
      blocks: [
        createBlock({ type: 'date-filter', signals: { emits: [{ signal: 'dateRange', trigger: 'onChange' }] } }),
        createBlock({ type: 'kpi', signals: { receives: [{ signal: 'dateRange', target: 'filter' }] } }),
      ]
    });

    expect(() => adapter.render(schema, validData)).not.toThrow();

    // Emit signal and verify no crash
    const runtime = adapter.createSignalRuntime(schema.signals);
    expect(() => runtime.set('dateRange', { start: new Date(), end: new Date() })).not.toThrow();
  });

  test('does not deadlock on circular signal reference', () => {
    // This should be caught by validation, but test adapter resilience
    const schema = createSchema({
      signals: { a: { type: 'custom' }, b: { type: 'custom' } },
      blocks: [
        createBlock({
          signals: {
            emits: [{ signal: 'a', trigger: 'onChange' }],
            receives: [{ signal: 'b', target: 'value' }]
          }
        }),
        createBlock({
          signals: {
            emits: [{ signal: 'b', trigger: 'onChange' }],
            receives: [{ signal: 'a', target: 'value' }]
          }
        }),
      ]
    });

    const renderPromise = Promise.resolve(adapter.render(schema, validData));
    const timeout = new Promise(resolve => setTimeout(() => resolve('TIMEOUT'), 1000));

    return Promise.race([renderPromise, timeout]).then(result => {
      expect(result).not.toBe('TIMEOUT');  // Should complete, not deadlock
    });
  });

  test('handles signal transform errors', () => {
    const schema = createSchema({
      signals: { value: { type: 'custom', validation: 'invalid LiquidExpr' } },
      blocks: [createBlock({ signals: { emits: [{ signal: 'value', trigger: 'onChange' }] } })],
    });

    expect(() => adapter.render(schema, validData)).not.toThrow();
  });

  test('persists and restores signals', () => {
    const schema = createSchema({
      signals: { dateRange: { type: 'dateRange', persist: 'url' } },
    });

    const runtime = adapter.createSignalRuntime(schema.signals);
    runtime.set('dateRange', { start: '2024-01-01', end: '2024-12-31' });
    runtime.persist();

    const newRuntime = adapter.createSignalRuntime(schema.signals);
    newRuntime.restore();

    expect(newRuntime.get('dateRange')).toEqual({ start: '2024-01-01', end: '2024-12-31' });
  });
});
```

**Category 5: Performance (5 tests)**

```typescript
describe('Performance', () => {
  test('renders within timeout', async () => {
    const schema = createValidSchema();
    const timeout = adapter.metadata.renderTimeout || 5000;

    const start = performance.now();
    await adapter.render(schema, validData);
    const elapsed = performance.now() - start;

    expect(elapsed).toBeLessThan(timeout);
  });

  test('handles 100 blocks without degradation', () => {
    const schema = createSchemaWithBlocks(100);
    expect(() => adapter.render(schema, validData)).not.toThrow();
  });

  test('handles 10,000 data rows efficiently', async () => {
    const largeData = generateLargeDataset(10_000);
    const schema = createSchema({ type: 'data-table' });

    const start = performance.now();
    await adapter.render(schema, largeData);
    const elapsed = performance.now() - start;

    expect(elapsed).toBeLessThan(10_000);  // <10s for 10K rows
  });

  test('does not leak memory on repeated renders', async () => {
    const schema = createValidSchema();

    const before = getMemoryUsage();

    for (let i = 0; i < 100; i++) {
      await adapter.render(schema, validData);
    }

    // Force GC if available
    if (global.gc) global.gc();

    const after = getMemoryUsage();
    const leak = after - before;

    expect(leak).toBeLessThan(10 * 1024 * 1024);  // <10MB leak for 100 renders
  });

  test('supports streaming render', async () => {
    if (!adapter.metadata.supportsStreaming) {
      return;  // Skip if adapter doesn't support streaming
    }

    const schema = createLargeSchema(50);
    const stream = adapter.renderStream(schema, validData);

    let chunks = 0;
    for await (const chunk of stream) {
      expect(chunk).toBeDefined();
      chunks++;
    }

    expect(chunks).toBeGreaterThan(1);  // Should emit multiple chunks
  });
});
```

### B.3.5 Validation Methodology (NEW)

**Running conformance tests:**

```bash
# Install conformance test suite
npm install @liquidcode/conformance-tests

# Run against adapter
npm test -- --adapter=./my-adapter

# Output:
# âœ… Block Rendering: 15/15 passed
# âœ… Error Handling: 10/10 passed
# âœ… Degradation: 5/5 passed
# âœ… Signals: 5/5 passed
# âœ… Performance: 5/5 passed
#
# ðŸŽ‰ Conformance: 40/40 tests passed (100%)
```

**Conformance levels:**

| Level | Tests Passed | Certification |
|-------|--------------|---------------|
| **Bronze** | 30-34 (75-85%) | Basic compatibility |
| **Silver** | 35-38 (87-95%) | Production-ready |
| **Gold** | 39-40 (97-100%) | Fully conformant |

**Minimum for production:** Silver (35+ tests)

### B.3.6 Test Data Fixtures (NEW)

**Standard test data:**

```typescript
// Provided by conformance suite
const TEST_FIXTURES = {
  // Valid data for each block type
  validData: {
    kpi: { revenue: 125000 },
    'bar-chart': {
      categories: ['Q1', 'Q2', 'Q3', 'Q4'],
      values: [100, 120, 115, 140]
    },
    'line-chart': {
      dates: ['2024-01-01', '2024-02-01', '2024-03-01'],
      values: [100, 120, 115]
    },
    // ... complete fixtures
  },

  // Edge cases
  edgeCases: {
    emptyArray: [],
    singleValue: [1],
    allNull: [null, null, null],
    mixedTypes: [1, 'two', null, true],
    unicode: 'ðŸš€ Ã‘oÃ±o',
    largeNumber: 9007199254740991,
    // ... complete edge cases
  },

  // Invalid data (should not crash)
  invalidData: {
    null: null,
    undefined: undefined,
    circular: (() => { const o: any = {}; o.self = o; return o; })(),
    malformed: { '[invalid-key': 'value' },
  },
};
```

### B.3.7 Adapter Certification Process (NEW)

**Step 1: Self-assessment**

```typescript
// Adapter declares capabilities
export const metadata: AdapterMetadata = {
  name: 'my-adapter',
  version: '1.0.0',
  platform: 'web',
  supportedSchemaVersions: ['2.0'],
  supportedBlockTypes: ['kpi', 'bar-chart', 'line-chart'],  // Subset OK
  supportsSignals: true,
  supportsStreaming: false,
  supportsLayout: true,
  renderTimeout: 3000,
};
```

**Step 2: Run conformance suite**

```bash
npm run conformance -- --adapter=./my-adapter --report=json > report.json
```

**Step 3: Review report**

```json
{
  "adapter": "my-adapter",
  "version": "1.0.0",
  "timestamp": "2024-12-21T00:00:00Z",
  "results": {
    "total": 40,
    "passed": 38,
    "failed": 2,
    "skipped": 0
  },
  "conformanceLevel": "Silver",
  "failures": [
    {
      "test": "handles deeply nested data",
      "category": "Error Handling",
      "error": "Maximum call stack size exceeded",
      "severity": "medium"
    },
    {
      "test": "supports streaming render",
      "category": "Performance",
      "error": "renderStream is not a function",
      "severity": "low"
    }
  ],
  "recommendations": [
    "Fix recursion depth handling in nested data",
    "Implement streaming API for large datasets (optional)"
  ]
}
```

**Step 4: Address failures**

Adapters must fix all **high severity** failures for Silver certification.

**Step 5: Submit for certification**

```bash
# Upload report to certification registry
npm run submit-certification -- --report=report.json
```

### B.3.8 Render Output Validation (NEW)

**What constitutes a valid render output?**

```typescript
// Adapter-specific, but must satisfy:
interface RenderOutputContract<T> {
  // Must be defined (not null/undefined)
  isDefined(output: T): boolean;

  // Must be valid instance of adapter's output type
  isValid(output: T): boolean;

  // Must complete within timeout
  completedWithinTimeout: boolean;

  // If placeholder, must have reason
  isPlaceholder?(output: T): boolean;
  getPlaceholderReason?(output: T): string;

  // If empty state, must be valid empty state
  isEmptyState?(output: T): boolean;

  // If fallback, must have error details
  isFallbackTemplate?(output: T): boolean;
  getFallbackError?(output: T): Error;
}
```

**React adapter example:**

```typescript
// React adapter output validation
function isValidRenderOutput(output: ReactElement): boolean {
  return (
    output !== null &&
    output !== undefined &&
    typeof output === 'object' &&
    '$$typeof' in output &&
    output.$$typeof === Symbol.for('react.element')
  );
}

function isPlaceholder(output: ReactElement): boolean {
  return output.type === PlaceholderComponent;
}

function getPlaceholderReason(output: ReactElement): string {
  return output.props.reason;
}
```

### B.3.9 Timeout Handling (NEW)

**Timeout detection:**

```typescript
async function renderWithTimeout<T>(
  adapter: LiquidAdapter<T>,
  schema: LiquidSchema,
  data: any
): Promise<T | TimeoutError> {
  const timeout = adapter.metadata.renderTimeout || 5000;

  return Promise.race([
    adapter.render(schema, data),
    new Promise<TimeoutError>((_, reject) =>
      setTimeout(() => reject(new TimeoutError(`Render exceeded ${timeout}ms`)), timeout)
    ),
  ]);
}
```

**Conformance test:**

```typescript
test('completes within timeout', async () => {
  const result = await renderWithTimeout(adapter, schema, data);

  expect(result).not.toBeInstanceOf(TimeoutError);
});
```

**Adapter responsibility:**

Adapters MUST either:
1. Complete render within `renderTimeout`, OR
2. Return a partial/placeholder result within timeout

Hanging forever is **never acceptable**.

### B.3.10 Continuous Conformance (NEW)

**Regression detection:**

```typescript
// Run conformance on every commit
// .github/workflows/conformance.yml
name: Conformance
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: npm install
      - run: npm run conformance
      - run: |
          if [ $(jq '.results.passed' report.json) -lt 35 ]; then
            echo "Conformance dropped below Silver level"
            exit 1
          fi
```

**Version compatibility:**

```typescript
// Test adapter against multiple schema versions
const SCHEMA_VERSIONS = ['1.0', '2.0'];

for (const version of SCHEMA_VERSIONS) {
  if (adapter.metadata.supportedSchemaVersions.includes(version)) {
    describe(`Schema v${version}`, () => {
      runConformanceTests(adapter, version);
    });
  }
}
```

---

## Validation

### Test Suite Completeness
- [x] 40 tests across 5 categories
- [x] All block types covered
- [x] Error scenarios covered
- [x] Performance tests included

### Certification Process
- [x] Three conformance levels defined (Bronze/Silver/Gold)
- [x] Minimum production threshold: Silver (35/40)
- [x] Self-assessment + automated testing

## Implementation Status

**Conformance suite deliverables:**

- [ ] Test suite npm package: `@liquidcode/conformance-tests`
- [ ] Test data fixtures
- [ ] CLI runner
- [ ] JSON report format
- [ ] Certification registry (optional)

**Timeline:** Q1 2025 (before v2.0 release)

## Impact

This resolution:
1. **Completes render guarantee** with executable tests
2. **Defines conformance levels** (Bronze/Silver/Gold)
3. **Provides certification process** for adapters
4. **Establishes continuous testing** for regression detection

**Document changes:**
- Enhance B.3.4 with complete 40-test suite
- Add B.3.5 Validation Methodology
- Add B.3.6 Test Data Fixtures
- Add B.3.7 Adapter Certification Process
- Add B.3.8 Render Output Validation
- Add B.3.9 Timeout Handling
- Add B.3.10 Continuous Conformance
