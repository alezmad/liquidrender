# ISS-127: Clear Separation of Concerns - Document Boundaries

**Issue Type:** Developer Experience
**Category:** Evidence
**Severity:** Medium
**Status:** Resolved

---

## Problem Statement

The spec describes many layers and components but doesn't always clarify:

1. **What decisions belong to which layer?** (Engine vs Adapter vs Application)
2. **Where is the trust boundary?** (What must the engine guarantee vs what adapters validate)
3. **What can implementations customize?** (Fixed spec vs extension points)
4. **How do concerns compose?** (LiquidCode vs LiquidSchema vs Adapter vs Data Layer)

Developers need clear boundaries to:
- Know where to implement features
- Avoid duplicating logic
- Understand security responsibilities
- Maintain clean architecture

---

## Resolution

### 1. Layer Responsibility Matrix

Add new section **§3.3 Separation of Concerns**:

```markdown
## 3.3 Separation of Concerns

The Liquid Engine architecture separates concerns across five distinct layers,
each with specific responsibilities and boundaries.

### 3.3.1 Responsibility Matrix

| Concern | Engine | Adapter | Application | Data Layer |
|---------|--------|---------|-------------|------------|
| **INTERFACE SEMANTICS** | | | | |
| What blocks exist | ✓ | | | |
| Block composition rules | ✓ | | | |
| Signal semantics | ✓ | | | |
| Layout constraints | ✓ | | | |
| Archetype detection | ✓ | | | |
| **RENDERING** | | | | |
| Visual appearance | | ✓ | | |
| Platform widgets | | ✓ | | |
| Styling | | ✓ | | |
| Animation/transitions | | ✓ | | |
| Accessibility | | ✓ | | |
| **DATA** | | | | |
| Schema introspection | | | | ✓ |
| Data fetching | | | ✓ | ✓ |
| Query execution | | | | ✓ |
| Caching (data) | | | | ✓ |
| Security/authorization | | | ✓ | ✓ |
| **STATE MANAGEMENT** | | | | |
| Digital twin | ✓ | | | |
| Operation history | ✓ | | | |
| Signal values | | ✓ | | |
| Signal persistence | | ✓ | | |
| **GENERATION** | | | | |
| LLM orchestration | ✓ | | | |
| Fragment caching | ✓ | | | |
| Coherence validation | ✓ | | | |
| Tier resolution | ✓ | | | |
| **COMPILATION** | | | | |
| LiquidCode parsing | ✓ | | | |
| Schema validation | ✓ | | | |
| Reference resolution | ✓ | | | |
| Type checking | ✓ | | | |
| **INTEGRATION** | | | | |
| User intent handling | | | ✓ | |
| Event handling | | | ✓ | |
| Routing/navigation | | | ✓ | |
| Error display | | | ✓ | |

**Legend:**
- ✓ = Primary responsibility
- (blank) = Not this layer's concern
```

### 2. Trust Boundaries

Add **§3.3.2 Trust Boundaries**:

```markdown
### 3.3.2 Trust Boundaries

```
┌────────────────────────────────────────────────────────────────┐
│                     APPLICATION LAYER                           │
│  • Untrusted user input                                        │
│  • Authentication/authorization                                │
│  • Business logic                                              │
└─────────────────────────┬──────────────────────────────────────┘
                          │ User Intent (string)
                          ↓
┌────────────────────────────────────────────────────────────────┐
│                   LIQUID ENGINE (CORE)                          │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ TRUST BOUNDARY: Input Validation                         │  │
│  │  • Sanitize user intent                                  │  │
│  │  • Validate selectors                                    │  │
│  │  • Check data fingerprints                               │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ SAFE ZONE: Engine Operations                             │  │
│  │  • All inputs validated                                  │  │
│  │  • LLM prompts sanitized                                 │  │
│  │  • Schemas guaranteed valid                              │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│                  LiquidSchema (validated)                       │
└─────────────────────────┬──────────────────────────────────────┘
                          │ Validated Schema
                          ↓
┌────────────────────────────────────────────────────────────────┐
│                      ADAPTER LAYER                              │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ TRUST BOUNDARY: Data Validation                          │  │
│  │  • Validate data shape matches binding                   │  │
│  │  • Sanitize for XSS (HTML escape)                        │  │
│  │  • Enforce security requirements                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ SAFE ZONE: Rendering                                     │  │
│  │  • Schema is valid (guaranteed by engine)                │  │
│  │  • Data is sanitized                                     │  │
│  │  • Can render safely                                     │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│                    Platform UI                                  │
└────────────────────────────────────────────────────────────────┘
```

**Key Principles:**

1. **Engine guarantees schema validity** — Adapters MUST NOT need to validate schema structure
2. **Adapters sanitize data** — Engine doesn't touch user data, adapters do
3. **Applications control data access** — Engine/adapter don't enforce row-level security
4. **Clear validation points** — Each layer validates its inputs once

**Example: Who validates what?**

| Input | Validator | Why |
|-------|-----------|-----|
| User intent string | Engine | Prevent prompt injection |
| Selector syntax | Engine | Ensure address resolution works |
| LiquidCode syntax | Engine | Compilation requires valid grammar |
| LiquidSchema structure | Engine | Must match normative types |
| Data shape | Adapter | Different data sources, runtime concern |
| HTML in data values | Adapter | Platform-specific escaping |
| User permissions | Application | Business logic, not engine concern |
```

### 3. Extension Points

Add **§3.3.3 Extension Points**:

```markdown
### 3.3.3 Extension Points

LiquidCode defines clear extension points where implementations can customize behavior.

#### FIXED (Cannot Customize):

| Component | Rationale |
|-----------|-----------|
| LiquidCode grammar | Cross-implementation compatibility |
| Core block types | Fragment cache would break |
| Signal types | Coordination requires shared types |
| Schema validation | Adapters rely on guarantees |
| UID format | Address resolution depends on it |
| Compilation semantics | Determinism required |

#### CONFIGURABLE (Parameters):

| Component | Extension | Example |
|-----------|-----------|---------|
| Token budgets | Adjust limits | `maxTokens: 100` |
| Cache TTL | Per-fragment | `ttl: 3600` |
| Performance budgets | Per-operation | `timeout: 200` |
| Breakpoint thresholds | Per-adapter | `compact: 500` |
| Coherence thresholds | Per-tier | `minConfidence: 0.85` |

#### EXTENSIBLE (Add new):

| Component | How to Extend | Constraints |
|-----------|---------------|-------------|
| Block types | `custom:my-block` | Adapters must support |
| Signal types | `custom` type | Adapter handles persistence |
| Archetypes | Add to discovery | Engine treats as opaque |
| Fragments | Cache new patterns | Must match existing schema |
| Transforms | Add LiquidExpr functions | Must be pure, total, sandboxed |
| Adapters | Implement interface | Must pass conformance tests |

**Example: Custom Block Type**

```typescript
// 1. Define in schema (allowed)
const schema: LiquidSchema = {
  blocks: [
    {
      uid: 'b_custom1',
      type: 'custom:heatmap',  // Extension via prefix
      binding: { /* ... */ },
    },
  ],
  // ...
};

// 2. Adapter must support (or render placeholder)
class MyAdapter implements LiquidAdapter<JSX.Element> {
  supports(type: BlockType): boolean {
    return type === 'custom:heatmap' || isStandardType(type);
  }

  renderBlock(block: Block, data: any): JSX.Element {
    if (block.type === 'custom:heatmap') {
      return <Heatmap data={data} />;
    }
    // ... standard blocks
  }
}

// 3. Fragment cache treats as opaque
// (Discovery engine won't suggest it, but can cache if used)
```

**Example: Custom LiquidExpr Function**

```typescript
// 1. Define function (must be pure, total, sandboxed)
const customFunctions = {
  slugify: (s: string) => s.toLowerCase().replace(/\s+/g, '-'),
  // ✓ Pure: same input → same output
  // ✓ Total: always returns, never throws
  // ✓ Sandboxed: no I/O, no state
};

// 2. Register with engine
engine.registerTransformFunction('slugify', customFunctions.slugify);

// 3. Use in binding
const binding: DataBinding = {
  fields: [
    { target: 'label', field: 'title', transform: 'slugify($title)' },
  ],
};
```
```

### 4. Layer Communication Contract

Add **§3.3.4 Layer Communication Contract**:

```markdown
### 3.3.4 Layer Communication Contract

Each layer communicates through well-defined interfaces. Layers MUST NOT bypass these contracts.

```
Application → Engine:
  ✓ engine.generate(intent, options)
  ✓ engine.mutate(mutation, target)
  ✓ engine.query(query)
  ✗ Direct access to fragment cache
  ✗ Direct LLM calls

Engine → Adapter:
  ✓ adapter.render(schema, data)
  ✓ adapter.calculateLayout(schema, context)
  ✗ Direct DOM manipulation
  ✗ Direct state management

Adapter → Data Layer:
  ✓ Via application-provided data parameter
  ✗ Direct database queries
  ✗ Direct API calls

Data Layer → Engine:
  ✓ Provide DataFingerprint for discovery
  ✗ Direct schema generation
  ✗ Direct fragment caching
```

**Violation Examples (WRONG):**

```typescript
// ❌ WRONG: Application bypassing engine validation
const schema = JSON.parse(userInput);  // Unchecked!
adapter.render(schema, data);  // Could crash

// ✓ CORRECT: Go through engine
const schema = await engine.compile(userInput);  // Validated
adapter.render(schema, data);  // Safe

// ❌ WRONG: Adapter calling LLM directly
class BadAdapter implements LiquidAdapter<JSX.Element> {
  async renderBlock(block: Block) {
    const label = await llm.complete(`Label for ${block.type}`);  // NO!
    return <div>{label}</div>;
  }
}

// ✓ CORRECT: Adapters render, don't generate
class GoodAdapter implements LiquidAdapter<JSX.Element> {
  renderBlock(block: Block) {
    const label = block.binding?.fields.find(f => f.target === 'label')?.field;
    return <div>{label}</div>;
  }
}

// ❌ WRONG: Engine directly querying database
async function generateFromData(db: Database) {
  const data = await db.query('SELECT * FROM sales');  // Engine shouldn't touch DB
  // ...
}

// ✓ CORRECT: Application provides fingerprint
async function generateFromData(db: Database) {
  const fingerprint = await createFingerprint(db);
  return engine.generate(intent, { fingerprint });
}
```
```

### 5. Architectural Decision Records

Add **§3.3.5 Why These Boundaries?**:

```markdown
### 3.3.5 Architectural Rationale

**Why Engine doesn't render?**
- Platform independence: Same schema renders on web, mobile, desktop
- Separation: Interface semantics != visual implementation
- Swappable: Change rendering without regenerating

**Why Adapter doesn't validate schema?**
- Performance: Validation once (at compile) vs every render
- Trust: Engine guarantees validity, adapter can assume it
- Complexity: Schema validation is complex, shouldn't duplicate

**Why Application controls data access?**
- Security: Row-level permissions are business logic
- Flexibility: Different auth systems, different rules
- Isolation: Engine doesn't know about users, tenants, permissions

**Why Engine doesn't cache data?**
- Lifetime: Interface schemas are long-lived, data is short-lived
- Complexity: Data caching has different invalidation rules
- Responsibility: Data layer already has caching (DB, CDN, etc.)

**Why Adapter handles signals?**
- Runtime: Signal values change during interaction (runtime)
- Platform: URL params (web) vs AsyncStorage (mobile)
- Reactivity: Platform-specific reactivity systems
```

---

## Testing Criteria

### Boundary Compliance Tests

1. **Layer Isolation:**
   - [ ] Engine doesn't import adapter code
   - [ ] Adapter doesn't import engine internals
   - [ ] Application doesn't import compiler internals

2. **Contract Validation:**
   - [ ] All engine→adapter calls go through interface
   - [ ] All application→engine calls use public API
   - [ ] No layer bypass detected

3. **Extension Point Validation:**
   - [ ] Custom block types work
   - [ ] Custom functions register correctly
   - [ ] Fixed components reject customization

4. **Responsibility Matrix:**
   - [ ] Each concern has exactly one owner
   - [ ] No duplicate validation
   - [ ] Clear escalation paths

---

## Migration Notes

**Impact:** Low - Clarifies existing architecture, no breaking changes
**Compatibility:** Fully backwards compatible

### For Implementers:

1. Review responsibility matrix against your implementation
2. Ensure trust boundaries are enforced (validation at right layer)
3. Use only documented extension points
4. Don't bypass layer communication contracts
5. Add tests for boundary violations

### For Users:

No changes required. Clearer documentation of what each layer does.

---

## References

- **§3.1** - System Overview
- **§17** - Compilation Pipeline (Engine responsibility)
- **§18** - Adapter Interface Contract (Adapter responsibility)
- **Appendix B.8** - Security Hardening (Trust boundaries)

---

## Resolution Summary

Documented clear separation of concerns:

1. **Responsibility Matrix** - What each layer owns
2. **Trust Boundaries** - Where validation happens
3. **Extension Points** - What can/cannot be customized
4. **Layer Communication Contract** - How layers interact
5. **Architectural Rationale** - Why these boundaries exist

Developers now have clear guidance on where to implement features and what each layer guarantees.
