# ISS-114: Schema Migration Strategy

**Issue Type:** Evolution Risk
**Category:** Extensibility and Evolution
**Priority:** Critical
**Affects:** Versioning & Migration (Section 20), All Schemas

---

## Problem Statement

LiquidCode v2 has minimal schema versioning support:
- Schema has a `version: "2.0"` field
- Adapters declare `supportedSchemaVersions: string[]`
- **No migration machinery exists**

This creates catastrophic problems when v3.0 is released:

### Failure Scenario

```typescript
// User loads a dashboard created in 2025
const v2Schema: LiquidSchema = loadDashboard('sales-2025.json');
// { version: "2.0", signals: { dateRange: { persist: 'url' } } }

// In 2027, LiquidCode v3.0 changes signal structure
// OLD: persist: 'url'
// NEW: storage: { type: 'url', ttl: undefined }

// What happens?
// Option A: Reject old schema
if (v2Schema.version !== '3.0') {
  throw new Error('Unsupported version');  // ❌ Dashboard is dead
}

// Option B: Try to render with undefined behavior
adapter.render(v2Schema, data);  // ❌ May crash or show wrong data
```

Without migration tooling:
1. **Breaking changes create hard forks** - v2 and v3 can't coexist
2. **Users lose their work** - Old dashboards become unusable
3. **System ossifies** - Fear of breaking changes prevents evolution
4. **Technical debt accumulates** - Workarounds pile up to maintain compatibility

### 5-Year Outlook

By 2030, users will have schemas created across 5+ years:
- v2.0 (2025), v2.5 (2026), v3.0 (2028), v4.0 (2030)
- Different companies stuck on different versions
- Community adapters supporting different schema versions
- Fragmented ecosystem

---

## Resolution

### Comprehensive Migration Infrastructure

Build migration machinery **before** v3.0 is released, enabling graceful evolution.

### Implementation

#### 1. Semantic Versioning Enforcement

```typescript
// Enforce semver in schema type
interface LiquidSchema {
  version: `${number}.${number}.${number}`;  // "2.0.0" not "2.0"

  // Optional: Feature flags for experimental features
  features?: {
    [featureName: string]: boolean;
  };
}

// Version parsing and comparison
class SchemaVersion {
  constructor(public major: number, public minor: number, public patch: number) {}

  static parse(version: string): SchemaVersion {
    const [major, minor, patch] = version.split('.').map(Number);
    return new SchemaVersion(major, minor, patch);
  }

  toString(): string {
    return `${this.major}.${this.minor}.${this.patch}`;
  }

  isCompatibleWith(other: SchemaVersion): boolean {
    // Same major = compatible (backward compatible minor/patch changes)
    return this.major === other.major;
  }

  isNewerThan(other: SchemaVersion): boolean {
    if (this.major !== other.major) return this.major > other.major;
    if (this.minor !== other.minor) return this.minor > other.minor;
    return this.patch > other.patch;
  }
}
```

#### 2. Migration Definition Interface

```typescript
interface SchemaMigration {
  // Version range
  from: string;                        // "2.0.0"
  to: string;                          // "3.0.0"

  // Migration function (pure, deterministic)
  migrate(schema: any): LiquidSchema;

  // Optional validation
  validate?(schema: any): ValidationResult;

  // Metadata
  changelog: string;                   // What changed
  breakingChanges: BreakingChange[];
  deprecations: Deprecation[];
  addedFeatures: string[];
}

interface BreakingChange {
  field: string;                       // e.g., 'signals.*.persist'
  reason: string;                      // Why it changed
  migration: string;                   // How to migrate
}

interface Deprecation {
  field: string;
  deprecatedIn: string;                // "3.0.0"
  removedIn: string;                   // "4.0.0"
  replacement: string;
  autoMigration?: boolean;
}
```

#### 3. Migration Registry

```typescript
class SchemaMigrationRegistry {
  private migrations: Map<string, SchemaMigration> = new Map();

  register(migration: SchemaMigration): void {
    const key = `${migration.from}->${migration.to}`;
    this.migrations.set(key, migration);
  }

  getMigration(from: string, to: string): SchemaMigration | null {
    return this.migrations.get(`${from}->${to}`) || null;
  }

  findMigrationPath(from: string, to: string): SchemaMigration[] | null {
    // Use Dijkstra's algorithm to find shortest path through version graph
    const fromVersion = SchemaVersion.parse(from);
    const toVersion = SchemaVersion.parse(to);

    if (fromVersion.major === toVersion.major) {
      // Within same major version - direct migration
      const direct = this.getMigration(from, to);
      if (direct) return [direct];

      // Try stepping through minor versions
      return this.findSteppingPath(fromVersion, toVersion);
    }

    // Cross major versions - chain migrations
    return this.findCrossVersionPath(fromVersion, toVersion);
  }

  private findSteppingPath(from: SchemaVersion, to: SchemaVersion): SchemaMigration[] {
    const path: SchemaMigration[] = [];
    let current = from;

    while (current.isNewerThan(to) === false && current.toString() !== to.toString()) {
      const next = new SchemaVersion(current.major, current.minor + 1, 0);
      const migration = this.getMigration(current.toString(), next.toString());

      if (!migration) return null;  // No path exists

      path.push(migration);
      current = next;
    }

    return path;
  }

  private findCrossVersionPath(from: SchemaVersion, to: SchemaVersion): SchemaMigration[] {
    // Find path from v2 → v3 → v4, etc.
    const path: SchemaMigration[] = [];
    let current = from.major;

    while (current < to.major) {
      const fromVer = `${current}.0.0`;
      const toVer = `${current + 1}.0.0`;
      const migration = this.getMigration(fromVer, toVer);

      if (!migration) return null;

      path.push(migration);
      current++;
    }

    return path;
  }
}
```

#### 4. Automatic Migration

```typescript
class SchemaEvolution {
  constructor(
    private registry: SchemaMigrationRegistry,
    private currentVersion: string = '2.0.0'
  ) {}

  migrate(schema: any, targetVersion?: string): LiquidSchema {
    const target = targetVersion || this.currentVersion;
    const from = schema.version || '1.0.0';

    if (from === target) {
      return schema;  // Already at target version
    }

    const path = this.registry.findMigrationPath(from, target);

    if (!path) {
      throw new MigrationError(
        `No migration path from ${from} to ${target}. ` +
        `Supported versions: ${this.getSupportedVersions().join(', ')}`
      );
    }

    // Apply migrations in sequence
    let current = schema;
    for (const migration of path) {
      console.log(`Migrating ${migration.from} → ${migration.to}`);
      current = migration.migrate(current);

      // Validate after each step
      if (migration.validate) {
        const result = migration.validate(current);
        if (!result.valid) {
          throw new MigrationError(
            `Migration ${migration.from} → ${migration.to} produced invalid schema: ` +
            result.errors.join(', ')
          );
        }
      }
    }

    return current;
  }

  canMigrate(from: string, to: string): boolean {
    return this.registry.findMigrationPath(from, to) !== null;
  }

  getSupportedVersions(): string[] {
    // Return all versions reachable from any starting point
    const versions = new Set<string>();
    for (const [key] of this.registry['migrations']) {
      const [from, to] = key.split('->');
      versions.add(from);
      versions.add(to);
    }
    return Array.from(versions).sort();
  }
}
```

#### 5. Example Migration: v2.0 → v3.0

```typescript
// Register v2 → v3 migration
registry.register({
  from: '2.0.0',
  to: '3.0.0',

  migrate: (schema: any): LiquidSchema => {
    const migrated = { ...schema, version: '3.0.0' };

    // Breaking change: signals.persist → signals.storage
    if (migrated.signals) {
      for (const [name, signal] of Object.entries(migrated.signals)) {
        if (signal.persist) {
          // Transform to new structure
          signal.storage = {
            type: signal.persist,
            ttl: signal.persist === 'session' ? 3600 : undefined,
            scope: 'user'  // New field, default value
          };
          delete signal.persist;
        }
      }
    }

    // Breaking change: layout.priority string → number
    const migrateLayout = (block: any) => {
      if (block.layout?.priority) {
        const priorityMap = {
          'hero': 1,
          'primary': 2,
          'secondary': 3,
          'detail': 4
        };
        const priority = block.layout.priority;
        if (typeof priority === 'string') {
          block.layout.priority = priorityMap[priority] || 2;
        }
      }

      // Recurse into slots
      if (block.slots) {
        for (const slot of Object.values(block.slots)) {
          if (Array.isArray(slot)) {
            slot.forEach(migrateLayout);
          }
        }
      }
    };

    migrated.blocks?.forEach(migrateLayout);

    return migrated;
  },

  validate: (schema: any): ValidationResult => {
    // Ensure no 'persist' fields remain
    const errors: string[] = [];

    if (schema.signals) {
      for (const [name, signal] of Object.entries(schema.signals)) {
        if ('persist' in signal) {
          errors.push(`Signal '${name}' still has 'persist' field after migration`);
        }
      }
    }

    return { valid: errors.length === 0, errors };
  },

  changelog: `
    - BREAKING: signals.*.persist → signals.*.storage (with TTL and scope)
    - BREAKING: layout.priority string → number (1-4)
    - ADDED: signals.*.storage.scope field
    - ADDED: signals.*.storage.ttl field
  `,

  breakingChanges: [
    {
      field: 'signals.*.persist',
      reason: 'Simple persist field insufficient for multi-scope, TTL-based storage',
      migration: 'Automatically migrated: persist:"url" → storage:{type:"url", scope:"user"}'
    },
    {
      field: 'layout.priority',
      reason: 'String values ambiguous, numeric ordering clearer',
      migration: 'Automatically migrated: "hero"→1, "primary"→2, "secondary"→3, "detail"→4'
    }
  ],

  deprecations: [],
  addedFeatures: ['signal-storage-ttl', 'signal-storage-scope']
});
```

#### 6. Deprecation Warnings

```typescript
interface DeprecationChecker {
  checkDeprecations(schema: LiquidSchema): DeprecationWarning[];
}

interface DeprecationWarning {
  field: string;
  currentValue: any;
  deprecatedIn: string;
  removedIn: string;
  replacement: string;
  autoMigration: boolean;
  severity: 'warning' | 'error';
}

class DeprecationChecker {
  constructor(private currentVersion: string) {}

  check(schema: LiquidSchema): DeprecationWarning[] {
    const warnings: DeprecationWarning[] = [];
    const version = SchemaVersion.parse(schema.version);
    const current = SchemaVersion.parse(this.currentVersion);

    // Example: Check for deprecated 'persist' in v3.x
    if (version.major >= 3 && version.minor < 9) {
      // In v3.0-3.8, 'persist' is deprecated but still works
      if (schema.signals) {
        for (const [name, signal] of Object.entries(schema.signals)) {
          if ('persist' in signal) {
            warnings.push({
              field: `signals.${name}.persist`,
              currentValue: signal.persist,
              deprecatedIn: '3.0.0',
              removedIn: '4.0.0',
              replacement: 'signals.*.storage',
              autoMigration: true,
              severity: 'warning'
            });
          }
        }
      }
    }

    return warnings;
  }
}
```

#### 7. Engine Integration

```typescript
class LiquidEngine {
  private evolution: SchemaEvolution;
  private deprecationChecker: DeprecationChecker;

  constructor(options: LiquidEngineOptions = {}) {
    const registry = new SchemaMigrationRegistry();
    this.registerCoreMigrations(registry);

    this.evolution = new SchemaEvolution(registry, CURRENT_VERSION);
    this.deprecationChecker = new DeprecationChecker(CURRENT_VERSION);
  }

  compile(
    liquidCode: string,
    options: CompileOptions = {}
  ): LiquidSchema {
    const rawSchema = this.parser.parse(liquidCode);

    // Auto-migrate if needed
    if (options.autoMigrate !== false) {
      const migrated = this.evolution.migrate(rawSchema);

      // Check for deprecations
      if (options.warnDeprecated !== false) {
        const warnings = this.deprecationChecker.check(migrated);
        if (warnings.length > 0) {
          console.warn('Schema uses deprecated features:');
          warnings.forEach(w => {
            console.warn(`  - ${w.field}: deprecated in ${w.deprecatedIn}, removed in ${w.removedIn}`);
            console.warn(`    Replace with: ${w.replacement}`);
          });
        }
      }

      return migrated;
    }

    return rawSchema;
  }

  loadSchema(
    schemaJson: string | object,
    options: LoadOptions = {}
  ): LiquidSchema {
    const schema = typeof schemaJson === 'string'
      ? JSON.parse(schemaJson)
      : schemaJson;

    // Auto-migrate on load
    if (options.autoMigrate !== false) {
      return this.evolution.migrate(schema, options.targetVersion);
    }

    return schema;
  }

  private registerCoreMigrations(registry: SchemaMigrationRegistry): void {
    // Register all known migrations
    // v2.0 → v3.0 (example above)
    // Future: v3.0 → v4.0, etc.
  }
}
```

---

## Migration Path

### Phase 1: Build Infrastructure (v2.1, ASAP)
- Implement migration registry and evolution system
- Add deprecation checker
- Create v2.0 → v2.1 example migration (no-op for testing)
- **Critical: Do this before v3.0 planning**

### Phase 2: Establish Process (v2.2-2.9)
- Document migration authoring guide
- Create migration test suite
- Establish deprecation policy (deprecate in vX.0, remove in vX+1.0)
- Build migration tooling (CLI for offline migration)

### Phase 3: First Major Migration (v3.0)
- Apply infrastructure to real breaking changes
- Test migration path on real user schemas
- Monitor migration success rate
- Iterate on tooling based on feedback

---

## Benefits

### User Benefits
- **Dashboards don't break** - Old schemas auto-migrate
- **Smooth upgrades** - Can upgrade LiquidCode version without fear
- **Clear warnings** - Deprecation notices give time to adapt

### Maintainer Benefits
- **Confident evolution** - Can make breaking changes when justified
- **Technical debt reduction** - Don't need workarounds for compatibility
- **Clear versioning contract** - Semantic versioning enforced

### Ecosystem Benefits
- **Adapter compatibility** - Clear version support matrix
- **Long-term stability** - 5+ year schema lifespan
- **Community trust** - Schemas are investments, not throwaway code

---

## Testing Requirements

```typescript
describe('Schema Migration', () => {
  it('migrates v2.0 schemas to v3.0', () => {
    const v2Schema = {
      version: '2.0.0',
      signals: {
        dateRange: { type: 'dateRange', persist: 'url' }
      }
    };

    const v3Schema = evolution.migrate(v2Schema, '3.0.0');

    expect(v3Schema.version).toBe('3.0.0');
    expect(v3Schema.signals.dateRange.persist).toBeUndefined();
    expect(v3Schema.signals.dateRange.storage).toEqual({
      type: 'url',
      ttl: undefined,
      scope: 'user'
    });
  });

  it('chains multiple migrations', () => {
    const v2Schema = { version: '2.0.0', /* ... */ };
    const v4Schema = evolution.migrate(v2Schema, '4.0.0');

    // Should apply: v2→v3, then v3→v4
    expect(v4Schema.version).toBe('4.0.0');
  });

  it('detects deprecated features', () => {
    const schema = {
      version: '3.0.0',
      signals: {
        test: { type: 'dateRange', persist: 'url' }  // Deprecated in v3
      }
    };

    const warnings = deprecationChecker.check(schema);
    expect(warnings).toHaveLength(1);
    expect(warnings[0].field).toBe('signals.test.persist');
    expect(warnings[0].removedIn).toBe('4.0.0');
  });
});
```

---

## Documentation Requirements

### Migration Authoring Guide

**Contents:**
1. When to create a migration
2. Writing migration functions (pure, deterministic)
3. Testing migrations
4. Documenting breaking changes
5. Deprecation policy
6. Versioning best practices

### User Migration Guide

**Contents:**
1. How auto-migration works
2. Checking for deprecations
3. Manual migration if needed
4. Version compatibility matrix
5. Rollback strategies

### CLI Tools Documentation

```bash
# Migrate schema file
liquidcode migrate schema.json --to 3.0.0 --output schema-v3.json

# Check for deprecations
liquidcode check schema.json --warn-deprecated

# Test migration dry-run
liquidcode migrate schema.json --to 3.0.0 --dry-run
```

---

## Implementation Checklist

- [ ] Define `SchemaMigration` interface
- [ ] Implement `SchemaMigrationRegistry`
- [ ] Implement `SchemaEvolution` with path finding
- [ ] Add semantic versioning enforcement
- [ ] Create deprecation checker
- [ ] Integrate auto-migration into engine
- [ ] Write migration test suite
- [ ] Create v2.0→v2.1 test migration
- [ ] Document migration authoring
- [ ] Build CLI migration tool
- [ ] Create version compatibility matrix

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** Critical (enables all future evolution)
**Breaking Changes:** None (infrastructure only, additive)
**Version Target:** v2.1 (URGENT)

**Rationale Integration:** This is the **most critical** resolution. Without migration infrastructure, LiquidCode will ossify and die. All other extensibility features depend on the ability to evolve the schema format. This must be built before v3.0 planning begins.

**Priority Justification:** Every day without this infrastructure makes future breaking changes more costly. If 10,000 schemas exist when we add migrations, that's fine. If 1,000,000 exist, that's a crisis.
