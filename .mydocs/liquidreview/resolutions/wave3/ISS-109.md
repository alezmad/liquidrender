# ISS-109: Explainability Metadata Bloat

**Category:** Minor Edge Cases
**Priority:** Low
**Status:** Resolved

## Issue

The `explainability` field in LiquidSchema can grow large if it includes full reasoning traces, source fragments, and decision logs. This bloats schema size and affects caching efficiency. What limits should apply?

## Resolution

### Explainability Levels

**Explainability is tiered based on context and user needs.**

```typescript
type ExplainabilityLevel = 'none' | 'minimal' | 'standard' | 'detailed';

interface SchemaExplainability {
  level: ExplainabilityLevel;
  source: 'cache' | 'semantic' | 'composition' | 'llm' | 'mutation';
  confidence: number;           // Always included (1 byte)

  // Conditional fields based on level
  reasoning?: string;           // standard+: max 200 chars
  sourceFragments?: string[];   // detailed only: max 5 fragments
  decisionLog?: DecisionNode[]; // detailed only: max depth 3
  coherenceScores?: CoherenceBreakdown; // detailed only
}

interface DecisionNode {
  step: string;                 // max 50 chars
  input: string;                // max 100 chars
  output: string;               // max 100 chars
  confidence: number;
}

interface CoherenceBreakdown {
  binding: number;
  signal: number;
  layout: number;
  data: number;
}
```

### Size Limits by Level

| Level | Max Size | Use Case |
|-------|----------|----------|
| `none` | 0 bytes | Production rendering (no overhead) |
| `minimal` | ~50 bytes | Source + confidence only |
| `standard` | ~300 bytes | + Brief reasoning (default for dev) |
| `detailed` | ~2KB | Full debugging (opt-in only) |

### Compilation Options

```typescript
interface CompileOptions {
  explainability?: ExplainabilityLevel;  // Default: 'minimal' in prod, 'standard' in dev
  includeSourceFragments?: boolean;      // Default: false
  includeDecisionLog?: boolean;          // Default: false
}

// Usage
engine.compile(liquidCode, {
  explainability: 'none'  // Minimal overhead for production
});

engine.compile(liquidCode, {
  explainability: 'detailed',        // For debugging
  includeSourceFragments: true,
  includeDecisionLog: true
});
```

### Field Truncation Rules

```typescript
function buildExplainability(
  level: ExplainabilityLevel,
  fullTrace: ExplainabilityTrace
): SchemaExplainability {
  const base = {
    level,
    source: fullTrace.source,
    confidence: fullTrace.confidence
  };

  if (level === 'none') return base;

  if (level === 'minimal') {
    return base;  // Just source + confidence
  }

  if (level === 'standard') {
    return {
      ...base,
      reasoning: truncate(fullTrace.reasoning, 200)  // Max 200 chars
    };
  }

  if (level === 'detailed') {
    return {
      ...base,
      reasoning: truncate(fullTrace.reasoning, 500),
      sourceFragments: fullTrace.sourceFragments.slice(0, 5),  // Max 5
      decisionLog: truncateLog(fullTrace.decisionLog, 3),      // Max depth 3
      coherenceScores: fullTrace.coherenceScores
    };
  }
}
```

### Caching Strategy

```typescript
// Cache schemas WITHOUT explainability metadata
interface CacheEntry {
  key: CacheKey;
  schema: Omit<LiquidSchema, 'explainability'>;  // Exclude for efficiency
  metadata: {
    source: 'cache' | 'semantic' | 'composition' | 'llm';
    confidence: number;
    timestamp: number;
  };

  // Explainability stored separately (optional)
  explainabilityRef?: string;  // Reference to full trace if needed
}

// Reconstruct with explainability on demand
function hydrateWithExplainability(
  schema: LiquidSchema,
  level: ExplainabilityLevel
): LiquidSchema {
  if (level === 'none') return schema;

  const trace = fetchExplainabilityTrace(schema.uid);
  return {
    ...schema,
    explainability: buildExplainability(level, trace)
  };
}
```

### Environment-Based Defaults

```typescript
const DEFAULT_EXPLAINABILITY_LEVEL: ExplainabilityLevel =
  process.env.NODE_ENV === 'production' ? 'none' : 'standard';
```

### Example

```typescript
// Production: no explainability overhead
const schema = engine.compile(code, { explainability: 'none' });
// schema.explainability is undefined

// Development: standard reasoning
const schema = engine.compile(code, { explainability: 'standard' });
// schema.explainability.reasoning: "Selected KPI for numeric field 'revenue'..."

// Debugging: full trace
const schema = engine.compile(code, {
  explainability: 'detailed',
  includeDecisionLog: true
});
// schema.explainability.decisionLog: [{ step: 'Archetype detection', ... }]
```

## Specification Impact

**Update §B.6.1 (LiquidSchema definition):**

Make `explainability` field conditional and add `ExplainabilityLevel` type.

**New section §16.5 (Explainability Management):**

Define levels, size limits, and caching strategy.

## Related Sections

- §16.4: Source Propagation
- §B.6.1: Complete Type Definitions
- §14.2: Fragment Storage Interface
