# ISS-133: Layout Resolution Algorithm Missing - Complete Layout Spec

**Issue Type:** Developer Experience
**Category:** Evidence
**Severity:** Medium
**Status:** Resolved

---

## Problem Statement

Section 11 (Layout & Responsiveness System) describes priority/flexibility/relationships but lacks:

1. **Layout resolution algorithm** - How to convert constraints → concrete dimensions
2. **Breakpoint detection** - How adapters determine current breakpoint
3. **Constraint solver** - How conflicting hints resolve
4. **Grid cell allocation** - Exact algorithm for grid layout
5. **Overflow handling** - What happens when blocks don't fit

---

## Resolution

### 1. Complete Layout Resolution Algorithm

Add to **§11.11 Responsive Transformation Rules**, new subsection **§11.16 Layout Resolution Algorithm**:

```typescript
/**
 * ═══════════════════════════════════════════════════════════════
 * LAYOUT RESOLUTION ALGORITHM
 * ═══════════════════════════════════════════════════════════════
 */

function resolveLayout(
  schema: LiquidSchema,
  context: SlotContext
): LayoutPlan {
  // 1. Determine breakpoint
  const breakpoint = determineBreakpoint(context.width, context.breakpointThresholds);

  // 2. Filter blocks by priority
  const visibleBlocks = filterByPriority(schema.blocks, breakpoint);

  // 3. Allocate grid cells
  const gridCells = allocateGridCells(
    schema.layout,
    visibleBlocks,
    context,
    breakpoint
  );

  // 4. Resolve dimensions
  const dimensionedCells = resolveDimensions(gridCells, context);

  // 5. Handle overflow
  const finalPlan = handleOverflow(dimensionedCells, context, breakpoint);

  return {
    breakpoint,
    visibleBlocks: finalPlan.visible.map(c => c.blockId),
    collapsedBlocks: finalPlan.collapsed.map(c => c.blockId),
    hiddenBlocks: finalPlan.hidden.map(c => c.blockId),
    grid: finalPlan.visible,
  };
}

// ─────────────────────────────────────────────────────────────────
// STEP 1: BREAKPOINT DETECTION
// ─────────────────────────────────────────────────────────────────

function determineBreakpoint(
  width: number,
  thresholds?: BreakpointThresholds
): Breakpoint {
  const defaults = {
    compact: 600,
    standard: 1200,
    expanded: Infinity,
  };

  const t = thresholds || defaults;

  if (width < t.compact) return 'compact';
  if (width < t.standard) return 'standard';
  return 'expanded';
}

// ─────────────────────────────────────────────────────────────────
// STEP 2: PRIORITY FILTERING
// ─────────────────────────────────────────────────────────────────

function filterByPriority(
  blocks: Block[],
  breakpoint: Breakpoint
): Block[] {
  // Priority thresholds by breakpoint
  const visiblePriorities: Record<Breakpoint, number[]> = {
    compact: [1],        // Only hero
    standard: [1, 2],    // Hero + primary
    expanded: [1, 2, 3, 4], // All
  };

  const allowed = visiblePriorities[breakpoint];

  return blocks.filter(block => {
    const priority = block.layout?.priority || 2; // Default: primary
    const level = typeof priority === 'number' ? priority : priorityToLevel(priority);
    return allowed.includes(level);
  });
}

function priorityToLevel(p: 'hero' | 'primary' | 'secondary' | 'detail'): number {
  const map = { hero: 1, primary: 2, secondary: 3, detail: 4 };
  return map[p];
}

// ─────────────────────────────────────────────────────────────────
// STEP 3: GRID CELL ALLOCATION
// ─────────────────────────────────────────────────────────────────

function allocateGridCells(
  layout: LayoutBlock,
  blocks: Block[],
  context: SlotContext,
  breakpoint: Breakpoint
): GridCell[] {
  if (layout.config.type !== 'grid') {
    // For non-grid layouts, create linear grid
    return allocateLinearGrid(blocks, context);
  }

  const config = layout.config as GridConfig;
  const cells: GridCell[] = [];

  // Adjust column count for breakpoint
  let columns = adjustColumnsForBreakpoint(config.columns, breakpoint);

  // Grid allocator state
  const grid: (string | null)[][] = Array(100).fill(null).map(() =>
    Array(columns).fill(null)
  );
  let nextRow = 0;
  let nextCol = 0;

  for (const block of blocks) {
    const span = block.layout?.span || { columns: 1, rows: 1 };

    // Convert span to numbers
    const colSpan = spanToNumber(span.columns, columns);
    const rowSpan = span.rows || 1;

    // Find next available position
    const pos = findNextPosition(grid, nextRow, nextCol, rowSpan, colSpan, columns);

    if (!pos) {
      // No space - overflow handling later
      continue;
    }

    // Mark grid cells as occupied
    for (let r = pos.row; r < pos.row + rowSpan; r++) {
      for (let c = pos.col; c < pos.col + colSpan; c++) {
        grid[r][c] = block.uid;
      }
    }

    cells.push({
      blockId: block.uid,
      row: pos.row,
      column: pos.col,
      rowSpan,
      colSpan,
      width: 0,  // To be resolved
      height: 'auto',
    });

    // Update next position
    nextCol = pos.col + colSpan;
    if (nextCol >= columns) {
      nextRow = pos.row + 1;
      nextCol = 0;
    }
  }

  return cells;
}

function spanToNumber(
  span: number | 'full' | 'half' | 'third' | 'quarter' | 'auto' | undefined,
  totalColumns: number
): number {
  if (typeof span === 'number') return span;

  switch (span) {
    case 'full': return totalColumns;
    case 'half': return Math.floor(totalColumns / 2);
    case 'third': return Math.floor(totalColumns / 3);
    case 'quarter': return Math.floor(totalColumns / 4);
    case 'auto': return 1;
    default: return 1;
  }
}

function findNextPosition(
  grid: (string | null)[][],
  startRow: number,
  startCol: number,
  rowSpan: number,
  colSpan: number,
  columns: number
): { row: number; col: number } | null {
  for (let r = startRow; r < grid.length; r++) {
    for (let c = (r === startRow ? startCol : 0); c < columns; c++) {
      if (canFit(grid, r, c, rowSpan, colSpan, columns)) {
        return { row: r, col: c };
      }
    }
  }
  return null;  // No space
}

function canFit(
  grid: (string | null)[][],
  row: number,
  col: number,
  rowSpan: number,
  colSpan: number,
  columns: number
): boolean {
  if (col + colSpan > columns) return false;
  if (row + rowSpan > grid.length) return false;

  for (let r = row; r < row + rowSpan; r++) {
    for (let c = col; c < col + colSpan; c++) {
      if (grid[r][c] !== null) return false;
    }
  }

  return true;
}

function adjustColumnsForBreakpoint(
  columns: number,
  breakpoint: Breakpoint
): number {
  switch (breakpoint) {
    case 'compact': return 1;  // Force single column
    case 'standard': return Math.min(columns, 2);  // Max 2 columns
    case 'expanded': return columns;  // Full grid
  }
}

// ─────────────────────────────────────────────────────────────────
// STEP 4: DIMENSION RESOLUTION
// ─────────────────────────────────────────────────────────────────

function resolveDimensions(
  cells: GridCell[],
  context: SlotContext
): GridCell[] {
  const columnWidth = context.width / Math.max(...cells.map(c => c.column + c.colSpan));

  return cells.map(cell => {
    const block = findBlock(cell.blockId);
    const intrinsic = getIntrinsicSize(block.type);

    // Width = column width × span
    let width = columnWidth * cell.colSpan;

    // Apply size hints
    if (block.layout?.size) {
      const min = block.layout.size.min;
      const max = block.layout.size.max;

      if (typeof min === 'number') width = Math.max(width, min);
      if (typeof max === 'number') width = Math.min(width, max);
    }

    // Apply flexibility
    const flex = block.layout?.flex || intrinsic.defaultFlex;

    if (flex === 'shrink' && width > intrinsic.idealWidth) {
      width = intrinsic.idealWidth;
    } else if (flex === 'fixed') {
      width = intrinsic.idealWidth;
    }

    // Height
    let height: number | 'auto' = 'auto';

    if (block.layout?.size?.aspect) {
      height = width / block.layout.size.aspect;
    } else if (flex === 'fixed' && intrinsic.idealHeight) {
      height = intrinsic.idealHeight;
    }

    return { ...cell, width, height };
  });
}

function getIntrinsicSize(blockType: BlockType): IntrinsicSize {
  // From §11.9
  const sizes: Record<string, IntrinsicSize> = {
    kpi: { minWidth: 100, idealWidth: 200, idealHeight: 80, defaultFlex: 'fixed' },
    'bar-chart': { minWidth: 200, idealWidth: 400, defaultFlex: 'shrink' },
    'line-chart': { minWidth: 250, idealWidth: 500, defaultFlex: 'shrink' },
    'pie-chart': { minWidth: 150, idealWidth: 300, defaultFlex: 'shrink' },
    'data-table': { minWidth: 300, idealWidth: Infinity, defaultFlex: 'grow' },
    // ... rest from spec
  };

  return sizes[blockType] || { minWidth: 100, idealWidth: 200, defaultFlex: 'shrink' };
}

interface IntrinsicSize {
  minWidth: number;
  idealWidth: number;
  idealHeight?: number;
  defaultFlex: 'fixed' | 'shrink' | 'grow' | 'collapse';
}

// ─────────────────────────────────────────────────────────────────
// STEP 5: OVERFLOW HANDLING
// ─────────────────────────────────────────────────────────────────

function handleOverflow(
  cells: GridCell[],
  context: SlotContext,
  breakpoint: Breakpoint
): { visible: GridCell[]; collapsed: GridCell[]; hidden: GridCell[] } {
  const visible: GridCell[] = [];
  const collapsed: GridCell[] = [];
  const hidden: GridCell[] = [];

  let totalHeight = 0;

  for (const cell of cells) {
    const block = findBlock(cell.blockId);

    // Check if fits
    if (cell.width < (block.layout?.size?.min || 0)) {
      // Too narrow - collapse or hide
      if (block.layout?.flex === 'collapse') {
        collapsed.push(cell);
      } else {
        hidden.push(cell);
      }
      continue;
    }

    // Check height constraint
    if (context.height !== 'auto') {
      const cellHeight = typeof cell.height === 'number' ? cell.height : 200;
      if (totalHeight + cellHeight > context.height) {
        // Overflow - collapse or hide based on priority
        const priority = priorityToLevel(block.layout?.priority || 'primary');
        if (priority >= 3) {
          collapsed.push(cell);
        } else {
          hidden.push(cell);
        }
        continue;
      }

      totalHeight += cellHeight;
    }

    visible.push(cell);
  }

  return { visible, collapsed, hidden };
}
```

### 2. Constraint Conflict Resolution

Add **§11.17 Constraint Resolution Rules**:

```markdown
## Constraint Resolution Rules

When layout hints conflict, apply in priority order:

1. **Explicit size constraints** (min/max) - MUST respect
2. **Breakpoint overrides** - Override defaults
3. **Priority** - Affects visibility, not size
4. **Flexibility** - Suggests behavior, not requirement
5. **Span** - Requested allocation
6. **Intrinsic sizes** - Fallback defaults

**Example conflicts:**

Conflict: Block has `fixed` flex but span is `full`
Resolution: Span wins (explicit), flex becomes `grow`

Conflict: Block min=400px but breakpoint=compact (max 390px)
Resolution: Min wins, block overflows (collapses or hides)

Conflict: Two blocks in same cell
Resolution: First in traversal order wins, second reflows

Conflict: Relationship group doesn't fit
Resolution: Stack vertically if height allows, else collapse group
```

---

## Resolution Summary

Complete layout algorithm:
1. **5-step resolution** - Breakpoint → Filter → Allocate → Dimension → Overflow
2. **Grid allocation algorithm** - Exact cell assignment
3. **Dimension calculation** - Width/height from constraints
4. **Overflow handling** - Collapse/hide based on priority & flex
5. **Conflict resolution** - Priority rules for contradictions
