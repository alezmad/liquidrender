# Resolution: ISS-087

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Data with Special Characters in Field Names
**Severity:** significant
**Target:** SPEC
**Section:** §6 LiquidCode Grammar, §9 Binding System

## Resolution

### Original Content
The specification uses field names in LiquidCode syntax (`$revenue`, `$category`) but does not define:
- Which characters are valid in field names
- How to escape or quote field names with spaces, symbols, or reserved characters
- Resolution rules for ambiguous field references

Partial references:
- §6.1: `$` prefix for binding fields
- §9.1: `field: string` (no character constraints)

### Replacement Content

**Add to §6.6 "Field Name Encoding" (new subsection after §6.5):**

```markdown
### 6.6 Field Name Encoding

LiquidCode must handle arbitrary field names from data sources, including those with special characters.

#### 6.6.1 Valid Unquoted Field Names

Field names matching this pattern can be used directly:

```regex
^[a-zA-Z_][a-zA-Z0-9_]*$
```

**Valid unquoted:**
- `$revenue` ✓
- `$user_id` ✓
- `$totalAmount` ✓
- `$_internal` ✓

**Invalid unquoted (require quoting):**
- `$total revenue` (space)
- `$user-id` (hyphen)
- `$revenue%` (special char)
- `$2023_revenue` (starts with number)

#### 6.6.2 Quoted Field Names

Field names with special characters MUST be quoted using one of two forms:

**Bracket notation:**
```liquidcode
$[field name with spaces]
$[user-id]
$[revenue%]
$[2023_revenue]
```

**String literal notation:**
```liquidcode
$"field name with spaces"
$"user-id"
$"revenue%"
$"2023_revenue"
```

Both forms are equivalent. Bracket notation is preferred for readability.

#### 6.6.3 Reserved Characters

These characters have special meaning and MUST be quoted:

| Character | Meaning | Example | Quoted Form |
|-----------|---------|---------|-------------|
| `,` | Delimiter | `$date,amount` | `$[date,amount]` if single field |
| `:` | Slot/modifier separator | `$revenue:sum` | `$[revenue:total]:sum` |
| `$` | Field prefix | N/A | Escape as `$$` |
| `@` | Address prefix | N/A | `$[@id]` |
| `#` | Archetype/ID prefix | N/A | `$[#tag]` |
| `*` | Wildcard | N/A | `$[all*]` |
| `[` `]` | Quoting delimiters | N/A | Escape as `\[` `\]` |
| `"` | String delimiter | N/A | Escape as `\"` |

#### 6.6.4 Escape Sequences

Within quoted field names, use escape sequences:

| Escape | Character | Example |
|--------|-----------|---------|
| `\\` | Backslash | `$[path\\to\\field]` |
| `\n` | Newline | `$[multi\nline]` |
| `\t` | Tab | `$[tab\tseparated]` |
| `\"` | Quote | `$["quoted"]` |
| `\[` | Open bracket | `$[array\[0\]]` |
| `\]` | Close bracket | `$[close\]]` |

#### 6.6.5 Normalization Rules

Field name matching follows these rules:

```typescript
function normalizeFieldName(raw: string): string {
  // 1. Trim whitespace
  let normalized = raw.trim();

  // 2. Lowercase for case-insensitive matching (see §6.6.6)
  normalized = normalized.toLowerCase();

  // 3. No other transformations (preserve symbols, spaces, etc.)
  return normalized;
}

function parseFieldReference(ref: string): string {
  // Unquoted: $fieldName
  if (/^\$[a-zA-Z_][a-zA-Z0-9_]*$/.test(ref)) {
    return ref.substring(1);  // Remove $
  }

  // Bracket quoted: $[field name]
  if (ref.startsWith('$[') && ref.endsWith(']')) {
    return unescapeBracket(ref.substring(2, ref.length - 1));
  }

  // String quoted: $"field name"
  if (ref.startsWith('$"') && ref.endsWith('"')) {
    return unescapeString(ref.substring(2, ref.length - 1));
  }

  throw new Error(`Invalid field reference: ${ref}`);
}
```

#### 6.6.6 Case Sensitivity

Field name matching is **case-insensitive** by default:

| Data Field | LiquidCode Reference | Match? |
|------------|---------------------|--------|
| `Revenue` | `$revenue` | ✓ Yes |
| `USER_ID` | `$user_id` | ✓ Yes |
| `TotalAmount` | `$totalamount` | ✓ Yes |

**Rationale:** Data sources use inconsistent casing (SQL uppercase, JSON camelCase, etc.). Case-insensitive matching reduces errors.

**Override:** For case-sensitive matching, use exact quoting:
```liquidcode
$"Revenue"    # Matches only "Revenue", not "revenue"
```

#### 6.6.7 Unicode Support

Field names MAY contain Unicode characters:

```liquidcode
$[收入]              # Chinese characters
$[montant_€]         # Euro symbol
$[température]       # Accented characters
```

**Normalization:** Unicode characters are preserved as-is. No case folding beyond ASCII.

#### 6.6.8 Maximum Field Name Length

Field names are limited to **256 characters** after normalization.

Longer names are truncated with a warning:
```
Warning: Field name truncated from 300 to 256 characters:
  "very_long_field_name_that_exceeds..."
```

#### 6.6.9 Ambiguous Field Name Matching

Covered in detail in §ISS-088 resolution. Summary:

1. Exact match (case-insensitive) preferred
2. If multiple matches, use disambiguation rules
3. Emit warning when ambiguity resolved automatically

#### 6.6.10 LiquidCode Examples

```liquidcode
# Simple fields (unquoted)
K$revenue
L$date$amount

# Fields with spaces (quoted)
K$[total revenue]
B$[product name]$[sales amount]

# Fields with symbols (quoted)
K$[revenue%]
L$[date/time]$[amount-usd]

# Fields starting with numbers (quoted)
K$[2023_revenue]
K$[1st_quarter_sales]

# Reserved characters (quoted)
K$[user:id]          # Colon would be parsed as slot separator
B$[a,b,c]$value      # Comma would be parsed as delimiter

# Mixed (unquoted + quoted)
L$date$[sales amount]
B$category$[revenue%]:sum

# Unicode
K$[收入]
L$date$[montant_€]
```

#### 6.6.11 Compilation to LiquidSchema

Quoted field names are preserved in schema:

```typescript
// LiquidCode
K$[total revenue]

// Compiles to LiquidSchema
{
  type: 'kpi',
  binding: {
    source: 'data',
    fields: [
      { target: 'value', field: 'total revenue' }  // Quotes removed
    ]
  }
}
```

The schema stores the **unquoted, normalized** field name.

#### 6.6.12 Data Source Field Discovery

When discovering fields from a data source:

```typescript
interface DataSourceField {
  name: string;              // Original field name from source
  normalizedName: string;    // Normalized for matching
  requiresQuoting: boolean;  // True if special chars present
  suggestedReference: string; // LiquidCode reference
}

function discoverFields(data: Record<string, any>[]): DataSourceField[] {
  const fields: DataSourceField[] = [];

  for (const key of Object.keys(data[0] || {})) {
    const normalized = normalizeFieldName(key);
    const requiresQuoting = !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key);

    fields.push({
      name: key,
      normalizedName: normalized,
      requiresQuoting,
      suggestedReference: requiresQuoting ? `$[${key}]` : `$${key}`,
    });
  }

  return fields;
}
```

#### 6.6.13 Error Messages

Clear error messages for invalid field references:

```typescript
// Error: Invalid character in unquoted field name
$total-revenue
// Message: "Field name 'total-revenue' contains '-' which requires quoting. Use: $[total-revenue]"

// Error: Missing closing bracket
$[revenue
// Message: "Unclosed bracket in field reference. Expected ']' after 'revenue'"

// Error: Field not found
$[unknown_field]
// Message: "Field 'unknown_field' not found in data source. Available fields: revenue, orders, date"
```

#### 6.6.14 Validation Schema

```typescript
const FieldReferencePattern = z.union([
  // Unquoted
  z.string().regex(/^\$[a-zA-Z_][a-zA-Z0-9_]*$/),

  // Bracket quoted
  z.string().regex(/^\$\[.+\]$/),

  // String quoted
  z.string().regex(/^\$".+"$/),
]);

function validateFieldReference(ref: string): boolean {
  return FieldReferencePattern.safeParse(ref).success;
}
```
```

**Add to §B.6.1 "Complete Type Definitions" (enhancement):**

```typescript
interface FieldBinding {
  target: BindingSlot;
  field: string;                         // Normalized field name (unquoted)
  transform?: string;
}

// Field name validation
const FieldNameSchema = z.string()
  .max(256, 'Field name too long (max 256 characters)')
  .refine(
    name => !name.includes('\0'),
    'Field name cannot contain null characters'
  );
```

## Verification Checklist
- [✓] Edge case fully specified (special characters, spaces, symbols, Unicode)
- [✓] Behavior deterministic (quoting rules, normalization, escape sequences)
- [✓] Error handling defined (clear error messages, validation)
- [✓] Examples provided (LiquidCode syntax, compilation, discovery)

## Confidence
**HIGH** - This resolution:
1. Defines clear quoting rules for field names with special characters
2. Provides two equivalent quoting syntaxes (bracket and string)
3. Specifies normalization and case-sensitivity rules
4. Includes escape sequences for reserved characters
5. Supports Unicode field names
6. Provides comprehensive examples and error messages
7. Integrates with field discovery and compilation pipeline
8. Includes validation schema and TypeScript types
