# Resolution: ISS-089

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Type Mismatches in Data
**Severity:** significant
**Target:** SPEC
**Section:** §9 Binding System, §12 Discovery Engine, §B.4 Safe Transform DSL

## Resolution

### Original Content
The specification infers field types and binds them to slots but does not specify:
- What happens when data types don't match expected schema
- Type coercion rules (string to number, date parsing, etc.)
- Error handling vs graceful degradation for type mismatches
- Runtime validation of data types

Partial references:
- §12.4: UOM primitive inference (detection only, not enforcement)
- §B.4: LiquidExpr handles type errors → returns `null`

### Replacement Content

**Add to §9.10 "Type System and Coercion" (new subsection after §9.9):**

```markdown
### 9.10 Type System and Coercion

LiquidCode uses a flexible type system that prioritizes graceful degradation over strict validation.

#### 9.10.1 Expected Types by Binding Slot

Each binding slot expects specific data types:

| Slot | Expected Type(s) | Fallback Types | Examples |
|------|-----------------|----------------|----------|
| **value** | number, currency | string (parse) | 1234, "1234", "$1,234" |
| **label** | string | any (toString) | "Product A", 123 |
| **x** (chart) | number, date, string | any | 2023-01-01, "Q1", 1 |
| **y** (chart) | number | string (parse) | 100, "100" |
| **category** | string | any (toString) | "North", 1, true |
| **color** | string (hex/name) | number (scale) | "#FF0000", "red", 5 |
| **date** | date, ISO string | number (timestamp) | "2023-01-01", 1672531200 |
| **boolean** | boolean | truthy/falsy | true, 1, "yes" |
| **data** (table) | array | any (wrap in array) | [{...}], {...} |
| **columns** (table) | string[] | object keys | ["name", "age"] |

#### 9.10.2 Type Coercion Rules

The engine attempts to coerce values to expected types:

```typescript
type CoercionRule = (value: unknown) => CoercionResult;

interface CoercionResult {
  success: boolean;
  value: unknown;
  originalType: string;
  targetType: string;
  method: string;           // How coercion was performed
  confidence: number;       // 0-1
}

const COERCION_RULES: Record<string, CoercionRule> = {
  toNumber: (value: unknown) => {
    // Direct number
    if (typeof value === 'number') {
      return { success: true, value, originalType: 'number', targetType: 'number', method: 'identity', confidence: 1.0 };
    }

    // String to number
    if (typeof value === 'string') {
      // Remove common formatting
      const cleaned = value.replace(/[$,\s]/g, '');
      const parsed = parseFloat(cleaned);

      if (!isNaN(parsed)) {
        return { success: true, value: parsed, originalType: 'string', targetType: 'number', method: 'parseFloat', confidence: 0.95 };
      }
    }

    // Boolean to number
    if (typeof value === 'boolean') {
      return { success: true, value: value ? 1 : 0, originalType: 'boolean', targetType: 'number', method: 'boolean-to-int', confidence: 0.8 };
    }

    // Date to timestamp
    if (value instanceof Date) {
      return { success: true, value: value.getTime(), originalType: 'date', targetType: 'number', method: 'timestamp', confidence: 0.9 };
    }

    return { success: false, value: null, originalType: typeof value, targetType: 'number', method: 'none', confidence: 0 };
  },

  toString: (value: unknown) => {
    if (value === null || value === undefined) {
      return { success: true, value: '', originalType: 'null', targetType: 'string', method: 'empty-string', confidence: 1.0 };
    }

    if (typeof value === 'string') {
      return { success: true, value, originalType: 'string', targetType: 'string', method: 'identity', confidence: 1.0 };
    }

    return { success: true, value: String(value), originalType: typeof value, targetType: 'string', method: 'String()', confidence: 0.95 };
  },

  toDate: (value: unknown) => {
    // Already a date
    if (value instanceof Date) {
      return { success: true, value, originalType: 'date', targetType: 'date', method: 'identity', confidence: 1.0 };
    }

    // ISO string
    if (typeof value === 'string') {
      const parsed = new Date(value);
      if (!isNaN(parsed.getTime())) {
        return { success: true, value: parsed, originalType: 'string', targetType: 'date', method: 'Date.parse', confidence: 0.95 };
      }
    }

    // Unix timestamp (number)
    if (typeof value === 'number') {
      const parsed = new Date(value);
      if (!isNaN(parsed.getTime())) {
        return { success: true, value: parsed, originalType: 'number', targetType: 'date', method: 'timestamp', confidence: 0.9 };
      }
    }

    return { success: false, value: null, originalType: typeof value, targetType: 'date', method: 'none', confidence: 0 };
  },

  toBoolean: (value: unknown) => {
    if (typeof value === 'boolean') {
      return { success: true, value, originalType: 'boolean', targetType: 'boolean', method: 'identity', confidence: 1.0 };
    }

    // Truthy string values
    if (typeof value === 'string') {
      const lower = value.toLowerCase().trim();
      if (['true', 'yes', '1', 'on'].includes(lower)) {
        return { success: true, value: true, originalType: 'string', targetType: 'boolean', method: 'truthy-string', confidence: 0.95 };
      }
      if (['false', 'no', '0', 'off', ''].includes(lower)) {
        return { success: true, value: false, originalType: 'string', targetType: 'boolean', method: 'falsy-string', confidence: 0.95 };
      }
    }

    // Number to boolean
    if (typeof value === 'number') {
      return { success: true, value: value !== 0, originalType: 'number', targetType: 'boolean', method: 'truthy-number', confidence: 0.8 };
    }

    // Fallback: JavaScript truthiness
    return { success: true, value: Boolean(value), originalType: typeof value, targetType: 'boolean', method: 'Boolean()', confidence: 0.7 };
  },

  toArray: (value: unknown) => {
    if (Array.isArray(value)) {
      return { success: true, value, originalType: 'array', targetType: 'array', method: 'identity', confidence: 1.0 };
    }

    // Wrap non-arrays
    return { success: true, value: [value], originalType: typeof value, targetType: 'array', method: 'wrap', confidence: 0.9 };
  },
};
```

#### 9.10.3 Type Validation and Coercion Pipeline

```typescript
interface TypedField {
  slot: BindingSlot;
  expectedType: DataType;
  value: unknown;
  coerced?: CoercionResult;
  error?: TypeError;
}

type DataType = 'number' | 'string' | 'date' | 'boolean' | 'array' | 'object' | 'any';

function validateAndCoerceField(
  slot: BindingSlot,
  value: unknown
): TypedField {
  const expectedType = SLOT_TYPE_MAP[slot];

  // Attempt coercion
  const coercion = COERCION_RULES[`to${capitalize(expectedType)}`]?.(value);

  if (coercion?.success) {
    return {
      slot,
      expectedType,
      value: coercion.value,
      coerced: coercion,
    };
  }

  // Coercion failed
  return {
    slot,
    expectedType,
    value: null,
    error: new TypeError(
      `Cannot coerce ${typeof value} to ${expectedType} for slot '${slot}'`
    ),
  };
}

const SLOT_TYPE_MAP: Record<BindingSlot, DataType> = {
  'value': 'number',
  'label': 'string',
  'x': 'any',           // Flexible for different chart types
  'y': 'number',
  'category': 'string',
  'series': 'string',
  'color': 'string',
  'stack': 'string',
  'trend': 'number',
  'icon': 'string',
  'compare': 'number',
  'current': 'number',
  'previous': 'number',
  'format': 'string',
  'data': 'array',
  'columns': 'array',
  'pageSize': 'number',
};
```

#### 9.10.4 Error Handling Strategies

When type coercion fails, use graduated fallback:

| Confidence | Action | User Experience |
|------------|--------|-----------------|
| **1.0** | Use value directly | Perfect render |
| **0.9-1.0** | Use coerced value | Normal render |
| **0.7-0.9** | Use coerced value + warning | Render with info icon |
| **< 0.7** | Use fallback value | Render placeholder |
| **0.0** | Skip field or show error | "Invalid data" message |

```typescript
interface FallbackStrategy {
  threshold: number;
  action: (field: TypedField) => RenderAction;
}

type RenderAction =
  | { type: 'render', value: unknown, warning?: string }
  | { type: 'placeholder', reason: string }
  | { type: 'skip' };

const FALLBACK_STRATEGIES: FallbackStrategy[] = [
  {
    threshold: 0.9,
    action: (field) => ({
      type: 'render',
      value: field.coerced!.value,
    }),
  },
  {
    threshold: 0.7,
    action: (field) => ({
      type: 'render',
      value: field.coerced!.value,
      warning: `Low confidence coercion: ${field.coerced!.method}`,
    }),
  },
  {
    threshold: 0.0,
    action: (field) => ({
      type: 'placeholder',
      reason: `Type mismatch: expected ${field.expectedType}, got ${typeof field.value}`,
    }),
  },
];
```

#### 9.10.5 Common Type Mismatch Scenarios

| Scenario | Expected | Actual | Coercion | Result |
|----------|----------|--------|----------|--------|
| **Number formatted as string** | number | "$1,234.56" | Parse → 1234.56 | ✓ Renders |
| **Date as string** | date | "2023-01-01" | Parse → Date | ✓ Renders |
| **Date as timestamp** | date | 1672531200000 | new Date() | ✓ Renders |
| **Boolean as number** | boolean | 1 | 1 → true | ✓ Renders |
| **Boolean as string** | boolean | "yes" | "yes" → true | ✓ Renders |
| **String as number** | number | "abc" | NaN → null | ✗ Placeholder |
| **Object as number** | number | {val: 5} | null | ✗ Placeholder |
| **Array as number** | number | [1,2,3] | null | ✗ Placeholder |
| **Non-array as array** | array | {...} | Wrap → [{...}] | ✓ Renders |

#### 9.10.6 Type Inference from Data

When binding types are not explicit, infer from data:

```typescript
function inferFieldType(values: unknown[]): DataType {
  // Check first 100 values for performance
  const sample = values.slice(0, 100);

  const types = sample.map(v => {
    if (v === null || v === undefined) return 'null';
    if (typeof v === 'number') return 'number';
    if (typeof v === 'boolean') return 'boolean';
    if (v instanceof Date) return 'date';
    if (Array.isArray(v)) return 'array';
    if (typeof v === 'object') return 'object';

    // String that might be date
    if (typeof v === 'string' && !isNaN(Date.parse(v))) return 'date';

    // String that might be number
    if (typeof v === 'string' && !isNaN(parseFloat(v.replace(/[$,\s]/g, '')))) return 'number';

    return 'string';
  });

  // Majority vote
  const typeCounts = types.reduce((acc, t) => {
    acc[t] = (acc[t] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  const majority = Object.entries(typeCounts)
    .sort((a, b) => b[1] - a[1])[0][0];

  return majority as DataType;
}
```

#### 9.10.7 Runtime Type Validation

```typescript
interface TypeValidationResult {
  valid: boolean;
  errors: TypeMismatch[];
  warnings: TypeWarning[];
  coercions: CoercionResult[];
}

interface TypeMismatch {
  field: string;
  slot: BindingSlot;
  expected: DataType;
  actual: string;
  sampleValue: unknown;
  canCoerce: boolean;
}

function validateBindingTypes(
  binding: DataBinding,
  data: unknown[]
): TypeValidationResult {
  const errors: TypeMismatch[] = [];
  const warnings: TypeWarning[] = [];
  const coercions: CoercionResult[] = [];

  for (const fieldBinding of binding.fields) {
    const values = data.map(row => row[fieldBinding.field]);
    const inferredType = inferFieldType(values);
    const expectedType = SLOT_TYPE_MAP[fieldBinding.target];

    if (inferredType !== expectedType) {
      // Attempt coercion
      const coercionRule = COERCION_RULES[`to${capitalize(expectedType)}`];
      const testCoercion = coercionRule?.(values[0]);

      if (testCoercion?.success) {
        coercions.push(testCoercion);

        if (testCoercion.confidence < 0.9) {
          warnings.push({
            field: fieldBinding.field,
            message: `Low confidence coercion: ${inferredType} → ${expectedType}`,
            confidence: testCoercion.confidence,
          });
        }
      } else {
        errors.push({
          field: fieldBinding.field,
          slot: fieldBinding.target,
          expected: expectedType,
          actual: inferredType,
          sampleValue: values[0],
          canCoerce: false,
        });
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    coercions,
  };
}
```

#### 9.10.8 Block-Specific Type Requirements

Different blocks have different type strictness:

| Block Type | Strictness | Behavior on Mismatch |
|------------|------------|---------------------|
| **kpi** | Medium | Attempts coercion, shows "—" if fails |
| **bar-chart** | Medium | Skips invalid categories, shows warning |
| **line-chart** | High | Requires numeric Y, shows placeholder if fail |
| **pie-chart** | Medium | Requires numeric values, skips invalid |
| **data-table** | Low | Shows values as-is (toString) |
| **comparison** | High | Requires two numbers, shows placeholder if fail |

#### 9.10.9 User-Facing Error Messages

```typescript
function formatTypeMismatchError(mismatch: TypeMismatch): string {
  return `
Type mismatch in field '${mismatch.field}':
  Expected: ${mismatch.expected}
  Actual: ${mismatch.actual}
  Sample value: ${JSON.stringify(mismatch.sampleValue)}

${mismatch.canCoerce
  ? '✓ Automatic coercion available'
  : '✗ Cannot coerce - data will be skipped'}

Suggestion: ${generateSuggestion(mismatch)}
  `.trim();
}

function generateSuggestion(mismatch: TypeMismatch): string {
  if (mismatch.expected === 'number' && mismatch.actual === 'string') {
    return 'Use transform to parse: transform="parseFloat($' + mismatch.field + ')"';
  }

  if (mismatch.expected === 'date' && mismatch.actual === 'string') {
    return 'Ensure dates are in ISO 8601 format or use transform';
  }

  return 'Check data source schema or use explicit transform';
}
```

#### 9.10.10 Transform Integration

Users can provide explicit transforms to handle mismatches:

```liquidcode
# Data has string-formatted numbers
K$revenue:transform="parseFloat($revenue.replace('$',''))"

# Data has date strings in custom format
L$date:transform="parseDate($date, 'MM/DD/YYYY')"$amount

# Data has boolean strings
K$active:transform='$active == "yes"'
```

Transforms use LiquidExpr (§B.4) for safety.

#### 9.10.11 Discovery Engine Type Hints

The discovery engine provides type hints:

```typescript
interface FieldTypeHint {
  field: string;
  inferredType: DataType;
  confidence: number;
  suggestedSlots: BindingSlot[];
  coercionAvailable: DataType[];
}

// Discovery suggests appropriate slots based on types
function suggestSlots(hint: FieldTypeHint): BindingSlot[] {
  const suggestions: BindingSlot[] = [];

  switch (hint.inferredType) {
    case 'number':
      suggestions.push('value', 'y', 'compare', 'current', 'previous');
      break;
    case 'date':
      suggestions.push('x');
      break;
    case 'string':
      suggestions.push('label', 'category', 'x');
      break;
    case 'boolean':
      suggestions.push('category');  // Convert to "Yes"/"No"
      break;
  }

  return suggestions;
}
```

#### 9.10.12 Conformance Tests

```typescript
const typeCoercionTests = [
  'coerces string-formatted number to number',
  'coerces ISO date string to Date',
  'coerces timestamp number to Date',
  'coerces boolean string "yes"/"no" to boolean',
  'wraps non-array value in array for table',
  'shows placeholder for uncoercible value',
  'emits warning for low-confidence coercion',
  'validates all bindings before render',
  'provides helpful error message on type mismatch',
  'suggests transform for common mismatches',
];
```
```

**Add to §B.3.2 "Adapter Conformance" (enhancement):**

```markdown
// Type handling (MUST)
'coerces common type mismatches gracefully',
'renders placeholder for uncoercible values',
'emits warnings for low-confidence coercions',
'validates data types before render',
'provides clear error messages for type mismatches',
```

## Verification Checklist
- [✓] Edge case fully specified (all common type mismatches)
- [✓] Behavior deterministic (coercion rules, fallback strategies)
- [✓] Error handling defined (confidence thresholds, warnings, placeholders)
- [✓] Examples provided (coercion scenarios, error messages, transforms)

## Confidence
**HIGH** - This resolution:
1. Defines comprehensive type coercion rules for common mismatches
2. Provides confidence-based fallback strategies
3. Specifies expected types for each binding slot
4. Includes type inference from data samples
5. Integrates with existing LiquidExpr transform system (§B.4)
6. Provides user-facing error messages with suggestions
7. Extends discovery engine with type hints
8. Includes comprehensive conformance tests
9. Balances strictness with graceful degradation
10. Handles edge cases like formatted numbers, date strings, boolean strings
