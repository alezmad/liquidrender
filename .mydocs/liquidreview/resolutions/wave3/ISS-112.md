# ISS-112: Signal Type Extensibility

**Issue Type:** Extension Gap
**Category:** Extensibility and Evolution
**Priority:** High
**Affects:** Signal System (Section 10)

---

## Problem Statement

LiquidCode v2 defines a fixed set of signal types:
- `dateRange`, `selection`, `filter`, `search`, `pagination`, `sort`, `toggle`, `custom`

The `custom` type is an untyped catch-all with no structure, validation, or serialization support. This prevents:

1. **Domain-specific signal types** with proper typing (e.g., medical `patientContext`, financial `portfolioSelection`)
2. **Value schema validation** to ensure signals carry correct data shapes
3. **Custom serialization** for complex types that need URL/session persistence
4. **Type safety** across the signal flow (emitter → registry → receiver)

### Example Failure

```typescript
// Current: Want to create a medical patient context signal
signals: {
  patientContext: {
    type: 'custom',  // Too vague - no schema!
    default: ???,    // What shape should this be?
    persist: 'session',
    validation: ???  // How to validate?
  }
}

// Receiver has no type information
<@patientContext→filter.patient  // What fields exist?
```

### 5-Year Outlook

Voice, gesture, AR/VR interfaces will require entirely new signal types (e.g., `voiceCommand`, `gesture`, `gaze`, `spatialAnchor`). Without extensibility, these become "custom" soup with no type safety.

---

## Resolution

### Extension Mechanism

Add a **Signal Type Registry** that allows defining custom signal types with full schema validation and serialization support.

### Implementation

#### 1. Signal Type Definition Interface

```typescript
interface SignalTypeDefinition {
  // Identification
  name: string;                        // e.g., 'patientContext'
  version: string;                     // Semver for type evolution

  // Type system
  valueSchema: z.ZodType;             // Zod schema for value validation
  defaultValue: unknown;              // Default if not provided

  // Serialization (for persistence)
  serialize?: (value: unknown) => string;
  deserialize?: (str: string) => unknown;

  // Validation
  validate?: (value: unknown) => boolean | ValidationError[];

  // Metadata
  description?: string;
  category?: 'temporal' | 'selection' | 'state' | 'filter' | 'custom';
  examples?: unknown[];
}
```

#### 2. Registration API

```typescript
interface SignalTypeRegistry {
  // Register new signal type
  register(definition: SignalTypeDefinition): void;

  // Get registered type
  get(name: string): SignalTypeDefinition | undefined;

  // Check if type exists
  has(name: string): boolean;

  // List all registered types
  list(): string[];

  // Unregister (for cleanup)
  unregister(name: string): void;
}

// Engine integration
const engine = new LiquidEngine();
engine.signals.registerType({...});
```

#### 3. Usage Example: Medical Domain

```typescript
// Register custom signal type
engine.signals.registerType({
  name: 'patientContext',
  version: '1.0.0',
  valueSchema: z.object({
    patientId: z.string().uuid(),
    encounterId: z.string().uuid().optional(),
    mrn: z.string(),
    dob: z.date(),
    facilityId: z.string()
  }),
  defaultValue: {
    patientId: '',
    mrn: '',
    dob: new Date(),
    facilityId: ''
  },
  serialize: (value) => JSON.stringify(value),
  deserialize: (str) => JSON.parse(str),
  validate: (value) => {
    // Additional business rules beyond schema
    const patient = value as PatientContext;
    if (!patient.patientId && !patient.mrn) {
      return [{ field: 'patientId', message: 'Either patientId or MRN required' }];
    }
    return true;
  },
  description: 'Patient demographic and visit context for medical interfaces',
  category: 'filter'
});

// Use in schema
const schema: LiquidSchema = {
  signals: {
    patient: {
      type: 'patientContext',  // Now fully typed!
      default: { patientId: '123', mrn: 'MRN-456', dob: new Date(), facilityId: 'FAC-1' },
      persist: 'url'
    }
  },
  blocks: [
    {
      type: 'custom:medical-chart',
      signals: {
        receives: [{
          signal: 'patient',
          target: 'filter.context'
        }]
      }
    }
  ]
};
```

#### 4. Core Signal Types as Built-in Registrations

Migrate existing built-in types to use the same registry system:

```typescript
// Engine initialization
class LiquidEngine {
  constructor() {
    this.signals = new SignalTypeRegistry();

    // Register core types
    this.registerCoreSignalTypes();
  }

  private registerCoreSignalTypes() {
    // dateRange
    this.signals.registerType({
      name: 'dateRange',
      version: '2.0.0',
      valueSchema: z.object({
        start: z.date(),
        end: z.date()
      }),
      defaultValue: {
        start: new Date(),
        end: new Date()
      },
      serialize: (v) => {
        const { start, end } = v as DateRange;
        return `${start.toISOString()},${end.toISOString()}`;
      },
      deserialize: (s) => {
        const [start, end] = s.split(',');
        return { start: new Date(start), end: new Date(end) };
      }
    });

    // selection
    this.signals.registerType({
      name: 'selection',
      version: '2.0.0',
      valueSchema: z.union([z.string(), z.array(z.string())]),
      defaultValue: [],
      serialize: (v) => Array.isArray(v) ? v.join(',') : v.toString(),
      deserialize: (s) => s.includes(',') ? s.split(',') : s
    });

    // ... other core types
  }
}
```

#### 5. Validation Integration

```typescript
// During schema compilation
function validateSignals(schema: LiquidSchema, registry: SignalTypeRegistry): ValidationResult {
  const errors: ValidationError[] = [];

  for (const [name, signal] of Object.entries(schema.signals || {})) {
    // Check type exists
    const typeDef = registry.get(signal.type);
    if (!typeDef) {
      errors.push({
        field: `signals.${name}.type`,
        message: `Unknown signal type: ${signal.type}. Register it via engine.signals.registerType()`
      });
      continue;
    }

    // Validate default value against schema
    if (signal.default !== undefined) {
      try {
        typeDef.valueSchema.parse(signal.default);
      } catch (e) {
        errors.push({
          field: `signals.${name}.default`,
          message: `Default value does not match type schema: ${e.message}`
        });
      }
    }

    // Run custom validation if provided
    if (typeDef.validate && signal.default !== undefined) {
      const result = typeDef.validate(signal.default);
      if (result !== true) {
        errors.push(...(Array.isArray(result) ? result : []));
      }
    }
  }

  return { valid: errors.length === 0, errors };
}
```

#### 6. LiquidCode Syntax Support

Maintain backward compatibility with existing syntax, add optional type annotations:

```liquidcode
# Current syntax (still works)
§dateRange:dr=30d,url

# Extended syntax with custom types (optional)
§patient:patientContext={patientId:"123"},session
§portfolio:portfolioSelection={accountIds:["A1","A2"]},url
```

Parser recognizes registered types and applies validation.

---

## Migration Path

### Phase 1: Add Registry (v2.1, Non-Breaking)
- Introduce `SignalTypeRegistry` interface
- Register existing types as built-ins
- All existing schemas continue to work

### Phase 2: Promote Usage (v2.2-2.5)
- Document custom signal type creation
- Publish domain packages (e.g., `@liquidcode/medical-signals`)
- Community adoption period

### Phase 3: Deprecate Untyped Custom (v3.0)
- Signal type `'custom'` deprecated (still works with warning)
- Encourage migration to typed custom signals
- All signals should have registered types

---

## Benefits

### Type Safety
- Compile-time validation of signal values
- Autocomplete in tooling (LSP support)
- Prevents runtime signal type errors

### Domain Extensibility
- Medical, financial, scientific domains can define proper types
- Type definitions ship as npm packages
- Ecosystem of typed signal libraries

### Future-Proofing
- Voice/gesture/AR signals can be proper types
- Multimodal LLM outputs can reference typed signals
- Migration between signal type versions possible

### Backward Compatibility
- Existing schemas unaffected
- `'custom'` type still available (though discouraged)
- Opt-in enhancement

---

## Examples

### Financial Domain

```typescript
engine.signals.registerType({
  name: 'portfolioSelection',
  version: '1.0.0',
  valueSchema: z.object({
    accountIds: z.array(z.string()),
    assetClasses: z.array(z.enum(['equity', 'fixed-income', 'alternative', 'cash'])).optional(),
    timeframe: z.enum(['1D', '1W', '1M', '3M', '1Y', 'YTD', 'All']).default('1M')
  }),
  defaultValue: { accountIds: [], timeframe: '1M' },
  serialize: (v) => JSON.stringify(v),
  deserialize: (s) => JSON.parse(s)
});
```

### Spatial/GIS Domain

```typescript
engine.signals.registerType({
  name: 'mapBounds',
  version: '1.0.0',
  valueSchema: z.object({
    north: z.number().min(-90).max(90),
    south: z.number().min(-90).max(90),
    east: z.number().min(-180).max(180),
    west: z.number().min(-180).max(180),
    zoom: z.number().min(0).max(22).optional()
  }),
  defaultValue: { north: 90, south: -90, east: 180, west: -180 },
  validate: (v) => {
    const bounds = v as MapBounds;
    if (bounds.north <= bounds.south) {
      return [{ field: 'bounds', message: 'North must be greater than south' }];
    }
    return true;
  }
});
```

---

## Testing Requirements

### Conformance Tests

```typescript
describe('Signal Type Registry', () => {
  it('registers custom signal types', () => {
    const registry = new SignalTypeRegistry();
    registry.register({ name: 'custom1', valueSchema: z.string(), defaultValue: '' });
    expect(registry.has('custom1')).toBe(true);
  });

  it('validates signal values against schema', () => {
    const schema = {
      signals: {
        test: {
          type: 'patientContext',
          default: { invalid: 'data' }  // Should fail validation
        }
      }
    };
    const result = validateSignals(schema, registry);
    expect(result.valid).toBe(false);
  });

  it('serializes and deserializes custom types', () => {
    const typeDef = registry.get('patientContext');
    const value = { patientId: '123', mrn: 'MRN-456' };
    const serialized = typeDef.serialize(value);
    const deserialized = typeDef.deserialize(serialized);
    expect(deserialized).toEqual(value);
  });
});
```

---

## Documentation Requirements

### Developer Guide Section

**Title:** "Custom Signal Types"

**Contents:**
1. When to create custom signal types
2. Registration API reference
3. Schema definition with Zod
4. Serialization strategies
5. Validation patterns
6. Domain package examples
7. Migration from `'custom'` type

### API Reference

Add to engine documentation:
- `LiquidEngine.signals.registerType()`
- `SignalTypeDefinition` interface
- Built-in signal type definitions

---

## Implementation Checklist

- [ ] Define `SignalTypeDefinition` interface
- [ ] Implement `SignalTypeRegistry` class
- [ ] Add registration API to `LiquidEngine`
- [ ] Migrate core signal types to registry
- [ ] Update schema validation to check registry
- [ ] Add serialization/deserialization support
- [ ] Extend LiquidCode parser for type annotations
- [ ] Write conformance tests
- [ ] Document custom signal type creation
- [ ] Create example domain packages

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** Medium (adds new API, existing schemas unchanged)
**Breaking Changes:** None (additive feature)
**Version Target:** v2.1

**Rationale Integration:** This mechanism enables the domain-specific extensibility that LiquidCode's platform-agnostic philosophy requires. Type safety prevents the "custom soup" anti-pattern while maintaining flexibility.
