# Resolution: ISS-079 - LiquidExpr Resource Exhaustion

**Issue ID:** ISS-079
**Severity:** Critical
**Target Document:** `.mydocs/liquidcode/LIQUIDCODE-SPEC-v2.md`
**Review Source:** 08-edge-cases-failure-modes.md (Failure 4)
**Date:** 2025-12-21

---

## Problem Statement

**Current State:** LiquidExpr (§B.4) lacks precise resource limits, allowing expressions to cause stack overflow, heap exhaustion, or infinite evaluation.

**Trigger Examples:**
```liquidcode
# Deep nesting
transform: "substr(substr(substr(...1000 times..., 0, 1), 0, 1), 0, 1)"

# Array operations on large data
transform: "sum(sum(sum(...nested 100 times...)))"

# Large intermediate results
transform: "concat(concat(concat(...10000 times..., 'x'), 'x'), 'x')"
```

**Impact:**
- Stack overflow in expression evaluator
- Heap exhaustion from intermediate results
- Exceeds 1000-operation bound (§B.4.6) if bound not enforced correctly
- Crashes adapter rendering process
- **CRITICAL:** Violates "never crash host runtime" guarantee (§B.3.1)

**Current Handling:**
- §B.4.6: "Execution time bounded (max 1000 operations)" but:
  - What counts as an "operation"? Function call? AST node? Binary operator?
  - How is limit enforced? Counter? Timeout?
  - What happens at limit? Return null? Throw?
  - No stack depth limit specified
  - No result size limit specified

---

## Resolution

### 1. Add Resource Limits to §B.4.6 (Expand Subsection)

Replace §B.4.6 (Security Properties) with detailed resource specification:

```markdown
### B.4.6 Resource Limits and Security

LiquidExpr MUST enforce strict resource limits to prevent denial-of-service and ensure safe execution in untrusted contexts.

#### B.4.6.1 Operation Counting

**Definition:** An "operation" is any single atomic action during evaluation.

| Expression Element | Operation Count |
|-------------------|-----------------|
| Literal | 1 (constant evaluation) |
| Identifier (field access) | 1 |
| Binary operator | 1 |
| Function call | 1 + count(args) |
| Conditional (ternary) | 1 + count(branches evaluated) |
| Array access | 1 per element accessed |
| Property access | 1 |

**Examples:**

```typescript
// Operation counting examples
"5 + 3"                           // 3 ops: literal(5) + operator + literal(3)
"$revenue * 0.1"                  // 3 ops: field access + operator + literal
"round($revenue)"                 // 2 ops: field access + function call
"round($revenue) + round($cost)"  // 6 ops: 2 fields + 2 functions + 2 ops + 1 binary
"sum([1,2,3,4,5])"               // 7 ops: 5 literals + array + function

// Nested example
"upper(concat($firstName, ' ', $lastName))"
// 6 ops:
//   - $firstName: 1
//   - literal(' '): 1
//   - $lastName: 1
//   - concat(...): 1 (function) + 3 (args) = 4
//   - upper(...): 1
//   Total: 6
```

**Enforcement:**

```typescript
interface EvaluationContext {
  data: Record<string, any>;
  operationCount: number;
  maxOperations: number;
  aborted: boolean;
}

function evaluateExpression(
  expr: Expr,
  context: EvaluationContext
): any {
  // Check limit before each operation
  if (context.operationCount >= context.maxOperations) {
    context.aborted = true;
    return null;  // Graceful fallback
  }

  context.operationCount++;

  // Evaluate based on expression type
  switch (expr.type) {
    case 'literal':
      return expr.value;

    case 'identifier':
      return context.data[expr.name] ?? null;

    case 'binary':
      const left = evaluateExpression(expr.left, context);
      if (context.aborted) return null;

      const right = evaluateExpression(expr.right, context);
      if (context.aborted) return null;

      return applyBinaryOp(expr.operator, left, right);

    case 'call':
      const args = expr.args.map(arg => {
        const val = evaluateExpression(arg, context);
        if (context.aborted) return null;
        return val;
      });
      if (context.aborted) return null;

      return callBuiltinFunction(expr.name, args, context);

    // ... other cases
  }
}
```

#### B.4.6.2 Stack Depth Limit

**Limit:** Maximum 50 nested function calls

**Rationale:** Prevents stack overflow while allowing reasonable expression complexity.

```typescript
interface EvaluationContext {
  // ... existing fields ...
  callDepth: number;
  maxCallDepth: number;  // Default: 50
}

function callBuiltinFunction(
  name: string,
  args: any[],
  context: EvaluationContext
): any {
  // Check depth limit
  if (context.callDepth >= context.maxCallDepth) {
    console.error(`LiquidExpr: Max call depth (${context.maxCallDepth}) exceeded`);
    return null;
  }

  context.callDepth++;

  try {
    const result = BUILTIN_FUNCTIONS[name]?.(args, context) ?? null;
    return result;
  } finally {
    context.callDepth--;
  }
}
```

**Example triggering limit:**

```typescript
// This would exceed depth limit:
transform: "upper(upper(upper(...55 nested upper()...)))"
// At depth 51, returns null
```

#### B.4.6.3 Result Size Limit

**Limit:** Maximum 1 MB for intermediate and final results

**Rationale:** Prevents heap exhaustion from string concatenation or large array operations.

```typescript
interface EvaluationContext {
  // ... existing fields ...
  resultSize: number;        // Bytes allocated
  maxResultSize: number;     // Default: 1MB = 1048576 bytes
}

function checkResultSize(value: any, context: EvaluationContext): boolean {
  const size = estimateSize(value);

  if (context.resultSize + size > context.maxResultSize) {
    console.error(
      `LiquidExpr: Result size limit (${context.maxResultSize} bytes) exceeded`
    );
    return false;
  }

  context.resultSize += size;
  return true;
}

function estimateSize(value: any): number {
  if (value === null || value === undefined) return 0;

  switch (typeof value) {
    case 'number':
    case 'boolean':
      return 8;  // 64-bit value

    case 'string':
      return value.length * 2;  // UTF-16 encoding

    case 'object':
      if (Array.isArray(value)) {
        return value.reduce((sum, item) => sum + estimateSize(item), 0);
      }
      return Object.entries(value).reduce(
        (sum, [key, val]) => sum + key.length * 2 + estimateSize(val),
        0
      );

    default:
      return 0;
  }
}

// Apply to string operations
function builtinConcat(args: any[], context: EvaluationContext): string | null {
  const result = args.map(a => String(a ?? '')).join('');

  if (!checkResultSize(result, context)) {
    return null;  // Size limit exceeded
  }

  return result;
}
```

**Example triggering limit:**

```typescript
// This would exceed size limit:
transform: "concat(concat(concat(...100000 nested 'x'...), 'x'), 'x')"
// After ~524,288 chars (1MB), returns null
```

#### B.4.6.4 Execution Time Limit

**Limit:** Maximum 100ms per expression evaluation

**Rationale:** Prevent runaway evaluation even if operation count is somehow bypassed.

```typescript
interface EvaluationContext {
  // ... existing fields ...
  startTime: number;
  maxExecutionTime: number;  // Default: 100ms
}

function evaluateExpression(
  expr: Expr,
  context: EvaluationContext
): any {
  // Check time limit periodically (every 10 operations)
  if (context.operationCount % 10 === 0) {
    const elapsed = Date.now() - context.startTime;
    if (elapsed > context.maxExecutionTime) {
      console.error(`LiquidExpr: Execution time limit (${context.maxExecutionTime}ms) exceeded`);
      context.aborted = true;
      return null;
    }
  }

  // ... rest of evaluation
}
```

#### B.4.6.5 Array Operation Limits

**Limits:**
- Maximum array size: 10,000 elements
- Maximum iterations in aggregate functions: 10,000

```typescript
function builtinSum(args: any[], context: EvaluationContext): number | null {
  const arr = args[0];

  if (!Array.isArray(arr)) {
    return null;
  }

  if (arr.length > 10000) {
    console.error('LiquidExpr: Array size limit (10,000) exceeded in sum()');
    return null;
  }

  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    // Count each iteration as operation
    context.operationCount++;
    if (context.operationCount >= context.maxOperations) {
      context.aborted = true;
      return null;
    }

    const val = Number(arr[i]);
    sum += isNaN(val) ? 0 : val;
  }

  return sum;
}
```

#### B.4.6.6 Default Resource Configuration

```typescript
const DEFAULT_LIQUIDEXPR_LIMITS: ResourceLimits = {
  maxOperations: 1000,         // Maximum operation count
  maxCallDepth: 50,            // Maximum nested calls
  maxResultSize: 1048576,      // 1 MB result size
  maxExecutionTime: 100,       // 100ms timeout
  maxArraySize: 10000,         // Maximum array length
};

interface ResourceLimits {
  maxOperations: number;
  maxCallDepth: number;
  maxResultSize: number;       // bytes
  maxExecutionTime: number;    // milliseconds
  maxArraySize: number;
}
```

**Adapter Configuration:**

Adapters MAY customize limits, but MUST NOT exceed safe defaults:

```typescript
interface LiquidAdapter<T> {
  // ... existing methods ...

  // NEW: Adapter can customize expression limits
  readonly liquidExprLimits?: Partial<ResourceLimits>;
}

// Example usage
const adapter = new ReactAdapter({
  liquidExprLimits: {
    maxOperations: 500,      // Stricter for production
    maxExecutionTime: 50,    // Stricter for low-latency
  },
});
```

#### B.4.6.7 Security Properties

With resource limits enforced:

- **No code execution:** Only predefined functions, no eval()
- **No external access:** No access to window, process, filesystem, network
- **Bounded execution:** All limits enforced, guaranteed termination
- **Memory safe:** Result size bounded, no heap exhaustion
- **Stack safe:** Call depth bounded, no stack overflow
- **Deterministic:** Same input → same output (no randomness, no time-dependent behavior except timeout)

#### B.4.6.8 Error Handling on Limit Exceeded

When any resource limit is exceeded:

1. **Log error** (development mode only):
   ```
   LiquidExpr resource limit exceeded:
     Expression: concat(concat(...))
     Limit: maxResultSize (1048576 bytes)
     Context: Block b_abc123, field 'label'
   ```

2. **Return null** (graceful degradation)

3. **Set aborted flag** to prevent further evaluation

4. **Do NOT throw** (prevents cascade failures)

**Production behavior:**

```typescript
function evaluateSafe(
  expr: string,
  data: any,
  limits: ResourceLimits = DEFAULT_LIQUIDEXPR_LIMITS
): any {
  try {
    const ast = parseLiquidExpr(expr);
    const context: EvaluationContext = {
      data,
      operationCount: 0,
      maxOperations: limits.maxOperations,
      callDepth: 0,
      maxCallDepth: limits.maxCallDepth,
      resultSize: 0,
      maxResultSize: limits.maxResultSize,
      startTime: Date.now(),
      maxExecutionTime: limits.maxExecutionTime,
      aborted: false,
    };

    const result = evaluateExpression(ast, context);

    if (context.aborted) {
      // Log in development, silent in production
      if (process.env.NODE_ENV === 'development') {
        console.warn('LiquidExpr evaluation aborted due to resource limits');
      }
      return null;
    }

    return result;
  } catch (error) {
    // Parse error or unexpected failure
    console.error('LiquidExpr evaluation failed:', error);
    return null;
  }
}
```

#### B.4.6.9 Conformance Tests

Update conformance tests to verify limits:

```typescript
// Resource limit tests
'enforces max operations limit (1000)',
'enforces max call depth (50)',
'enforces max result size (1MB)',
'enforces max execution time (100ms)',
'enforces max array size (10,000)',
'returns null gracefully on limit exceeded',
'does not throw or crash on limit exceeded',
'completes evaluation within timeout for valid expressions',

// Specific edge cases
'handles deeply nested function calls (49 levels OK, 51 levels → null)',
'handles large string concatenation (1MB limit)',
'handles large array aggregation (10,000 elements max)',
'handles pathological expression (returns null, no crash)',
```

#### B.4.6.10 Static Analysis (Compile-Time Checks)

While runtime limits are mandatory, implementations SHOULD perform static analysis to reject obviously unbounded expressions:

```typescript
interface StaticAnalysisResult {
  safe: boolean;
  estimatedOps: number;
  estimatedDepth: number;
  warnings: string[];
}

function analyzeExpression(ast: Expr): StaticAnalysisResult {
  // Count AST nodes as lower bound for operations
  const nodeCount = countNodes(ast);

  // Calculate max depth
  const depth = calculateDepth(ast);

  const warnings: string[] = [];

  // Warn if likely to exceed limits
  if (nodeCount > 800) {
    warnings.push(`High operation count estimate: ${nodeCount}/1000`);
  }

  if (depth > 40) {
    warnings.push(`Deep nesting detected: ${depth}/50 levels`);
  }

  return {
    safe: nodeCount <= 1000 && depth <= 50,
    estimatedOps: nodeCount,
    estimatedDepth: depth,
    warnings,
  };
}
```

**Compilation integration:**

```typescript
// In binding compilation
const analysis = analyzeExpression(parseTransform(binding.transform));

if (!analysis.safe) {
  throw new CompilationError(
    `Transform expression likely exceeds resource limits: ${analysis.warnings.join(', ')}`,
    'TRANSFORM_COMPLEXITY_TOO_HIGH'
  );
}
```
```

---

### 2. Update §B.4.4 (Error Handling)

Add resource limit errors to fallback table (line 2150):

**Add rows:**

| Error | Fallback | Example |
|-------|----------|---------|
| Operation limit exceeded | `null` | `sum(sum(sum(...1000 times...)))` → `null` |
| Stack depth exceeded | `null` | `upper(upper(...60 times...))` → `null` |
| Result size exceeded | `null` | `concat(concat(...huge...))` → `null` |
| Execution timeout | `null` | Runaway loop → `null` |

---

### 3. Update Conformance Tests (§B.3.3)

Add LiquidExpr resource tests at line 2100:

```typescript
  // LiquidExpr resource limits
  'enforces operation count limit',
  'enforces call depth limit',
  'enforces result size limit',
  'enforces execution time limit',
  'returns null gracefully on limit exceeded',
  'never throws or crashes on resource limit',
```

---

### 4. Add to Hardening Checklist (§B.7)

Add to line 2572:

```markdown
- [ ] LiquidExpr enforces all resource limits (ops, depth, size, time)
- [ ] Resource limit exceeded returns null, not crash
- [ ] Static analysis rejects obviously unbounded expressions
```

---

## Implementation Checklist

- [ ] Expand §B.4.6 with complete resource specification (~800 lines)
- [ ] Add resource limit table to §B.4.4 error handling
- [ ] Add ResourceLimits interface to normative types (§B.6.1)
- [ ] Add EvaluationContext interface to normative types
- [ ] Update conformance tests (§B.3.3)
- [ ] Update hardening checklist (§B.7)
- [ ] Add static analysis optional feature

---

## Testing Strategy

### Test Cases

1. **Operation limit:**
   ```typescript
   // 1001 operations → null
   const expr = 'sum([' + Array(1001).fill('1').join(',') + '])';
   expect(evaluate(expr, {})).toBe(null);
   ```

2. **Stack depth limit:**
   ```typescript
   // 51 nested calls → null
   let expr = '$value';
   for (let i = 0; i < 51; i++) {
     expr = `upper(${expr})`;
   }
   expect(evaluate(expr, { value: 'test' })).toBe(null);
   ```

3. **Result size limit:**
   ```typescript
   // >1MB string → null
   const longString = 'x'.repeat(600000);
   const expr = `concat("${longString}", "${longString}")`;
   expect(evaluate(expr, {})).toBe(null);
   ```

4. **Execution time limit:**
   ```typescript
   // Mock slow function to exceed 100ms
   const expr = 'slowFunction($data)';
   expect(evaluate(expr, { data: largeArray })).toBe(null);
   ```

5. **Array size limit:**
   ```typescript
   const largeArray = Array(20000).fill(1);
   const expr = 'sum($arr)';
   expect(evaluate(expr, { arr: largeArray })).toBe(null);
   ```

6. **Valid complex expression:**
   ```typescript
   // Should complete successfully
   const expr = 'currency(round($revenue * 1.1), "$")';
   expect(evaluate(expr, { revenue: 1000 })).toBe('$1,100');
   ```

---

## Migration Impact

**Breaking Change:** No

Existing valid expressions continue to work. Only pathological expressions that would have crashed now return null gracefully.

**Migration Path:** None needed for valid expressions.

**Adapter Impact:** Adapters should handle null return values from transforms (already specified in §B.4.4).

---

## Cross-References

- §B.4.1: LiquidExpr Specification
- §B.4.2: Grammar
- §B.4.3: Built-in Functions
- §B.4.4: Error Handling
- §B.3.1: Render Contract (never crash guarantee)
- §B.3.3: Conformance Test Suite
- §19.1: Error Categories

---

## Specification Diff

### Modified Section: §B.4.6

**Location:** Line 2174

**Replace:** Current §B.4.6 (6 bullet points) with complete resource limit specification (~800 lines)

### Modified Section: §B.4.4

**Location:** Line 2150

**Add:** 4 rows to error fallback table

### Modified Section: §B.3.3

**Location:** Line 2100

**Add:** 6 LiquidExpr resource conformance tests

### Modified Section: §B.7

**Location:** Line 2572

**Add:** 3 resource limit checklist items

---

## Resolution Status

- [x] Problem analyzed
- [x] Solution designed
- [x] Specification content written
- [x] Resource limits defined with rationale
- [x] Cross-references identified
- [x] Test cases defined
- [ ] Approved for merge
- [ ] Applied to SPEC document

---

**Resolution Author:** Claude Opus 4.5
**Review Required:** Yes - Critical change affecting security and safety guarantee
