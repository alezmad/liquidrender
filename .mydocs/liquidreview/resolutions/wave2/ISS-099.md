# Resolution: ISS-099

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Partial Fragment Composition Mismatch
**Severity:** significant
**Target:** SPEC
**Section:** §15 Compositional Grammar Engine, §13.3 Semantic Search

## Resolution

### Original Content

From §15.2:
```typescript
interface CompositionRule {
  pattern: IntentPattern;
  fragments: FragmentRef[];
  layout: LayoutRule;
  signals: SignalWiring;
}
```

From §13.3:
```typescript
interface SemanticMatch {
  fragment: CachedFragment;
  similarity: number;        // 0-1
  adaptations: Adaptation[]; // What needs to change
}

If similarity > 0.85 and adaptations are L2-only (labels/formatting), use cached fragment with adaptations.
```

**No specification for:**
- Handling fragments that partially match requirements (e.g., 3 of 5 needed blocks)
- Scoring partial matches vs full composition
- Deciding when to compose partials vs generate from scratch
- Combining multiple partial fragments

### Replacement Content

**Add new section §15.6 Partial Fragment Matching**

#### 15.6 Partial Fragment Matching

When no single fragment fully satisfies the intent, the engine MAY compose from multiple partial fragments or fall back to LLM generation.

**15.6.1 Match Scoring**

```typescript
interface FragmentMatchScore {
  fragment: CachedFragment;
  coverage: number;              // 0-1: what % of requirements are met
  compatibility: number;         // 0-1: how well it fits context
  adaptation: number;            // 0-1: ease of adaptation (1 = no changes)
  overall: number;               // Weighted composite score
  requirements: RequirementMatch[];
}

interface RequirementMatch {
  requirement: IntentRequirement;
  met: boolean;
  partial: boolean;
  confidence: number;
}

interface IntentRequirement {
  type: 'block_type' | 'binding_field' | 'signal' | 'layout' | 'archetype';
  value: any;
  optional: boolean;
  weight: number;                // Importance (0-1)
}

function scoreFragmentMatch(
  fragment: CachedFragment,
  requirements: IntentRequirement[],
  context: DataFingerprint
): FragmentMatchScore {
  const reqMatches: RequirementMatch[] = [];
  let totalWeight = 0;
  let metWeight = 0;
  let partialWeight = 0;

  for (const req of requirements) {
    totalWeight += req.weight;
    const match = evaluateRequirement(fragment, req, context);
    reqMatches.push(match);

    if (match.met) {
      metWeight += req.weight;
    } else if (match.partial) {
      partialWeight += req.weight * match.confidence;
    }
  }

  const coverage = totalWeight > 0 ? (metWeight + partialWeight) / totalWeight : 0;
  const compatibility = assessCompatibility(fragment, context);
  const adaptation = calculateAdaptationCost(fragment, requirements);

  // Weighted composite score
  const overall = (
    coverage * 0.5 +
    compatibility * 0.3 +
    adaptation * 0.2
  );

  return {
    fragment,
    coverage,
    compatibility,
    adaptation,
    overall,
    requirements: reqMatches,
  };
}
```

**15.6.2 Partial Match Thresholds**

| Overall Score | Strategy | Example |
|---------------|----------|---------|
| ≥ 0.85 | Use fragment directly | Exact match or trivial adaptation |
| 0.70 - 0.85 | Adapt fragment | Change 1-2 bindings, adjust layout |
| 0.50 - 0.70 | Compose from partials | Combine 2-3 fragments |
| 0.30 - 0.50 | Hybrid (partial + LLM) | Use fragment base, LLM fills gaps |
| < 0.30 | Generate from scratch | No useful fragments found |

**15.6.3 Composition Algorithm**

When multiple fragments each partially match:

```typescript
interface CompositionCandidate {
  fragments: FragmentMatchScore[];
  combinedCoverage: number;      // Total requirements covered
  coherence: number;             // How well fragments fit together
  cost: number;                  // Composition complexity
  score: number;                 // Overall viability
}

function findBestComposition(
  requirements: IntentRequirement[],
  context: DataFingerprint,
  fragmentPool: CachedFragment[]
): CompositionCandidate | null {
  // Score all fragments individually
  const scored = fragmentPool
    .map(f => scoreFragmentMatch(f, requirements, context))
    .filter(s => s.coverage > 0.3);  // Ignore low-coverage fragments

  // Try single fragment first
  const best = scored.sort((a, b) => b.overall - a.overall)[0];
  if (best && best.overall >= 0.7) {
    return {
      fragments: [best],
      combinedCoverage: best.coverage,
      coherence: 1.0,              // Single fragment = perfect coherence
      cost: 1 - best.adaptation,
      score: best.overall,
    };
  }

  // Try combinations of 2-3 fragments
  const combinations = generateCombinations(scored, 3);

  return combinations
    .map(combo => scoreCombination(combo, requirements, context))
    .filter(c => c.score > 0.5)
    .sort((a, b) => b.score - a.score)[0] || null;
}

function scoreCombination(
  fragments: FragmentMatchScore[],
  requirements: IntentRequirement[],
  context: DataFingerprint
): CompositionCandidate {
  // Calculate combined coverage
  const coveredReqs = new Set<string>();
  for (const frag of fragments) {
    for (const reqMatch of frag.requirements) {
      if (reqMatch.met || reqMatch.partial) {
        coveredReqs.add(reqMatch.requirement.type + ':' + reqMatch.requirement.value);
      }
    }
  }
  const combinedCoverage = coveredReqs.size / requirements.length;

  // Calculate coherence (how well fragments work together)
  const coherence = assessCoherence(fragments, context);

  // Calculate composition cost (complexity of merging)
  const cost = calculateCompositionCost(fragments);

  // Weighted score
  const score = (
    combinedCoverage * 0.5 +
    coherence * 0.3 +
    (1 - cost) * 0.2
  );

  return {
    fragments,
    combinedCoverage,
    coherence,
    cost,
    score,
  };
}
```

**15.6.4 Coherence Assessment**

Check if fragments can be combined meaningfully:

```typescript
function assessCoherence(
  fragments: FragmentMatchScore[],
  context: DataFingerprint
): number {
  let coherenceScore = 1.0;

  // Check 1: Binding compatibility
  const allBindings = fragments.flatMap(f =>
    f.fragment.blocks.flatMap(b => b.binding?.fields || [])
  );
  const fieldConflicts = findFieldConflicts(allBindings);
  coherenceScore -= fieldConflicts.length * 0.1;

  // Check 2: Signal compatibility
  const allSignals = fragments.flatMap(f =>
    Object.keys(f.fragment.signals || {})
  );
  const signalConflicts = findSignalConflicts(allSignals);
  coherenceScore -= signalConflicts.length * 0.15;

  // Check 3: Layout compatibility
  const layoutConflict = hasLayoutConflict(fragments);
  if (layoutConflict) coherenceScore -= 0.3;

  // Check 4: Archetype alignment
  const archetypes = fragments
    .map(f => f.fragment.archetype)
    .filter(a => a);
  if (new Set(archetypes).size > 1) coherenceScore -= 0.2;

  return Math.max(0, coherenceScore);
}

interface FieldConflict {
  field: string;
  bindings: FieldBinding[];
  conflict: 'different_targets' | 'different_transforms' | 'different_aggregations';
}

function findFieldConflicts(bindings: FieldBinding[]): FieldConflict[] {
  const conflicts: FieldConflict[] = [];
  const byField = new Map<string, FieldBinding[]>();

  for (const binding of bindings) {
    const existing = byField.get(binding.field) || [];
    existing.push(binding);
    byField.set(binding.field, existing);
  }

  for (const [field, fieldBindings] of byField) {
    if (fieldBindings.length <= 1) continue;

    // Check if all bindings use field consistently
    const targets = new Set(fieldBindings.map(b => b.target));
    const transforms = new Set(fieldBindings.map(b => b.transform || 'none'));

    if (targets.size > 1) {
      conflicts.push({
        field,
        bindings: fieldBindings,
        conflict: 'different_targets',
      });
    } else if (transforms.size > 1) {
      conflicts.push({
        field,
        bindings: fieldBindings,
        conflict: 'different_transforms',
      });
    }
  }

  return conflicts;
}
```

**15.6.5 Composition Cost**

Estimate complexity of merging fragments:

```typescript
function calculateCompositionCost(fragments: FragmentMatchScore[]): number {
  let cost = 0;

  // Base cost: number of fragments to merge
  cost += (fragments.length - 1) * 0.2;

  // Layout merging complexity
  const layouts = fragments.map(f => f.fragment.layout?.type).filter(Boolean);
  if (new Set(layouts).size > 1) {
    cost += 0.3;  // Different layout types = expensive merge
  }

  // Signal wiring complexity
  const totalSignals = fragments.reduce(
    (sum, f) => sum + Object.keys(f.fragment.signals || {}).length,
    0
  );
  cost += Math.min(totalSignals * 0.05, 0.3);

  // Block count complexity
  const totalBlocks = fragments.reduce(
    (sum, f) => sum + f.fragment.blocks.length,
    0
  );
  if (totalBlocks > 10) cost += 0.2;

  return Math.min(cost, 1.0);
}
```

**15.6.6 Fallback Decision Tree**

```typescript
function selectResolutionStrategy(
  requirements: IntentRequirement[],
  context: DataFingerprint,
  fragmentPool: CachedFragment[]
): ResolutionStrategy {
  const composition = findBestComposition(requirements, context, fragmentPool);

  if (!composition) {
    return { type: 'llm', reason: 'No viable fragments found' };
  }

  if (composition.score >= 0.85) {
    return {
      type: 'use_fragment',
      fragments: composition.fragments,
      reason: 'High-confidence match',
    };
  }

  if (composition.score >= 0.7) {
    return {
      type: 'adapt_fragment',
      fragments: composition.fragments,
      reason: 'Good match with minor adaptations',
    };
  }

  if (composition.score >= 0.5 && composition.coherence >= 0.7) {
    return {
      type: 'compose',
      fragments: composition.fragments,
      reason: 'Coherent partial fragments available',
    };
  }

  if (composition.score >= 0.4 && composition.combinedCoverage >= 0.6) {
    return {
      type: 'hybrid',
      fragments: composition.fragments,
      reason: 'Partial fragments cover most requirements, LLM fills gaps',
    };
  }

  return {
    type: 'llm',
    reason: `Fragment composition score too low (${composition.score.toFixed(2)})`,
  };
}

type ResolutionStrategy =
  | { type: 'use_fragment'; fragments: FragmentMatchScore[]; reason: string }
  | { type: 'adapt_fragment'; fragments: FragmentMatchScore[]; reason: string }
  | { type: 'compose'; fragments: FragmentMatchScore[]; reason: string }
  | { type: 'hybrid'; fragments: FragmentMatchScore[]; reason: string }
  | { type: 'llm'; reason: string };
```

**15.6.7 Partial Match Examples**

**Example 1: High partial coverage, use fragment**
```typescript
// Intent: "Show revenue KPI and orders chart"
// Fragment: "Revenue KPI, orders KPI, revenue line chart"
// Match: 2/2 requirements met + 1 extra block
// Coverage: 1.0, Coherence: 1.0
// Strategy: use_fragment (trim extra KPI)
```

**Example 2: Complementary fragments, compose**
```typescript
// Intent: "Dashboard with KPIs and table"
// Fragment A: "3 KPIs in row"
// Fragment B: "Data table with filters"
// Match: A covers KPIs (0.5), B covers table (0.5)
// Combined coverage: 1.0, Coherence: 0.9 (same data source)
// Strategy: compose (merge into grid layout)
```

**Example 3: Partial fragment + LLM, hybrid**
```typescript
// Intent: "Sales dashboard with forecast chart"
// Fragment: "Sales KPIs and historical trend chart"
// Match: Covers KPIs and one chart (0.6 coverage)
// Missing: forecast chart (novel requirement)
// Strategy: hybrid (use fragment, LLM generates forecast chart)
```

**Example 4: Low coherence, fall back to LLM**
```typescript
// Intent: "Product analytics dashboard"
// Fragment A: "Financial KPIs" (archetype: overview)
// Fragment B: "User engagement funnel" (archetype: funnel)
// Match: Different domains, conflicting archetypes
// Coherence: 0.3
// Strategy: llm (fragments too different to merge meaningfully)
```

**Add to §13.3 Semantic Search:**

Replace threshold check with:
```typescript
if (similarity > 0.85 && adaptations are L2-only) {
  return { strategy: 'use_fragment', fragment };
} else if (similarity > 0.7) {
  return { strategy: 'adapt_fragment', fragment, adaptations };
} else {
  // Fall through to composition tier (§15.6)
  return selectResolutionStrategy(requirements, context, [fragment, ...others]);
}
```

## Verification Checklist
- [x] Edge case fully specified (partial fragment matching)
- [x] Behavior deterministic (scoring algorithm + decision tree)
- [x] Error handling defined (fallback strategies for all score ranges)
- [x] Examples provided where helpful (4 concrete scenarios with scores)

## Confidence
**HIGH** - This resolution:
1. Defines comprehensive scoring for partial matches (coverage, compatibility, adaptation)
2. Provides clear thresholds and strategies for different score ranges
3. Includes coherence checking to prevent nonsensical compositions
4. Specifies cost estimation for composition complexity
5. Integrates with existing tiered resolution system (§13)
6. Provides 4 realistic examples showing decision logic in practice
