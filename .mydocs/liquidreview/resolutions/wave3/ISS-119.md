# ISS-119: LiquidCode Grammar Breaking Changes

**Issue Type:** Evolution Risk
**Category:** Extensibility and Evolution
**Priority:** Medium
**Affects:** LiquidCode Grammar (Section 6), Compilation Pipeline (Section 17)

---

## Problem Statement

LiquidCode grammar will need to evolve to support new features:

### Potential Grammar Changes

| Feature | Current Syntax | Potential v3+ Syntax |
|---------|----------------|----------------------|
| Multi-dimensional bindings | `L$date$revenue` (2D) | `Heatmap$x:date$y:category$color:revenue` (3D) |
| Nested mutations | Flat operations only | `Δ[@K0+L$trend, @K1~.label:"New"]` (atomic batch) |
| Conditional generation | LLM decides | `K$revenue?revenue>1000` (conditional in LiquidCode) |
| Typed slots | Implicit inference | `K$revenue:value` (explicit slot names) |
| Complex filters | Basic filter syntax | `T$orders{status:active,date>2025}` (inline filter expressions) |

Breaking grammar changes affect:
- Parser implementation
- LLM prompts (must learn new syntax)
- Tooling (syntax highlighters, LSP)
- Documentation and examples
- User-authored LiquidCode (if any)

---

## Resolution

### Strategy: Grammar Versioning

Decouple grammar version from schema version, allowing grammar evolution without schema breaking changes.

### Implementation

#### 1. Grammar Versioning in Schema

```typescript
interface LiquidSchema {
  version: '2.0.0';              // Schema structure version
  grammarVersion?: '2.0';         // Grammar syntax version (NEW)

  // If grammarVersion omitted, defaults to schema major.minor
  // Example: version "2.5.3" → default grammarVersion "2.5"
}

// Example: Using newer grammar with older schema
{
  version: '2.0.0',               // Schema v2
  grammarVersion: '2.1',          // But using v2.1 grammar features
  // ...
}
```

#### 2. Multi-Version Parser

```typescript
interface GrammarParser {
  version: string;                 // "2.0", "2.1", "3.0"
  parse(liquidCode: string): AST;
}

class MultiVersionParser {
  private parsers: Map<string, GrammarParser> = new Map();

  registerParser(version: string, parser: GrammarParser): void {
    this.parsers.set(version, parser);
  }

  parse(liquidCode: string, grammarVersion: string = '2.0'): AST {
    const parser = this.parsers.get(grammarVersion);

    if (!parser) {
      throw new ParseError(
        `Unsupported grammar version: ${grammarVersion}. ` +
        `Supported: ${Array.from(this.parsers.keys()).join(', ')}`
      );
    }

    return parser.parse(liquidCode);
  }
}

// Engine integration
class LiquidEngine {
  private parser: MultiVersionParser;

  constructor() {
    this.parser = new MultiVersionParser();
    this.parser.registerParser('2.0', new GrammarV2_0());
    this.parser.registerParser('2.1', new GrammarV2_1());
    // Future: this.parser.registerParser('3.0', new GrammarV3_0());
  }

  compile(liquidCode: string, options: CompileOptions = {}): LiquidSchema {
    const grammarVersion = options.grammarVersion || '2.0';
    const ast = this.parser.parse(liquidCode, grammarVersion);
    return this.generator.generate(ast);
  }
}
```

#### 3. AST-Based Transformation

All parsers produce a common AST structure, then transform to schema:

```typescript
// Common AST (grammar-agnostic)
interface LiquidAST {
  type: 'interface' | 'mutation' | 'query';
  nodes: ASTNode[];
}

interface ASTNode {
  type: 'block' | 'signal' | 'binding' | 'operation';
  // ... common fields
}

// Grammar-specific parser → Common AST → Schema
const flow = `
  LiquidCode (v2.0 syntax)
      ↓
  GrammarV2_0.parse()
      ↓
  CommonAST
      ↓
  SchemaGenerator.generate()
      ↓
  LiquidSchema
`;

// Alternative grammar → Same AST
const alternativeFlow = `
  LiquidCode (v2.1 syntax with new features)
      ↓
  GrammarV2_1.parse()
      ↓
  CommonAST (same structure!)
      ↓
  SchemaGenerator.generate()
      ↓
  LiquidSchema (compatible)
`;
```

This allows grammar evolution without breaking schema compatibility.

#### 4. Example: Grammar V2.1 (Multi-Dimensional Bindings)

```typescript
class GrammarV2_1 extends GrammarV2_0 {
  parse(code: string): LiquidAST {
    // Support new syntax: Heatmap$x:date$y:category$color:revenue

    // Pattern: BlockType$slot1:field1$slot2:field2...
    const explicitSlotPattern = /(\w+)(\$(\w+):(\w+))+/;

    const match = explicitSlotPattern.exec(code);
    if (match) {
      return this.parseExplicitSlots(match);
    }

    // Fall back to v2.0 parsing for backward compatibility
    return super.parse(code);
  }

  private parseExplicitSlots(match: RegExpMatchArray): ASTNode {
    // Extract: Heatmap, [(x, date), (y, category), (color, revenue)]
    const blockType = match[1];
    const slots = this.extractSlotBindings(match);

    return {
      type: 'block',
      blockType,
      bindings: slots.map(([slot, field]) => ({
        target: slot,
        field: field
      }))
    };
  }
}

// LiquidCode v2.1 example
const code = 'Heatmap$x:date$y:category$color:revenue';

// Parsed with v2.1 grammar
const ast = parser.parse(code, '2.1');

// Result (same AST structure as v2.0, just more explicit bindings)
{
  type: 'block',
  blockType: 'heatmap',
  bindings: [
    { target: 'x', field: 'date' },
    { target: 'y', field: 'category' },
    { target: 'color', field: 'revenue' }
  ]
}
```

#### 5. Grammar Feature Flags

Allow opt-in to experimental grammar features:

```typescript
interface CompileOptions {
  grammarVersion?: string;
  grammarFeatures?: {
    explicitSlots?: boolean;       // v2.1: $slot:field syntax
    conditionalBlocks?: boolean;   // v2.2: K$revenue?revenue>1000
    nestedMutations?: boolean;     // v2.2: Δ[op1, op2]
    inlineFilters?: boolean;       // v2.3: T$orders{status:active}
  };
}

// Usage
engine.compile(
  'Heatmap$x:date$y:category$color:revenue',
  {
    grammarVersion: '2.1',
    grammarFeatures: { explicitSlots: true }
  }
);
```

#### 6. LLM Prompt Grammar Specification

When generating LiquidCode, LLM must know which grammar version to use:

```typescript
// In LLM prompt context
const promptContext = `
You are generating LiquidCode v${grammarVersion}.

Grammar rules:
${getGrammarRules(grammarVersion)}

Examples:
${getGrammarExamples(grammarVersion)}
`;

// Grammar-specific rules
function getGrammarRules(version: string): string {
  if (version === '2.0') {
    return `
      Block bindings: BlockType$field1$field2
      Example: K$revenue, L$date$amount
    `;
  } else if (version === '2.1') {
    return `
      Block bindings (explicit slots): BlockType$slot:field$slot:field
      Example: Heatmap$x:date$y:category$color:revenue

      Block bindings (implicit, backward compatible): BlockType$field1$field2
      Example: K$revenue, L$date$amount
    `;
  }
  // ... other versions
}
```

---

## Grammar Evolution Principles

### 1. Backward Compatibility First

New grammar features should be **additive**, not replacing:

✅ **Good (additive):**
```liquidcode
# v2.0 syntax still works in v2.1
K$revenue

# v2.1 adds explicit slot syntax (optional)
K$value:revenue
```

❌ **Bad (replacement):**
```liquidcode
# v3.0 breaks v2.0 syntax
K$revenue  # ❌ No longer valid
K{value: revenue}  # ✅ New required syntax (BREAKING!)
```

### 2. Versioned Deprecation

When syntax must change:

**V2.5:** Introduce new syntax, deprecate old
```liquidcode
# Old (deprecated but works)
K$revenue

# New (preferred)
K$value:revenue
```

**V3.0:** Remove old syntax (with migration)
```liquidcode
# Old syntax errors, migration tool auto-converts
K$revenue  # ❌ Parse error: Use K$value:revenue
```

### 3. Feature Detection

Parser should detect which features are used:

```typescript
interface ParsedGrammar {
  detectedVersion: string;         // Minimum grammar version required
  usedFeatures: string[];          // Features detected in code
  backwardCompatible: boolean;     // Can run on older parser?
}

const result = parser.analyze('Heatmap$x:date$y:category$color:revenue');
// {
//   detectedVersion: '2.1',
//   usedFeatures: ['explicitSlots'],
//   backwardCompatible: false  // v2.0 parser can't handle this
// }
```

---

## Migration Path

### Phase 1: Grammar Versioning Infrastructure (v2.1)
- Add `grammarVersion` field to schema
- Implement multi-version parser
- Register v2.0 grammar
- No syntax changes yet (infrastructure only)

### Phase 2: Additive Grammar Features (v2.1-2.9)
- v2.1: Explicit slot syntax (optional)
- v2.2: Conditional blocks (optional)
- v2.3: Inline filters (optional)
- All backward compatible with v2.0

### Phase 3: Grammar v3.0 (Breaking, if needed)
- Plan based on 3+ years of v2.x usage data
- Identify pain points in current grammar
- RFC process for breaking changes
- Migration tools for auto-conversion

---

## Testing Requirements

```typescript
describe('Grammar Versioning', () => {
  it('parses v2.0 syntax with v2.0 parser', () => {
    const code = 'K$revenue';
    const ast = parser.parse(code, '2.0');
    expect(ast.nodes[0].bindings[0].target).toBe('value');  // Implicit
  });

  it('parses v2.1 explicit slots', () => {
    const code = 'Heatmap$x:date$y:category$color:revenue';
    const ast = parser.parse(code, '2.1');
    expect(ast.nodes[0].bindings).toHaveLength(3);
    expect(ast.nodes[0].bindings[0]).toEqual({ target: 'x', field: 'date' });
  });

  it('maintains backward compatibility in v2.1', () => {
    const v2_0_code = 'K$revenue';
    const ast = parser.parse(v2_0_code, '2.1');  // v2.1 parser
    expect(ast.nodes[0].bindings[0].target).toBe('value');  // Still works
  });

  it('detects grammar version from syntax', () => {
    const result = parser.analyze('Heatmap$x:date$y:category');
    expect(result.detectedVersion).toBe('2.1');
    expect(result.usedFeatures).toContain('explicitSlots');
  });
});
```

---

## Documentation Requirements

### Grammar Changelog

**Title:** "LiquidCode Grammar Version History"

**Contents:**
- v2.0: Base grammar
- v2.1: Explicit slot syntax, backward compatible
- v2.2: Conditional blocks, nested mutations
- v3.0: (Future) Breaking changes if any

### Migration Guide

**Title:** "Updating LiquidCode Syntax for Grammar v2.1+"

**Contents:**
1. What changed in each version
2. Backward compatibility guarantees
3. How to opt-in to new features
4. Auto-migration tools
5. Examples: before/after

---

## Implementation Checklist

### Phase 1 (v2.1)
- [ ] Add `grammarVersion` field to `LiquidSchema`
- [ ] Implement `MultiVersionParser`
- [ ] Register v2.0 grammar
- [ ] Grammar version detection
- [ ] Update LLM prompts with grammar version

### Phase 2 (v2.1-2.9)
- [ ] Implement v2.1 parser (explicit slots)
- [ ] Implement v2.2 parser (conditionals)
- [ ] Backward compatibility tests
- [ ] Feature detection
- [ ] Documentation updates

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** Medium (adds grammar versioning system)
**Breaking Changes:** None (infrastructure is non-breaking)
**Version Target:** v2.1 (infrastructure), v2.x+ (new grammar features)

**Rationale Integration:** Grammar must evolve to stay expressive, but breaking existing LiquidCode is unacceptable. Versioned grammars with AST-based transformation enable syntax evolution while preserving compatibility. This parallels the schema migration strategy (ISS-114) but for syntax rather than structure.

**Philosophy:** **Syntax is UI for LLMs.** As LLMs evolve, optimal syntax may change. Grammar versioning allows us to improve the "UI" without breaking existing "code."
