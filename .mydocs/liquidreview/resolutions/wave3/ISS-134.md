# ISS-134: Test Vectors Absent - Add Test Vectors

**Issue Type:** Developer Experience
**Category:** Evidence
**Severity:** High
**Status:** Resolved

---

## Problem Statement

The specification lacks comprehensive test vectors:

1. **Grammar test vectors** - Valid/invalid LiquidCode examples (addressed in ISS-128 but expand)
2. **Schema test vectors** - Complete valid/invalid LiquidSchema JSON
3. **Compilation test vectors** - Input LiquidCode → Expected output schema
4. **Mutation test vectors** - Before/after digital twin states
5. **Edge case vectors** - Boundary conditions, stress tests

Developers need test vectors to:
- Verify implementation correctness
- Test parsers/compilers/adapters
- Ensure cross-implementation compatibility
- Regression test fixes

---

## Resolution

### 1. Complete Test Vector Suite

Add new **Appendix C: Test Vectors**:

```markdown
# Appendix C: Test Vectors

## C.1 Grammar Test Vectors

### C.1.1 Minimal Valid Examples

```liquidcode
# TEST: minimal-generation
#overview;G2x2;K$revenue
EXPECT: Compiles successfully
BLOCKS: 1

# TEST: single-block
#simple;S;K$total
EXPECT: Compiles successfully
BLOCKS: 1

# TEST: empty-interface
#empty;S;
EXPECT: Compiles successfully
BLOCKS: 0
```

### C.1.2 Complete Feature Examples

```liquidcode
# TEST: full-featured-dashboard
#sales_dashboard;G2x3
signal:dateRange:dr=30d,url
signal:category:sel=all,session
DF<>@dateRange#date_filter
SF$categories<>@category#category_filter
K$revenue!hero^fixed<@dateRange<@category#main_revenue
K$orders!1^fixed<@dateRange<@category
K$profit!2^shrink<@dateRange<@category
L$date$revenue!1^grow*full<@dateRange<@category
T$orders!3^collapse*full<@dateRange<@category

EXPECT: Compiles successfully
BLOCKS: 7
SIGNALS: 2 (dateRange, category)
LAYOUT: grid 2x3
PRIORITY_DISTRIBUTION: 1 hero, 2 level-1, 1 level-2, 1 level-3
```

### C.1.3 Mutation Examples

```liquidcode
# TEST: add-block
BEFORE: #overview;G2x2;K$revenue,K$orders
MUTATION: delta:+K$profit@[1,0]
AFTER: 3 blocks, profit at [1,0]

# TEST: remove-block
BEFORE: #overview;G2x2;K$revenue,K$orders,K$profit
MUTATION: delta:-@K1
AFTER: 2 blocks (revenue, profit), orders removed

# TEST: replace-type
BEFORE: #overview;G2x2;K$revenue,P$distribution
MUTATION: delta:@P0->B
AFTER: 2 blocks, second is bar-chart

# TEST: modify-property
BEFORE: #overview;G2x2;K$revenue,K$orders
MUTATION: delta:~@K0.layout.priority:"hero"
AFTER: First KPI has priority=hero
```

### C.1.4 Invalid Examples (Must Fail)

```liquidcode
# TEST: unknown-block-type
#overview;G2x2;Z$revenue
EXPECT: SemanticError - Unknown block type 'Z'

# TEST: invalid-selector
delta:-@@@
EXPECT: ParseError - Invalid selector syntax

# TEST: unbalanced-brackets
delta:@[0,0
EXPECT: ParseError - Expected ']'

# TEST: unknown-signal
K$revenue<@unknownSignal
EXPECT: ValidationError - Signal 'unknownSignal' not declared
```

## C.2 Schema Test Vectors

### C.2.1 Minimal Valid Schema

```json
{
  "version": "2.0",
  "scope": "interface",
  "uid": "s_abc123def456",
  "title": "Minimal Interface",
  "generatedAt": "2025-01-15T10:00:00Z",
  "layout": {
    "type": "stack",
    "uid": "b_layout001",
    "config": {
      "type": "stack",
      "direction": "vertical"
    },
    "children": []
  },
  "blocks": []
}
```

EXPECT: Valid, renders empty interface

### C.2.2 Complete Feature Schema

```json
{
  "version": "2.0",
  "scope": "interface",
  "uid": "s_full001",
  "title": "Sales Dashboard",
  "generatedAt": "2025-01-15T10:00:00Z",
  "layout": {
    "type": "grid",
    "uid": "b_layout001",
    "config": {
      "type": "grid",
      "columns": 2,
      "rows": 3
    },
    "children": []
  },
  "blocks": [
    {
      "uid": "b_kpi001",
      "id": "main_revenue",
      "type": "kpi",
      "binding": {
        "source": "sales_data",
        "fields": [
          { "target": "value", "field": "revenue" }
        ]
      },
      "signals": {
        "receives": [
          { "signal": "dateRange", "target": "filter.date" }
        ]
      },
      "layout": {
        "priority": "hero",
        "flex": "fixed"
      }
    }
  ],
  "signals": {
    "dateRange": {
      "type": "dateRange",
      "default": { "start": "2024-12-16", "end": "2025-01-15" },
      "persist": "url"
    }
  }
}
```

EXPECT: Valid, renders dashboard with 1 KPI and signal

### C.2.3 Invalid Schemas (Must Fail Validation)

```json
// TEST: missing-version
{
  "scope": "interface",
  "uid": "s_test",
  ...
}
EXPECT: ValidationError - version is required

// TEST: invalid-version
{
  "version": "1.0",
  ...
}
EXPECT: ValidationError - version must be "2.0"

// TEST: invalid-uid-format
{
  "version": "2.0",
  "uid": "invalid",
  ...
}
EXPECT: ValidationError - UID must match /^s_[a-z0-9]{12}$/

// TEST: unknown-block-type
{
  "blocks": [
    { "uid": "b_test", "type": "unknown-type" }
  ],
  ...
}
EXPECT: ValidationError - Invalid block type

// TEST: orphaned-signal-receive
{
  "blocks": [
    {
      "uid": "b_test",
      "type": "kpi",
      "signals": {
        "receives": [{ "signal": "undeclared", "target": "filter" }]
      }
    }
  ],
  "signals": {}
}
EXPECT: ValidationError - Signal 'undeclared' not in registry
```

## C.3 Compilation Test Vectors

### C.3.1 Simple Generation

INPUT:
```liquidcode
#overview;G2x2;K$revenue,K$orders
```

EXPECTED OUTPUT:
```json
{
  "version": "2.0",
  "scope": "interface",
  "uid": "<generated>",
  "title": "Overview",
  "generatedAt": "<timestamp>",
  "layout": {
    "type": "grid",
    "uid": "<generated>",
    "config": { "type": "grid", "columns": 2, "rows": 2 },
    "children": []
  },
  "blocks": [
    {
      "uid": "<generated>",
      "type": "kpi",
      "binding": {
        "source": "data",
        "fields": [{ "target": "value", "field": "revenue" }]
      }
    },
    {
      "uid": "<generated>",
      "type": "kpi",
      "binding": {
        "source": "data",
        "fields": [{ "target": "value", "field": "orders" }]
      }
    }
  ]
}
```

VALIDATION:
- Block count matches (2)
- Block types correct (both kpi)
- Bindings correct (revenue, orders)
- Layout correct (grid 2x2)

### C.3.2 With Signals

INPUT:
```liquidcode
#dashboard;G2x2
signal:dateRange:dr=30d,url
DF<>@dateRange
K$revenue<@dateRange
```

EXPECTED OUTPUT:
- 2 blocks (date-filter, kpi)
- 1 signal declaration (dateRange)
- date-filter emits and receives dateRange
- kpi receives dateRange into filter binding
- Signal persists to URL

## C.4 Edge Case Test Vectors

### C.4.1 Boundary Conditions

```liquidcode
# TEST: max-blocks (100 blocks)
#large;G10x10;K$f1,K$f2,...,K$f100
EXPECT: Compiles, but may warn about performance

# TEST: deep-nesting (slots in slots, 10 levels)
<nested schema with 10 levels of slot containment>
EXPECT: Compiles successfully

# TEST: max-signals (50 signals)
signal:s1:dr,signal:s2:dr,...,signal:s50:dr
EXPECT: Compiles successfully

# TEST: empty-field-name
K$
EXPECT: ParseError - Expected field name after $
```

### C.4.2 Unicode Handling

```liquidcode
# TEST: unicode-field-names
K$收入  # Chinese "revenue"
EXPECT: ParseError - Field names must be ASCII identifiers
(Per B.1, identifiers are [a-zA-Z_][a-zA-Z0-9_]*)

# TEST: unicode-operators
Δ+K$revenue@[0,0]  # Unicode delta
delta:+K$revenue@[0,0]  # ASCII delta
EXPECT: Both compile to same result
```

### C.4.3 Whitespace Variations

```liquidcode
# TEST: no-whitespace
#overview;G2x2;K$revenue,K$orders
EXPECT: Valid

# TEST: lots-of-whitespace
#overview  ;  G2x2  ;  K$revenue  ,  K$orders
EXPECT: Valid, equivalent to no-whitespace

# TEST: newlines-as-separators
#overview;G2x2
K$revenue
K$orders
EXPECT: Valid, equivalent to comma-separated
```

## C.5 Performance Test Vectors

### C.5.1 Compilation Performance

```liquidcode
# TEST: compilation-latency-small (5 blocks)
#overview;G2x2;K$a,K$b,L$c$d,T$e
BUDGET: <20ms P99

# TEST: compilation-latency-medium (20 blocks)
<20 block dashboard>
BUDGET: <50ms P99

# TEST: compilation-latency-large (100 blocks)
<100 block dashboard>
BUDGET: <200ms P99
```

### C.5.2 Validation Performance

```json
// TEST: validation-latency
<valid schema with 50 blocks>
BUDGET: Validation <20ms P99
```

## C.6 Cross-Implementation Compatibility

### C.6.1 Canonical Examples

These examples MUST produce byte-for-byte identical schemas across implementations:

```liquidcode
# CANONICAL-1
#overview;G2x2;K$revenue,K$orders,L$date$amount,T$data

# CANONICAL-2
#dashboard;G2x3
signal:dateRange:dr=30d,url
DF<>@dateRange
K$revenue<@dateRange
```

REQUIREMENT: Hash of compiled schema identical across implementations
(After normalizing UIDs and timestamps to fixed values)

## C.7 Regression Test Vectors

### C.7.1 Bug Fixes

```liquidcode
# BUG-001: Address resolution drift after insert
BEFORE: K$a,K$b,K$c
MUTATION: delta:+K$new@[0,0]
QUERY: ?@K1  # Should still resolve to original K$b, not K$c
EXPECT: Resolves to block with binding "b"

# BUG-002: Signal orphan after remove
BEFORE: DF<>@dateRange, K$revenue<@dateRange
MUTATION: delta:-@DF0
EXPECT: ValidationWarning - K still receives @dateRange but no emitter
```

---

## C.8 Test Suite Structure

Implementations MUST pass:

1. **All valid grammar examples** compile
2. **All invalid grammar examples** fail with expected error
3. **All valid schemas** pass validation
4. **All invalid schemas** fail validation with expected error
5. **All compilation vectors** produce semantically equivalent output
6. **All edge cases** handle correctly
7. **All performance budgets** met
8. **Canonical examples** produce identical output (normalized)

**Test runner:**

```typescript
interface TestVector {
  id: string;
  category: string;
  input: string | object;
  expectedOutput?: object;
  expectedError?: string;
  budget?: number;  // ms
}

function runTestVector(vector: TestVector): TestResult {
  // ... implementation
}

function runTestSuite(vectors: TestVector[]): SuiteResult {
  const results = vectors.map(runTestVector);
  return {
    total: results.length,
    passed: results.filter(r => r.passed).length,
    failed: results.filter(r => !r.passed).length,
    results,
  };
}
```
```

---

## Resolution Summary

Complete test vector suite:
1. **Grammar vectors** - 20+ valid/invalid examples
2. **Schema vectors** - 10+ valid/invalid JSON examples
3. **Compilation vectors** - Input → expected output pairs
4. **Edge case vectors** - Boundaries, unicode, whitespace
5. **Performance vectors** - Latency budgets
6. **Canonical vectors** - Cross-implementation compatibility
7. **Regression vectors** - Bug fix verification

Developers now have comprehensive test suite for validation.
