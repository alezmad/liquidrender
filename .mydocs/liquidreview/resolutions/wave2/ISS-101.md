# Resolution: ISS-101

## Status: ✅ RESOLVED

## Issue Summary
**Title:** LiquidExpr Division by Zero
**Severity:** significant
**Target:** SPEC
**Section:** §B.4 Safe Transform DSL

## Resolution

### Original Content

From §B.4.4:
```
| Error | Fallback | Example |
|-------|----------|---------|
| Divide by zero | `null` | `10 / 0` → `null` |
| Missing field | `null` | `$missing` → `null` |
| Type mismatch | `null` | `upper(123)` → `null` |
| Null input | `null` | `round(null)` → `null` |
```

From §B.4.1:
```
**Properties:**
- **Pure:** No side effects, no I/O
- **Total:** Always terminates, no exceptions
- **Typed:** Statically typed, errors at compile time
- **Sandboxed:** No access to external state
```

**Specification states division by zero returns `null` but lacks:**
- Handling for other mathematical edge cases (sqrt of negative, log of zero, etc.)
- Behavior for operations with `null` operands (null propagation vs short-circuit)
- Overflow/underflow handling
- NaN/Infinity handling (important for JavaScript implementations)

### Replacement Content

**Replace §B.4.4 Error Handling with comprehensive specification:**

#### B.4.4 Error Handling and Edge Cases

LiquidExpr NEVER throws exceptions. All error conditions produce typed fallback values with predictable propagation rules.

**B.4.4.1 Mathematical Edge Cases**

| Operation | Edge Case | Result | Reasoning |
|-----------|-----------|--------|-----------|
| Division | `x / 0` where x ≠ 0 | `null` | Undefined mathematically |
| Division | `0 / 0` | `null` | Indeterminate form |
| Modulo | `x % 0` | `null` | Undefined mathematically |
| Square root | `sqrt(x)` where x < 0 | `null` | Imaginary result (not supported) |
| Logarithm | `log(0)` | `null` | Negative infinity (not representable) |
| Logarithm | `log(x)` where x < 0 | `null` | Complex result (not supported) |
| Power | `0 ^ 0` | `1` | Mathematical convention (lim x→0 x^x = 1) |
| Power | `x ^ y` where result > MAX_SAFE_INTEGER | `null` | Overflow |
| Power | `x ^ y` where result < MIN_SAFE_INTEGER | `null` | Underflow |

**B.4.4.2 Null Propagation**

LiquidExpr uses **strict null propagation**: any operation involving `null` produces `null`.

```typescript
// Arithmetic with null
null + 5        → null
10 - null       → null
null * null     → null
100 / null      → null

// Comparison with null
null == null    → true
null == 5       → false
null != 5       → true
null < 5        → false  (null is not comparable)
null >= null    → false

// Logical with null
null && true    → null
true && null    → null
null || false   → false  (null is falsy)
false || null   → false

// Function calls with null
round(null)     → null
upper(null)     → null
if(null, 'a', 'b') → 'b'  (null is falsy)
```

**B.4.4.3 Type Coercion Rules**

When operand types don't match, attempt coercion before falling back to `null`:

```typescript
// Number + String (concat if either is string)
5 + "3"         → "53"
"Revenue: " + 100 → "Revenue: 100"

// String to Number (for arithmetic)
"10" - 5        → 5
"10" * "2"      → 20
"10.5" / 2      → 5.25
"abc" - 5       → null  (coercion fails)

// Boolean to Number
true + 1        → 2
false * 10      → 0

// String to Boolean (in logical context)
"" || "default" → "default"  (empty string is falsy)
"text" && true  → true

// Any to Boolean (in conditionals)
if(0, 'a', 'b')      → 'b'  (0 is falsy)
if(1, 'a', 'b')      → 'a'  (non-zero is truthy)
if("", 'a', 'b')     → 'b'  (empty string is falsy)
if("text", 'a', 'b') → 'a'  (non-empty string is truthy)
```

**B.4.4.4 NaN and Infinity Handling**

JavaScript's `NaN` and `Infinity` are not first-class values in LiquidExpr:

```typescript
// Operations producing NaN in JS → null in LiquidExpr
0 / 0           → null  (not NaN)
sqrt(-1)        → null  (not NaN)
parseFloat("abc") → null  (not NaN)

// Operations producing Infinity in JS → null in LiquidExpr
1 / 0           → null  (not Infinity)
-1 / 0          → null  (not -Infinity)
Math.pow(10, 1000) → null  (overflow, not Infinity)

// Checking for these values
isNaN(x)        → not available (use x == null)
isFinite(x)     → not available (valid numbers are always finite)
```

**B.4.4.5 Numeric Bounds**

LiquidExpr uses **safe integer arithmetic** to prevent silent overflow:

```typescript
const MAX_SAFE_INTEGER = 9007199254740991;   // 2^53 - 1
const MIN_SAFE_INTEGER = -9007199254740991;  // -(2^53 - 1)

// Operations exceeding bounds → null
MAX_SAFE_INTEGER + 1000     → null
MIN_SAFE_INTEGER - 1000     → null
MAX_SAFE_INTEGER * 2        → null

// Floating-point results remain valid until overflow
1.7976931348623157e+308     → null  (exceeds MAX_VALUE)
5e-324                      → null  (below MIN_VALUE, underflow)
```

**B.4.4.6 String Edge Cases**

```typescript
// String operations on non-strings
upper(123)          → null  (type error)
lower(true)         → null  (type error)
trim(null)          → null  (null propagation)

// Empty strings
upper("")           → ""
len("")             → 0
trim("  ")          → ""

// String slicing out of bounds
substr("hello", 10, 5)  → ""    (start beyond length)
substr("hello", -1, 3)  → null  (negative index not supported)
substr("hello", 2, -1)  → null  (negative length not supported)
```

**B.4.4.7 Date Edge Cases**

```typescript
// Invalid dates
year("not a date")      → null
month(null)             → null
format("2023-13-45", "YYYY-MM-DD") → null  (invalid date)

// Date arithmetic overflow
diff("0001-01-01", "9999-12-31", "days") → valid (large number ok)
diff("0000-01-01", "0001-01-01", "days") → null  (year 0 invalid)

// Timezone handling
// All dates treated as UTC unless explicitly specified
format("2023-06-15T12:00:00Z", "YYYY-MM-DD HH:mm") → "2023-06-15 12:00"
```

**B.4.4.8 Array/Aggregate Edge Cases**

```typescript
// Empty arrays
sum([])             → 0     (mathematical identity)
avg([])             → null  (undefined)
count([])           → 0
first([])           → null  (no first element)
last([])            → null  (no last element)
min([])             → null  (undefined)
max([])             → null  (undefined)

// Arrays with null
sum([1, null, 3])   → null  (null propagation)
count([1, null, 3]) → 3     (count includes null)
avg([1, 2, 3])      → 2
avg([1, null, 3])   → null  (null contaminates average)

// Type mixing in arrays
sum([1, "2", 3])    → null  (mixed types)
max([1, 2, "3"])    → null  (incomparable types)
```

**B.4.4.9 Execution Bounds**

To prevent infinite loops or hangs:

```typescript
const MAX_OPERATIONS = 1000;  // Maximum operations per expression
const MAX_CALL_DEPTH = 10;    // Maximum nested function calls

// Exceeding operation limit → null
// Example: Complex nested expression with 1000+ operations
if(a, if(b, if(c, ...))) → null (too deep)

// Timeout (implementation-specific)
const EXECUTION_TIMEOUT = 100;  // milliseconds

// Expression taking > 100ms → null
```

**B.4.4.10 Error Handling Implementation**

```typescript
type LiquidValue = number | string | boolean | null;

function safeDivide(a: LiquidValue, b: LiquidValue): LiquidValue {
  // Null propagation
  if (a === null || b === null) return null;

  // Type validation
  if (typeof a !== 'number' || typeof b !== 'number') {
    // Attempt coercion
    a = coerceToNumber(a);
    b = coerceToNumber(b);
    if (a === null || b === null) return null;
  }

  // Division by zero
  if (b === 0) return null;

  // Perform division
  const result = a / b;

  // Check for overflow/underflow/NaN
  if (!Number.isFinite(result)) return null;
  if (Math.abs(result) > Number.MAX_SAFE_INTEGER) return null;

  return result;
}

function coerceToNumber(value: LiquidValue): number | null {
  if (typeof value === 'number') return value;
  if (typeof value === 'boolean') return value ? 1 : 0;
  if (typeof value === 'string') {
    const parsed = parseFloat(value);
    return Number.isNaN(parsed) ? null : parsed;
  }
  return null;
}

function safeSqrt(x: LiquidValue): LiquidValue {
  if (x === null) return null;

  const num = coerceToNumber(x);
  if (num === null) return null;
  if (num < 0) return null;  // No imaginary numbers

  return Math.sqrt(num);
}

function safeLog(x: LiquidValue): LiquidValue {
  if (x === null) return null;

  const num = coerceToNumber(x);
  if (num === null) return null;
  if (num <= 0) return null;  // log(0) and log(negative) undefined

  return Math.log(num);
}
```

**B.4.4.11 Comprehensive Error Table**

| Category | Operation | Invalid Input | Result |
|----------|-----------|---------------|--------|
| **Arithmetic** | `a + b` | Either null | `null` |
| | `a - b` | Either null | `null` |
| | `a * b` | Either null | `null` |
| | `a / b` | b = 0 | `null` |
| | `a / b` | Either null | `null` |
| | `a % b` | b = 0 | `null` |
| | `a ^ b` | Overflow | `null` |
| **Math Functions** | `sqrt(x)` | x < 0 | `null` |
| | `log(x)` | x ≤ 0 | `null` |
| | `abs(x)` | x = null | `null` |
| | `round(x)` | x = null | `null` |
| | `min(a,b)` | Either null | `null` |
| | `max(a,b)` | Either null | `null` |
| **String Functions** | `upper(s)` | s not string | `null` |
| | `lower(s)` | s not string | `null` |
| | `len(s)` | s not string/array | `null` |
| | `substr(s,i,n)` | i or n negative | `null` |
| | `substr(s,i,n)` | i > len(s) | `""` |
| **Date Functions** | `year(d)` | d not date | `null` |
| | `format(d,f)` | d invalid | `null` |
| | `diff(d1,d2,u)` | Either invalid | `null` |
| **Aggregate Functions** | `avg([])` | Empty array | `null` |
| | `avg([...])` | Contains null | `null` |
| | `sum([])` | Empty array | `0` |
| | `first([])` | Empty array | `null` |
| | `max([])` | Empty array | `null` |
| **Logical** | `a && b` | a falsy | `a` |
| | `a \|\| b` | a truthy | `a` |
| | `if(c,t,f)` | c falsy | `f` |
| **Comparison** | `a < b` | Either null | `false` |
| | `a == b` | null == null | `true` |

**Add to §B.4.2 Grammar:**

```ebnf
(* Add explicit null literal *)
literal     = NUMBER | STRING | BOOLEAN | NULL | "null"
```

## Verification Checklist
- [x] Edge case fully specified (division by zero + all mathematical edge cases)
- [x] Behavior deterministic (null propagation rules + comprehensive error table)
- [x] Error handling defined (all operations return null on error, no exceptions)
- [x] Examples provided where helpful (50+ examples across 11 categories)

## Confidence
**HIGH** - This resolution:
1. Comprehensively specifies behavior for all mathematical edge cases, not just division by zero
2. Defines clear null propagation rules (strict propagation)
3. Specifies type coercion rules for mixed-type operations
4. Handles JavaScript-specific concerns (NaN, Infinity, safe integer bounds)
5. Provides complete error table covering all built-in functions
6. Includes working implementation examples for key operations
7. Maintains totality guarantee (no exceptions, always terminates)
8. Adds execution bounds to prevent infinite loops
