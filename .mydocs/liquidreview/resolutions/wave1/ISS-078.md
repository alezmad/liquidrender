# Resolution: ISS-078 - UID Collision in High-Volume Generation

**Issue ID:** ISS-078
**Severity:** Critical
**Target Document:** `.mydocs/liquidcode/LIQUIDCODE-SPEC-v2.md`
**Review Source:** 08-edge-cases-failure-modes.md (Failure 3)
**Date:** 2025-12-21

---

## Problem Statement

**Current State:** The UID format `b_[a-z0-9]{12}` lacks collision probability analysis and generation strategy, creating risk of silent data corruption in high-volume or distributed scenarios.

**Trigger Scenarios:**
1. Rapid generation of many schemas (10,000+ blocks/second)
2. Distributed systems with parallel generators without coordination
3. UID format: `b_[a-z0-9]{12}` = 36^12 ≈ 4.7×10^18 space
4. Birthday paradox: ~50% collision probability at √(36^12) ≈ 68 million blocks

**Impact:**
- Mutation targets wrong block (silent data corruption)
- Undo/redo breaks (operation applied to wrong block)
- Cache poisoning (different blocks share same UID)
- **CRITICAL:** Violates stable identity guarantee (§B.2)

**Current Handling:**
- §B.2.1: "Generated at creation time" but no uniqueness guarantee
- No mention of collision detection or generation algorithm
- No distributed coordination strategy

---

## Resolution

### 1. Add UID Generation Specification to §B.2.5 (New Subsection)

Add the following after §B.2.4 (Explicit ID Addressing):

```markdown
### B.2.5 UID Generation and Collision Avoidance

#### B.2.5.1 UID Format Specification

**Normative Format:**

```
Block UID:     b_<timestamp:8><random:8>
Schema UID:    s_<timestamp:8><random:8>
```

**Components:**

| Component | Length | Encoding | Purpose |
|-----------|--------|----------|---------|
| Prefix | 2 chars | `b_` or `s_` | Type identification |
| Timestamp | 8 chars | Base36 (0-9a-z) | Temporal ordering + entropy |
| Random | 8 chars | Base36 (0-9a-z) | Collision resistance |

**Example:**
```
b_k7m3n9p2a4f8c1b6
  ^prefix
    ^^^^^^^^timestamp (ms since epoch, base36)
            ^^^^^^^^random (8 chars base36)
```

#### B.2.5.2 Generation Algorithm

```typescript
interface UIDGenerator {
  generateBlockUID(): string;
  generateSchemaUID(): string;

  // For testing/debugging
  readonly generatedCount: number;
  readonly lastGenerationTime: number;
}

class DefaultUIDGenerator implements UIDGenerator {
  private lastTimestamp = 0;
  private sequenceCounter = 0;
  generatedCount = 0;
  lastGenerationTime = 0;

  generateBlockUID(): string {
    return this.generate('b_');
  }

  generateSchemaUID(): string {
    return this.generate('s_');
  }

  private generate(prefix: string): string {
    const now = Date.now();

    // Ensure timestamp monotonicity within process
    if (now === this.lastTimestamp) {
      this.sequenceCounter++;
    } else {
      this.lastTimestamp = now;
      this.sequenceCounter = 0;
    }

    // Timestamp component (8 chars base36)
    const timestampPart = this.encodeBase36(now, 8);

    // Random component (8 chars base36)
    // Include sequence counter in random seed for monotonicity within ms
    const randomSeed = now + this.sequenceCounter;
    const randomPart = this.generateRandomBase36(8, randomSeed);

    this.generatedCount++;
    this.lastGenerationTime = now;

    return `${prefix}${timestampPart}${randomPart}`;
  }

  private encodeBase36(num: number, length: number): string {
    let result = num.toString(36).padStart(length, '0');

    // Truncate if too long (take rightmost chars for rollover)
    if (result.length > length) {
      result = result.slice(-length);
    }

    return result;
  }

  private generateRandomBase36(length: number, seed?: number): string {
    const chars = '0123456789abcdefghijklmnopqrstuvwxyz';
    let result = '';

    // Use crypto.getRandomValues if available (browser/secure contexts)
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      const buffer = new Uint32Array(length);
      crypto.getRandomValues(buffer);

      for (let i = 0; i < length; i++) {
        result += chars[buffer[i] % 36];
      }
    } else {
      // Fallback to Math.random with seed mixing
      let random = seed ?? Date.now();
      for (let i = 0; i < length; i++) {
        random = (random * 9301 + 49297) % 233280;  // Linear congruential generator
        const idx = random % 36;
        result += chars[idx];
      }
    }

    return result;
  }
}
```

#### B.2.5.3 Collision Probability Analysis

**Birthday Paradox Formula:**

```
P(collision) ≈ 1 - e^(-n²/(2×N))

where:
  n = number of UIDs generated
  N = total namespace size
```

**For LiquidCode UIDs:**

```
Total namespace: 36^16 ≈ 7.96 × 10^24

Collision probability:
  n = 1 million:     P ≈ 6.3 × 10^-14   (negligible)
  n = 1 billion:     P ≈ 6.3 × 10^-8    (1 in 16 million)
  n = 1 trillion:    P ≈ 6.3 × 10^-2    (6.3%, concerning)
```

**Practical Limits:**

| Scenario | Blocks Generated | Collision Risk | Mitigation |
|----------|------------------|----------------|------------|
| Single user, 1 year | ~1 million | Negligible | None needed |
| Enterprise, 1 year | ~100 million | Very low | None needed |
| SaaS platform, 1 year | ~10 billion | Low (0.0006%) | Detection recommended |
| High-volume distributed | ~1 trillion | Moderate (6%) | Detection + coordination required |

#### B.2.5.4 Collision Detection

All implementations MUST detect collisions during schema construction:

```typescript
interface DigitalTwin {
  schema: LiquidSchema;
  timestamp: number;
  operationCount: number;

  // NEW: UID uniqueness tracking
  private uidRegistry: Set<string>;
}

class DigitalTwinImpl implements DigitalTwin {
  private uidRegistry = new Set<string>();

  registerBlock(block: Block): void {
    // Collision detection
    if (this.uidRegistry.has(block.uid)) {
      throw new UIDCollisionError(
        `UID collision detected: ${block.uid} already exists in schema`,
        block.uid,
        this.findBlockByUID(block.uid)
      );
    }

    this.uidRegistry.add(block.uid);
  }

  removeBlock(uid: string): void {
    this.uidRegistry.delete(uid);
  }
}

class UIDCollisionError extends Error {
  constructor(
    message: string,
    public readonly collidingUID: string,
    public readonly existingBlock: Block | null
  ) {
    super(message);
    this.name = 'UIDCollisionError';
  }
}
```

**Handling Strategy:**

1. **Detection:** All UIDs added to schema checked against registry
2. **On Collision:**
   - Log error with both blocks
   - Regenerate UID for new block (retry up to 3 times)
   - If retry fails, throw fatal error (prevents silent corruption)
3. **Production:** Collision events trigger monitoring alerts

```typescript
function addBlockWithCollisionRetry(
  twin: DigitalTwin,
  block: Block,
  generator: UIDGenerator,
  maxRetries = 3
): Block {
  let attempts = 0;
  let currentBlock = block;

  while (attempts < maxRetries) {
    try {
      twin.registerBlock(currentBlock);
      return currentBlock;
    } catch (error) {
      if (error instanceof UIDCollisionError) {
        attempts++;
        console.warn(
          `UID collision on attempt ${attempts}: ${currentBlock.uid}. Regenerating...`
        );

        // Regenerate UID
        currentBlock = {
          ...currentBlock,
          uid: generator.generateBlockUID(),
        };
      } else {
        throw error;
      }
    }
  }

  // Fatal: Multiple retries failed
  throw new Error(
    `Failed to generate unique UID after ${maxRetries} attempts. ` +
    `Possible systematic issue with UID generator.`
  );
}
```

#### B.2.5.5 Distributed Coordination

For distributed systems (multiple processes/servers generating UIDs concurrently):

**Strategy 1: Instance ID Prefix (Recommended)**

```typescript
interface DistributedUIDGenerator extends UIDGenerator {
  readonly instanceId: string;  // 4-char base36
}

class DistributedUIDGeneratorImpl implements DistributedUIDGenerator {
  constructor(public readonly instanceId: string) {
    if (!/^[0-9a-z]{4}$/.test(instanceId)) {
      throw new Error('Instance ID must be 4 chars base36');
    }
  }

  private generate(prefix: string): string {
    const timestamp = this.encodeBase36(Date.now(), 6);  // Reduced to 6
    const random = this.generateRandomBase36(6);         // Reduced to 6

    // Format: b_<instance:4><timestamp:6><random:6>
    return `${prefix}${this.instanceId}${timestamp}${random}`;
  }
}

// Total namespace per instance: 36^12 ≈ 4.7 × 10^18
// Total instances possible: 36^4 ≈ 1.68 million
// Combined namespace: 36^16 ≈ 7.96 × 10^24 (unchanged)
```

**Instance ID Assignment:**

```typescript
// Option 1: Hash-based (from hostname/process ID)
function generateInstanceId(): string {
  const source = `${os.hostname()}-${process.pid}-${Date.now()}`;
  const hash = createHash('sha256').update(source).digest('hex');
  return parseInt(hash.slice(0, 8), 16).toString(36).padStart(4, '0').slice(0, 4);
}

// Option 2: Coordinated assignment (via central registry)
async function assignInstanceId(registry: InstanceRegistry): Promise<string> {
  return await registry.claimNextId();
}
```

**Strategy 2: UUIDv4 Format (Maximum Safety)**

For systems requiring absolute collision avoidance:

```typescript
class UUIDBasedGenerator implements UIDGenerator {
  generateBlockUID(): string {
    return `b_${this.generateUUID()}`;
  }

  generateSchemaUID(): string {
    return `s_${this.generateUUID()}`;
  }

  private generateUUID(): string {
    // Use standard UUID v4
    const uuid = crypto.randomUUID();
    // Convert to compact format (remove hyphens)
    return uuid.replace(/-/g, '').slice(0, 16);
  }
}

// Format: b_<uuid:32 chars, base16>
// Namespace: 2^128 ≈ 3.4 × 10^38
// Collision probability at 1 trillion: ~1.47 × 10^-18 (effectively zero)
```

#### B.2.5.6 Configuration

Implementations SHOULD allow UID generator configuration:

```typescript
interface LiquidEngineConfig {
  // ... existing config ...

  uidGenerator?: UIDGenerator | 'default' | 'distributed' | 'uuid';
  instanceId?: string;  // Required if uidGenerator === 'distributed'
}

// Usage
const engine = new LiquidEngine({
  uidGenerator: 'distributed',
  instanceId: 'a1b2',  // Assigned by infrastructure
});
```

#### B.2.5.7 Validation and Testing

**Validation Rules:**

```typescript
const BLOCK_UID_REGEX = /^b_[0-9a-z]{16}$/;
const SCHEMA_UID_REGEX = /^s_[0-9a-z]{16}$/;

function validateBlockUID(uid: string): boolean {
  return BLOCK_UID_REGEX.test(uid);
}

function validateSchemaUID(uid: string): boolean {
  return SCHEMA_UID_REGEX.test(uid);
}
```

**Conformance Tests:**

```typescript
// Test UID generation
'generates valid UID format (b_[a-z0-9]{16})',
'generates unique UIDs across 10,000 rapid calls',
'detects UID collision and throws error',
'retries on collision with new UID',
'includes timestamp for temporal ordering',
'produces monotonically increasing UIDs within process',

// Test collision probability
'generates 1 million UIDs with no collisions (statistical)',
'distributed generators with different instance IDs produce no collisions',
```

#### B.2.5.8 Migration Path

**Existing schemas with old format:**

If upgrading from `b_<random:12>` format:

```typescript
function migrateUID(oldUID: string): string {
  // Old format: b_abc123def456
  // New format: b_<timestamp:8><random:8>

  if (/^b_[0-9a-z]{16}$/.test(oldUID)) {
    return oldUID;  // Already new format
  }

  if (/^b_[0-9a-z]{12}$/.test(oldUID)) {
    // Migrate: Add timestamp prefix, keep random suffix
    const timestamp = encodeBase36(Date.now(), 8);
    const random = oldUID.slice(2, 10);  // Take first 8 chars of old UID
    return `b_${timestamp}${random}`;
  }

  throw new Error(`Invalid UID format: ${oldUID}`);
}
```
```

---

### 2. Update §B.2.1 UID Requirements

Modify line 1950 to reference generation spec:

**Before:**
```typescript
**UID properties:**
- Generated at creation time (compile or mutation)
- Immutable for block lifetime
- Survives position changes, type changes, property modifications
- Format: `b_<random12>` (e.g., `b_a7f3c9e2b4d1`)
```

**After:**
```typescript
**UID properties:**
- Generated at creation time (compile or mutation) per §B.2.5
- Immutable for block lifetime
- Survives position changes, type changes, property modifications
- Format: `b_<timestamp:8><random:8>` (e.g., `b_k7m3n9p2a4f8c1b6`)
- Guaranteed unique within schema via collision detection
- Temporally ordered for audit/debugging
```

---

### 3. Update Digital Twin Interface (§16.1)

Add UID registry at line 1505:

**Before:**
```typescript
interface DigitalTwin {
  schema: LiquidSchema;          // Current valid schema
  timestamp: number;             // Last update time
  operationCount: number;        // Total operations applied
}
```

**After:**
```typescript
interface DigitalTwin {
  schema: LiquidSchema;          // Current valid schema
  timestamp: number;             // Last update time
  operationCount: number;        // Total operations applied

  // UID uniqueness tracking (§B.2.5.4)
  uidRegistry: Set<string>;      // All active UIDs in schema

  // Methods
  registerBlock(block: Block): void;
  removeBlock(uid: string): void;
}
```

---

### 4. Update Validation Schema (§B.6.3)

Update UID regex at line 2515:

**Before:**
```typescript
uid: z.string().regex(/^b_[a-z0-9]{12}$/),
```

**After:**
```typescript
uid: z.string().regex(/^b_[a-z0-9]{16}$/),  // 8 timestamp + 8 random
```

---

### 5. Update Conformance Tests (§B.3.3)

Add UID generation tests at line 2100:

```typescript
  // UID generation and collision handling
  'generates valid UID format',
  'generates unique UIDs across rapid generation',
  'detects UID collision during schema construction',
  'retries UID generation on collision',
  'maintains UID registry in Digital Twin',
```

---

## Implementation Checklist

- [ ] Add §B.2.5 with complete UID generation specification
- [ ] Update §B.2.1 UID format description
- [ ] Add uidRegistry to DigitalTwin interface (§16.1)
- [ ] Update UID regex in validation schema (§B.6.3)
- [ ] Add UIDGenerator interface to normative types (§B.6.1)
- [ ] Add UIDCollisionError to error taxonomy (§19.1)
- [ ] Update conformance tests (§B.3.3)
- [ ] Update hardening checklist (§B.7)

---

## Testing Strategy

### Test Cases

1. **Unique generation:**
   - Generate 10,000 UIDs rapidly
   - Assert all unique

2. **Format validation:**
   ```typescript
   const uid = generator.generateBlockUID();
   expect(uid).toMatch(/^b_[0-9a-z]{16}$/);
   ```

3. **Collision detection:**
   ```typescript
   const twin = new DigitalTwinImpl();
   const block1 = { uid: 'b_1234567890abcdef', ... };
   const block2 = { uid: 'b_1234567890abcdef', ... };

   twin.registerBlock(block1);  // OK
   expect(() => twin.registerBlock(block2)).toThrow(UIDCollisionError);
   ```

4. **Collision retry:**
   - Mock generator to return duplicate on first call
   - Verify retry succeeds with new UID

5. **Distributed generation:**
   - Create generators with different instance IDs
   - Generate 10,000 UIDs from each concurrently
   - Assert no collisions across instances

6. **Temporal ordering:**
   ```typescript
   const uid1 = generator.generateBlockUID();
   await sleep(10);
   const uid2 = generator.generateBlockUID();

   // Extract timestamps
   const ts1 = parseInt(uid1.slice(2, 10), 36);
   const ts2 = parseInt(uid2.slice(2, 10), 36);

   expect(ts2).toBeGreaterThanOrEqual(ts1);
   ```

---

## Migration Impact

**Breaking Change:** Yes - UID format changes from 12 to 16 characters

**Migration Path:**

1. **New schemas:** Use new format automatically
2. **Existing schemas:** Continue working (old format still valid)
3. **Schema migration:** Optional, via `migrateUID()` function

**Adapter Impact:** None - UIDs are opaque strings to adapters

**Cache Impact:** Cache keys include UIDs, so caches will need rebuild after migration (automatic on first miss)

---

## Cross-References

- §B.2.1: UID Requirements
- §B.2.2: Address Resolution
- §16.1: Digital Twin
- §19.1: Error Categories
- §B.3.3: Conformance Test Suite
- §B.6.3: Validation Requirements

---

## Specification Diff

### New Section: §B.2.5

**Location:** After line 2021 (end of §B.2.4)

**Insert:** Full content of §B.2.5 as specified above (~600 lines)

### Modified Section: §B.2.1

**Location:** Line 1950

**Change:** Update UID format description with new spec

### Modified Section: §16.1

**Location:** Line 1505

**Change:** Add uidRegistry field and methods

### Modified Section: §B.6.3

**Location:** Line 2515

**Change:** Update UID regex from 12 to 16 chars

### Modified Section: §B.3.3

**Location:** Line 2100

**Change:** Add 5 UID conformance tests

---

## Resolution Status

- [x] Problem analyzed
- [x] Solution designed
- [x] Specification content written
- [x] Collision probability calculated
- [x] Cross-references identified
- [x] Test cases defined
- [ ] Approved for merge
- [ ] Applied to SPEC document

---

**Resolution Author:** Claude Opus 4.5
**Review Required:** Yes - Critical change affecting data integrity guarantee
