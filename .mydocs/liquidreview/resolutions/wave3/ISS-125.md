# ISS-125: Hardening Appendix - Review Completeness

**Issue Type:** Developer Experience
**Category:** Evidence
**Severity:** Medium
**Status:** Resolved

---

## Problem Statement

Appendix B (Hardening Specification) addresses six critical failure modes but may have gaps:

1. **Missing hardening topics:** Are there other production concerns not covered?
2. **Incomplete subsections:** Do existing sections (B.1-B.6) cover all aspects?
3. **Testing coverage:** Is the hardening checklist (B.7) sufficient?
4. **Cross-cutting concerns:** Security, performance, observability missing?

Developers need confidence that production deployment won't encounter undocumented failure modes.

---

## Resolution

### 1. Hardening Topic Completeness Analysis

**Existing Coverage (B.1-B.6):**
- ✅ B.1: Token efficiency (Unicode → ASCII)
- ✅ B.2: State stability (UID system)
- ✅ B.3: Render safety (testable guarantees)
- ✅ B.4: Transform security (sandboxed DSL)
- ✅ B.5: Reuse validation (coherence gate)
- ✅ B.6: Schema consistency (normative types)

**Missing Production Concerns:**

Add **B.7: Performance Budgets** (renumber existing B.7 to B.8):

```markdown
### B.7 Performance Budgets

**Problem:** No specified performance bounds → unbounded latency in production.

**Solution:** Normative performance budgets with measurement requirements.

#### B.7.1 Latency Budgets

| Operation | P50 | P95 | P99 | Timeout |
|-----------|-----|-----|-----|---------|
| Tier 1: Cache hit | <5ms | <10ms | <20ms | 50ms |
| Tier 2: Semantic search | <30ms | <50ms | <100ms | 200ms |
| Tier 3: Composition | <50ms | <100ms | <150ms | 500ms |
| Tier 4: LLM generation | <200ms | <500ms | <1000ms | 5000ms |
| Compilation | <10ms | <20ms | <50ms | 200ms |
| Validation | <5ms | <10ms | <20ms | 100ms |
| Mutation | <5ms | <10ms | <20ms | 100ms |

#### B.7.2 Memory Budgets

| Component | Heap Limit | Reason |
|-----------|------------|--------|
| Fragment cache | 50MB | ~10K fragments @ 5KB each |
| Vector embeddings | 100MB | ~50K embeddings @ 2KB each |
| Digital twin | 10MB | Current + 100 operation history |
| Compilation workspace | 5MB | Temporary AST + validation |

**Total steady-state:** <200MB

#### B.7.3 Token Budgets

| Operation | Mean | P95 | P99 | Hard Limit |
|-----------|------|-----|-----|------------|
| Generation (L0) | 5 | 8 | 12 | 20 |
| Generation (L1) | 20 | 30 | 40 | 60 |
| Generation (L2) | 10 | 15 | 20 | 30 |
| Mutation | 4 | 8 | 12 | 20 |
| Micro-LLM repair | 5 | 10 | 15 | 25 |

**Total generation budget:** 110 tokens P99

#### B.7.4 Measurement Requirements

Implementations MUST:
1. Instrument all operations with timing metrics
2. Emit P50/P95/P99 latency per operation type
3. Track budget violations (> P99 threshold)
4. Log slow operations for analysis
5. Implement timeout-based cancellation

**Observability:**
```typescript
interface PerformanceMetrics {
  operation: OperationType;
  latencyMs: number;
  tokenCount?: number;
  memoryBytes?: number;
  tier?: ResolutionTier;
  cacheHit?: boolean;
  timestamp: number;
}

// Required metrics export
interface MetricsExporter {
  recordLatency(op: OperationType, ms: number): void;
  recordTokens(op: OperationType, count: number): void;
  recordMemory(component: string, bytes: number): void;
  getHistogram(op: OperationType): Histogram;
}
```
```

Add **B.8: Security Hardening** (renumber existing B.7 to B.9):

```markdown
### B.8 Security Hardening

**Problem:** User-provided data flows through transforms, bindings, and LLM prompts → injection risks.

#### B.8.1 Input Validation

All user-provided strings MUST be validated:

```typescript
interface InputValidator {
  // Selector validation
  validateSelector(selector: string): ValidationResult;

  // Field name validation (prevent injection)
  validateFieldName(field: string): ValidationResult;

  // Transform expression validation
  validateTransform(expr: string): ValidationResult;

  // Signal name validation
  validateSignalName(name: string): ValidationResult;
}

// Validation rules
const FIELD_NAME_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
const SIGNAL_NAME_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
const SELECTOR_PATTERN = /^@(#[a-z_][a-z0-9_]*|\[\d+,\d+\]|[A-Z]+\d*|:\w+|\d+)$/;

// No SQL, no shell metacharacters, no XSS vectors
```

#### B.8.2 LLM Prompt Injection Prevention

User intent flows to LLM prompts. Prevent prompt injection:

```typescript
function sanitizeUserIntent(intent: string): string {
  // 1. Length limit
  if (intent.length > 500) {
    throw new ValidationError('Intent too long (max 500 chars)');
  }

  // 2. Detect prompt injection patterns
  const injectionPatterns = [
    /ignore.*previous.*instructions/i,
    /system.*message/i,
    /act.*as.*different/i,
    /<\|.*\|>/,  // Special tokens
  ];

  for (const pattern of injectionPatterns) {
    if (pattern.test(intent)) {
      throw new SecurityError('Potential prompt injection detected');
    }
  }

  // 3. Escape special tokens
  return intent
    .replace(/<\|/g, '&lt;|')
    .replace(/\|>/g, '|&gt;')
    .replace(/###/g, '# # #');  // Break delimiter patterns
}
```

#### B.8.3 Data Binding Security

Prevent binding to sensitive fields without explicit allow-list:

```typescript
interface DataSourceConfig {
  // Explicit field visibility
  allowedFields: string[];

  // Redaction rules
  redactPatterns?: {
    pattern: RegExp;
    replacement: string;
  }[];

  // Row-level security
  rowFilter?: string;  // LiquidExpr returning boolean
}

// Example
const config: DataSourceConfig = {
  allowedFields: ['revenue', 'orders', 'region'],
  redactPatterns: [
    { pattern: /\d{4}-\d{4}-\d{4}-\d{4}/, replacement: '****-****-****-####' }  // CC
  ],
  rowFilter: '$user_region == @currentUserRegion'
};
```

#### B.8.4 Fragment Cache Isolation

Prevent cache poisoning and cross-tenant leakage:

```typescript
interface CacheKey {
  intentHash: string;
  dataFingerprint: string;

  // REQUIRED: Tenant/user isolation
  tenantId: string;

  // Optional: User-specific preferences
  userId?: string;
}

// Cache MUST namespace by tenantId
// Cross-tenant cache hits MUST be rejected
function getCacheKey(request: GenerationRequest): CacheKey {
  return {
    intentHash: hash(request.intent),
    dataFingerprint: hash(request.dataSchema),
    tenantId: request.tenantId,  // REQUIRED
    userId: request.userId,
  };
}
```

#### B.8.5 Adapter Sandboxing

Adapters render user data → XSS risk. Require sandboxing:

```typescript
interface AdapterSecurityRequirements {
  // Output encoding
  htmlEscape: boolean;         // Escape HTML entities
  jsEscape: boolean;           // Escape JavaScript strings
  urlEscape: boolean;          // Escape URLs

  // CSP compatibility
  noInlineScripts: boolean;    // No inline <script>
  noInlineStyles: boolean;     // No inline style=""

  // Data validation
  validateDataShape: boolean;  // Validate data matches binding
}

// React adapter example
const reactAdapterSecurity: AdapterSecurityRequirements = {
  htmlEscape: true,    // React escapes by default
  jsEscape: true,
  urlEscape: true,
  noInlineScripts: true,
  noInlineStyles: false,  // style prop is safe in React
  validateDataShape: true,
};
```
```

### 2. Cross-Reference Additions

Add cross-cutting concerns to existing sections:

#### Enhance B.3 (Render Guarantee) with Security

Add to **B.3.2 Adapter Conformance**:

```typescript
// Security requirement for adapters
interface LiquidAdapter<T> {
  // ... existing methods ...

  // REQUIRED: Sanitize user data before render
  sanitizeData(data: unknown): unknown;

  // REQUIRED: Report security violations
  onSecurityViolation(violation: SecurityViolation): void;

  // Security metadata
  readonly securityRequirements: AdapterSecurityRequirements;
}
```

#### Enhance B.6 (Schema Spec) with Validation Timing

Add to **B.6.3 Validation Requirements**:

```typescript
/**
 * Validation Timing Requirements
 *
 * Validation MUST occur at these checkpoints:
 *
 * 1. COMPILE TIME: After LiquidCode → LiquidSchema transformation
 *    - Catch syntax errors, type errors, reference errors
 *    - Budget: <20ms P99
 *
 * 2. MUTATION TIME: Before applying operation to digital twin
 *    - Validate operation is legal given current state
 *    - Budget: <10ms P99
 *
 * 3. RENDER TIME: Before passing to adapter
 *    - Final sanity check (should never fail if previous passed)
 *    - Budget: <5ms P99
 *
 * 4. CACHE LOAD: When retrieving fragment from cache
 *    - Verify cache entry hasn't been corrupted
 *    - Budget: <5ms P99
 */

interface ValidationCheckpoint {
  phase: 'compile' | 'mutate' | 'render' | 'cache-load';
  schema: LiquidSchema;
  strictMode: boolean;  // Fail on warnings in production
}

function validate(checkpoint: ValidationCheckpoint): ValidationResult {
  const start = performance.now();

  try {
    const result = LiquidSchemaSchema.parse(checkpoint.schema);

    const elapsed = performance.now() - start;
    recordLatency('validation', elapsed);

    if (elapsed > VALIDATION_TIMEOUT[checkpoint.phase]) {
      logger.warn('Validation timeout exceeded', { phase: checkpoint.phase, elapsed });
    }

    return { success: true, schema: result };
  } catch (error) {
    return { success: false, errors: formatZodErrors(error) };
  }
}
```

### 3. Enhanced Hardening Checklist

Replace **B.7 Hardening Checklist** with comprehensive version (now **B.9**):

```markdown
### B.9 Production Readiness Checklist

Before production deployment, verify:

#### Grammar & Tokenization
- [ ] ASCII grammar produces equivalent results to Unicode
- [ ] P99 token count ≤ 60 for generation, ≤ 15 for mutation
- [ ] Token count measured on actual LLM tokenizer
- [ ] Test corpus of 20+ diverse dashboards

#### State Management
- [ ] All blocks have stable UIDs that survive mutations
- [ ] Positional selectors resolve to UIDs before operation
- [ ] Address resolution is deterministic (same input → same output)
- [ ] Snapshot addressing works for undo/redo

#### Rendering
- [ ] All adapters pass conformance test suite (B.3.3)
- [ ] No adapter throws on any valid schema
- [ ] Placeholder rendering for unsupported blocks
- [ ] Graceful degradation levels defined

#### Security
- [ ] All user input validated (field names, selectors, intents)
- [ ] LLM prompt injection patterns detected and blocked
- [ ] Data binding allow-lists enforced
- [ ] Fragment cache isolated by tenant
- [ ] Adapter output sanitized (XSS prevention)
- [ ] No sensitive fields in default bindings

#### Transform Safety
- [ ] All transforms use LiquidExpr (no free-form code)
- [ ] LiquidExpr execution sandboxed (no I/O, no network)
- [ ] Transform execution timeout enforced (max 1000 ops)
- [ ] Division by zero and null handling tested

#### Reuse & Coherence
- [ ] Coherence gate rejects incoherent fragments
- [ ] Binding coherence checks field existence and types
- [ ] Signal coherence prevents orphaned receivers
- [ ] Micro-LLM repairs are scoped and budgeted

#### Schema Validation
- [ ] Schema validation uses complete Zod schema
- [ ] Canonical ordering produces deterministic hashes
- [ ] Validation occurs at all checkpoints (compile/mutate/render/cache)
- [ ] Validation latency within budgets

#### Performance
- [ ] Latency budgets met: P99 cache <20ms, semantic <100ms, LLM <1000ms
- [ ] Memory usage <200MB steady-state
- [ ] Token budgets tracked and enforced
- [ ] Slow operations logged for analysis
- [ ] Timeout-based cancellation implemented

#### Observability
- [ ] Metrics exported for all operations (latency, tokens, memory)
- [ ] P50/P95/P99 histograms tracked
- [ ] Cache hit rate monitored (target >85%)
- [ ] Error rates tracked by category
- [ ] Security violations logged

#### Error Handling
- [ ] Error messages include resolution path and suggestions
- [ ] All error types defined and documented
- [ ] Graceful degradation levels tested
- [ ] Never-crash guarantee verified

#### Testing
- [ ] Completeness tests: all interface patterns expressible
- [ ] Orthogonality tests: concepts independent
- [ ] Error probability model validated (>95% success)
- [ ] Token reduction verified (>100× vs JSON)
- [ ] 1000+ generation test corpus
```

### 4. Add Performance Testing Framework

Add new subsection **B.7.5 Performance Test Suite**:

```typescript
/**
 * Normative Performance Test Suite
 *
 * All implementations MUST pass these tests before production.
 */

interface PerformanceTest {
  name: string;
  operation: () => Promise<void>;
  budget: LatencyBudget;
  iterations: number;
}

const performanceTests: PerformanceTest[] = [
  {
    name: 'Tier 1: Cache hit',
    operation: async () => {
      const intent = 'Show revenue overview';
      await engine.generate(intent, { data });
    },
    budget: { p50: 5, p95: 10, p99: 20 },
    iterations: 1000,
  },
  {
    name: 'Tier 4: LLM generation',
    operation: async () => {
      const novelIntent = 'Show ' + randomMetric();
      await engine.generate(novelIntent, { data });
    },
    budget: { p50: 200, p95: 500, p99: 1000 },
    iterations: 100,
  },
  {
    name: 'Compilation',
    operation: async () => {
      await compiler.compile(sampleLiquidCode);
    },
    budget: { p50: 10, p95: 20, p99: 50 },
    iterations: 1000,
  },
  {
    name: 'Mutation',
    operation: async () => {
      await engine.mutate('Change the chart type to bar');
    },
    budget: { p50: 5, p95: 10, p99: 20 },
    iterations: 1000,
  },
  {
    name: 'Validation',
    operation: async () => {
      LiquidSchemaSchema.parse(sampleSchema);
    },
    budget: { p50: 5, p95: 10, p99: 20 },
    iterations: 10000,
  },
];

// Test runner
async function runPerformanceTests(): Promise<TestReport> {
  const results: TestResult[] = [];

  for (const test of performanceTests) {
    const latencies: number[] = [];

    for (let i = 0; i < test.iterations; i++) {
      const start = performance.now();
      await test.operation();
      const elapsed = performance.now() - start;
      latencies.push(elapsed);
    }

    latencies.sort((a, b) => a - b);

    const p50 = latencies[Math.floor(latencies.length * 0.5)];
    const p95 = latencies[Math.floor(latencies.length * 0.95)];
    const p99 = latencies[Math.floor(latencies.length * 0.99)];

    const passed = (
      p50 <= test.budget.p50 &&
      p95 <= test.budget.p95 &&
      p99 <= test.budget.p99
    );

    results.push({
      name: test.name,
      passed,
      measured: { p50, p95, p99 },
      budget: test.budget,
    });
  }

  return { results, allPassed: results.every(r => r.passed) };
}
```

---

## Testing Criteria

### Completeness Validation

1. **Gap Analysis:**
   - [ ] All production concerns from review documented
   - [ ] Security, performance, observability covered
   - [ ] Cross-references updated

2. **Checklist Coverage:**
   - [ ] All hardening topics have checklist items
   - [ ] Checklist items are testable (not vague)
   - [ ] Pass criteria clearly defined

3. **Performance Budget Enforcement:**
   - [ ] Budgets defined for all operation types
   - [ ] Measurement framework specified
   - [ ] Test suite runnable and automatable

4. **Security Hardening:**
   - [ ] All input validation points identified
   - [ ] Injection prevention tested
   - [ ] Cache isolation verified

---

## Migration Notes

**Impact:** Medium - New requirements for production deployment
**Compatibility:** Non-breaking - These are production hardening additions

### For Implementers:

1. Review new sections B.7 (Performance) and B.8 (Security)
2. Implement performance instrumentation
3. Add security validation at all input points
4. Run enhanced hardening checklist (B.9)
5. Pass performance test suite before production

### For Users:

No API changes. Enhanced production robustness invisible to users.

---

## References

- **§13** - Tiered Resolution System (performance budgets)
- **§18** - Adapter Interface Contract (security requirements)
- **Appendix B.3** - Testable Render Guarantee
- **Appendix B.4** - Safe Transform DSL
- **Appendix B.6** - Normative LiquidSchema Specification

---

## Resolution Summary

Enhanced Appendix B with:

1. **B.7: Performance Budgets** - Latency, memory, and token budgets with measurement requirements
2. **B.8: Security Hardening** - Input validation, injection prevention, cache isolation
3. **B.9: Enhanced Checklist** - Comprehensive production readiness validation (expanded from 12 to 40+ items)
4. Cross-cutting concerns integrated into existing sections
5. Normative performance test suite

Hardening specification now complete for production deployment.
