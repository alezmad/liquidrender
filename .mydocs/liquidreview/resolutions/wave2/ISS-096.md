# Resolution: ISS-096

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Single-Column Layout Constraint
**Severity:** significant
**Category:** edge-cases
**Target:** SPEC
**Section:** §11 Layout & Responsiveness System

## Problem Statement

Behavior when constraints force single column is undefined. The specification defines responsive breakpoints (§11.11) and grid layouts (§11.6) but does not specify what happens when:

1. Container width forces single-column layout (narrow sidebars, mobile)
2. Grid layout degrades from multi-column to single-column
3. Block relationships (groups, compare) conflict with single-column
4. Priority and visibility rules apply in single-column context
5. Nested grids all become single-column (deep nesting collapse)

Without defined behavior, adapters may:
- Show broken layouts with horizontal overflow
- Violate relationship constraints (e.g., comparison side-by-side becomes stacked)
- Have inconsistent ordering in single-column mode
- Ignore priority when stacking vertically

## Resolution

### Specification Addition

Add the following subsection to §11 Layout & Responsiveness System, after §11.17 Zero and Invalid Dimensions:

#### §11.18 Single-Column Degradation

When container width constraints force single-column layout, the system applies **priority-ordered vertical stacking** while preserving semantic relationships where possible.

**Single-Column Trigger Conditions:**

Single-column layout is triggered when:

```typescript
interface SingleColumnTrigger {
  condition: string;
  threshold: number;
  reason: string;
}

const SINGLE_COLUMN_TRIGGERS: SingleColumnTrigger[] = [
  {
    condition: 'width < minColumnWidth',
    threshold: 320, // Minimum width for meaningful column
    reason: 'Container too narrow for multi-column',
  },
  {
    condition: 'width / desiredColumns < minBlockWidth',
    threshold: 150, // Minimum width per block
    reason: 'Blocks would be too narrow in multi-column',
  },
  {
    condition: 'explicit breakpoint override',
    threshold: 0,
    reason: 'Schema explicitly requests single-column at this breakpoint',
  },
];

function shouldUseSingleColumn(
  context: SlotContext,
  layout: LayoutBlock
): boolean {
  // Check explicit override first
  const breakpointConfig = layout.responsive?.breakpoints?.[context.breakpoint];
  if (breakpointConfig?.columns === 1) {
    return true; // Explicit single-column
  }

  // Check container width
  const minColumnWidth = context.minBlockWidth || 320;
  if (context.width < minColumnWidth) {
    return true; // Too narrow
  }

  // Check if blocks would be too narrow
  const desiredColumns = layout.type === 'grid'
    ? inferGridColumns(layout)
    : 1;
  const widthPerColumn = context.width / desiredColumns;

  if (widthPerColumn < 150) {
    return true; // Blocks too narrow in multi-column
  }

  return false;
}
```

**Single-Column Transformation:**

When single-column is triggered, transform layout from grid/multi-column to vertical stack:

```typescript
interface SingleColumnLayout {
  type: 'stack';
  blocks: Block[];
  order: 'priority' | 'schema' | 'relationship';
  preserveGroups: boolean;
}

function transformToSingleColumn(
  layout: LayoutBlock,
  context: SlotContext
): SingleColumnLayout {
  const blocks = getAllBlocks(layout);

  // Determine ordering strategy
  const order = decideSingleColumnOrder(blocks, layout);

  // Sort blocks according to strategy
  const sorted = sortBlocksForSingleColumn(blocks, order);

  // Preserve relationship groups if possible
  const withGroups = preserveRelationshipGroups(sorted, blocks);

  return {
    type: 'stack',
    blocks: withGroups,
    order,
    preserveGroups: true,
  };
}

function decideSingleColumnOrder(
  blocks: Block[],
  layout: LayoutBlock
): 'priority' | 'schema' | 'relationship' {
  // If priority-heavy (many explicit priorities), use priority order
  const withPriority = blocks.filter(b => b.layout?.priority !== undefined);
  if (withPriority.length > blocks.length / 2) {
    return 'priority';
  }

  // If relationship-heavy (many groups), preserve relationships
  const withRelationships = blocks.filter(b =>
    b.layout?.relationship !== undefined
  );
  if (withRelationships.length > blocks.length / 3) {
    return 'relationship';
  }

  // Default: schema order
  return 'schema';
}
```

**Priority-Based Ordering:**

In single-column mode, priority determines vertical order (top = highest priority):

```typescript
function sortBlocksForSingleColumn(
  blocks: Block[],
  order: 'priority' | 'schema' | 'relationship'
): Block[] {
  if (order === 'priority') {
    return blocks.sort((a, b) => {
      const priorityA = normalizePriority(a.layout?.priority);
      const priorityB = normalizePriority(b.layout?.priority);

      // Lower number = higher priority = earlier in stack
      if (priorityA !== priorityB) {
        return priorityA - priorityB;
      }

      // Tie-breaker: schema order
      return blocks.indexOf(a) - blocks.indexOf(b);
    });
  }

  if (order === 'schema') {
    // Keep original order
    return [...blocks];
  }

  if (order === 'relationship') {
    // Group related blocks together, then sort groups by priority
    return sortByRelationships(blocks);
  }

  return blocks;
}

// Example ordering:
// Priority order: hero → primary → secondary → detail
// Schema order: K0 → K1 → L0 → T0 (as declared)
// Relationship order: [K0 K1]=group → L0 → T0 (groups first)
```

**Relationship Preservation:**

Some relationships can be preserved in single-column, others cannot:

| Relationship | Multi-Column Behavior | Single-Column Behavior |
|--------------|----------------------|------------------------|
| `group` | Stays together spatially | Stays together, stacked vertically |
| `compare` | Side-by-side, same size | Stacked vertically, same width |
| `detail` | Detail below/beside master | Detail immediately after master |
| `flow` | Wraps to next line | Already vertical, no change |

```typescript
function preserveRelationshipGroups(
  sorted: Block[],
  original: Block[]
): Block[] {
  const groups = extractRelationshipGroups(original);
  const result: Block[] = [];
  const grouped = new Set<string>();

  for (const block of sorted) {
    if (grouped.has(block.uid)) continue;

    // Find group containing this block
    const group = groups.find(g =>
      g.blocks.some(b => b.uid === block.uid)
    );

    if (group) {
      // Add all group members together
      for (const member of group.blocks) {
        result.push(member);
        grouped.add(member.uid);
      }
    } else {
      // Independent block
      result.push(block);
      grouped.add(block.uid);
    }
  }

  return result;
}

interface RelationshipGroup {
  type: 'group' | 'compare' | 'detail';
  blocks: Block[];
  priority: number; // Highest priority in group
}
```

**Compare Relationship in Single-Column:**

`compare` relationship (side-by-side) becomes stacked but with visual indicator:

```typescript
interface CompareAdaptation {
  originalRelationship: 'compare';
  singleColumnStrategy: 'stack-with-divider' | 'overlay' | 'tabs';
  preserveSameWidth: boolean;
}

function adaptCompareRelationship(
  blocks: Block[]
): CompareAdaptation {
  return {
    originalRelationship: 'compare',
    singleColumnStrategy: 'stack-with-divider',
    preserveSameWidth: true, // Both blocks get full width
  };
}

// Adapter renders:
// [Block A - full width]
// [--- Compare Divider ---]
// [Block B - full width]
```

**Grid Position Collapse:**

Grid positions (row, column) collapse to single sequence:

```typescript
function collapseGridToSingleColumn(grid: GridLayout): Block[] {
  const blocks = grid.children;

  // Sort by grid position: row-major order (row 0 col 0, row 0 col 1, row 1 col 0, ...)
  const sorted = blocks.sort((a, b) => {
    const posA = getGridPosition(a);
    const posB = getGridPosition(b);

    if (posA.row !== posB.row) {
      return posA.row - posB.row;
    }
    return posA.col - posB.col;
  });

  return sorted;
}

// Example:
// Grid 2x2:  [A B]  →  Single column: [A, B, C, D]
//            [C D]
```

**Span Handling:**

Block spans (§11.6) are ignored in single-column mode:

```typescript
function handleSpanInSingleColumn(block: Block): Block {
  // Remove span specifications (not meaningful in single-column)
  const adapted = { ...block };

  if (adapted.layout?.span) {
    adapted.layout = {
      ...adapted.layout,
      span: undefined, // All blocks full width
    };
  }

  return adapted;
}

// Example:
// Multi-column: L$trend*full (spans all columns)
// Single-column: L$trend (full width - same as all blocks)
```

**Nested Grid Collapse:**

When multiple nested grids all become single-column, flatten where safe:

```typescript
function handleNestedSingleColumn(
  parent: Block,
  children: Block[],
  depth: number
): Block[] {
  const MAX_NESTING = 3; // Beyond this, flatten

  if (depth > MAX_NESTING) {
    // Flatten: hoist nested blocks to parent level
    return flattenNestedBlocks(children);
  }

  // Keep nesting: nested single-columns within parent single-column
  return children;
}

// Example:
// Grid { Grid { Grid { Blocks } } } at depth 4
// → Flatten to: Stack [ Blocks ] (depth 1)
```

**Visibility in Single-Column:**

Priority visibility rules (§11.3) still apply in single-column:

```typescript
function filterVisibleInSingleColumn(
  blocks: Block[],
  breakpoint: Breakpoint
): Block[] {
  return blocks.filter(block => {
    const priority = normalizePriority(block.layout?.priority);
    return isVisibleAtPriority(priority, breakpoint);
  });
}

// Example compact breakpoint (shows only hero):
// Multi-column: [Hero1 Hero2 Hero3] → first hero shown
// Single-column: [Hero1 Hero2 Hero3] → all heroes shown vertically (all are hero priority)
```

**Adapter Rendering:**

Adapters receive single-column layout as a stack:

```typescript
interface LiquidAdapter<RenderOutput> {
  // ... existing methods ...

  // Render single-column stack
  renderStack(
    blocks: Block[],
    context: SlotContext,
    options: StackRenderOptions
  ): RenderOutput;
}

interface StackRenderOptions {
  spacing: 'none' | 'tight' | 'normal' | 'loose';
  dividers: boolean;
  preserveRelationships: boolean;
  order: 'priority' | 'schema' | 'relationship';
}

// Example React adapter:
function renderStack(blocks, context, options) {
  return (
    <Stack spacing={options.spacing} dividers={options.dividers}>
      {blocks.map(block => (
        <StackItem key={block.uid} fullWidth>
          {renderBlock(block, context)}
        </StackItem>
      ))}
    </Stack>
  );
}
```

**Warning System:**

Emit warnings when single-column degrades multi-column semantics:

```typescript
interface SingleColumnWarning {
  severity: 'info';
  code: 'SINGLE_COLUMN_FORCED' | 'COMPARE_DEGRADED' | 'GRID_COLLAPSED';
  message: string;
  affectedBlocks: string[];
}

// Example warnings:
{
  severity: 'info',
  code: 'SINGLE_COLUMN_FORCED',
  message: 'Container width 280px forced single-column layout (minimum: 320px)',
  affectedBlocks: ['all'],
}

{
  severity: 'info',
  code: 'COMPARE_DEGRADED',
  message: 'Compare relationship [L0, B0] degraded to vertical stack in single-column',
  affectedBlocks: ['b_line123', 'b_bar456'],
}
```

### Integration Points

1. **Layout System (§11)** - Single-column transformation integrated into responsive system
2. **Priority System (§11.3)** - Priority order determines stack order
3. **Relationship System (§11.5)** - Groups and compare relationships adapted
4. **Adapter Contract (§18)** - Adapters implement stack rendering
5. **Responsive Breakpoints (§11.11)** - Compact breakpoint often triggers single-column

### Examples

**Example 1: Grid Forced to Single-Column**

```liquidcode
# Grid 2x2 layout
G2x2;K$a!1,K$b!1,L$c!2,T$d!3

# Container width: 280px (< 320px minimum)
# Triggers single-column

# Transformation:
# Grid 2x2: [K$a K$b]  →  Single-column: [K$a]  (priority 1)
#           [L$c T$d]                     [K$b]  (priority 1)
#                                         [L$c]  (priority 2)
#                                         [T$d]  (priority 3)

# Order: priority (both K blocks are priority 1, schema order breaks tie)
# Rendered: Vertical stack, full width each
```

**Example 2: Compare Relationship Degraded**

```liquidcode
# Two charts side-by-side for comparison
[L$actual B$forecast]=compare

# Single-column mode (narrow container)
# Cannot show side-by-side

# Adaptation:
# - Stack vertically
# - Add visual divider
# - Preserve same width (both full width)

# Rendered:
# ┌─────────────────────┐
# │ Line Chart: Actual  │
# ├─────────────────────┤ ← Divider
# │ Bar Chart: Forecast │
# └─────────────────────┘
```

**Example 3: Grouped Blocks Preserved**

```liquidcode
# Three KPIs grouped together
[K$rev!1 K$ord!2 K$profit!3]=group
L$trend!1

# Single-column mode
# Group stays together despite different priorities

# Order: relationship (preserves groups)
# Rendered:
# [K$rev]    ← Group
# [K$ord]    ← Group
# [K$profit] ← Group
# [L$trend]  ← Independent

# (Not: [K$rev, L$trend, K$ord, K$profit] - priority order would break group)
```

**Example 4: Nested Grids Collapse**

```liquidcode
# Nested grids (depth 4)
G{G{G{G{K$a,K$b,K$c}}}}

# Single-column forced at all levels
# Nesting depth > 3 → flatten

# Transformation:
# Flatten to: Stack[K$a, K$b, K$c]

# Rendered:
# [K$a]
# [K$b]
# [K$c]

# (Not: Stack{Stack{Stack{Stack{...}}}} - too deeply nested)
```

**Example 5: Priority Visibility in Single-Column**

```liquidcode
# Five blocks, different priorities
K$a!hero
K$b!primary
K$c!primary
L$d!secondary
T$e!detail

# Compact breakpoint (shows only hero)
# Single-column

# Visible blocks: K$a only (hero)
# Rendered:
# [K$a]

# Standard breakpoint (shows hero + primary)
# Visible blocks: K$a, K$b, K$c
# Rendered:
# [K$a]  ← hero
# [K$b]  ← primary
# [K$c]  ← primary
```

**Example 6: Span Ignored**

```liquidcode
# Chart spans full width in multi-column
G2x2;K$a,K$b,L$trend*full,T$data

# Single-column mode
# Span is meaningless (all blocks full width)

# Rendered:
# [K$a]       ← full width
# [K$b]       ← full width
# [L$trend]   ← full width (span ignored)
# [T$data]    ← full width
```

## Verification Checklist

- [x] **All single-column triggers defined**
  - Container too narrow
  - Blocks would be too narrow in multi-column
  - Explicit breakpoint override
- [x] **Transformation algorithm**
  - Grid collapse to stack
  - Priority-based ordering
  - Relationship preservation
  - Nested grid flattening
- [x] **Relationship adaptation**
  - Groups stay together
  - Compare becomes stacked
  - Detail follows master
  - Flow unchanged
- [x] **Priority and visibility**
  - Priority order in stack
  - Visibility rules still apply
  - Ordinal tie-breaker
- [x] **Graceful degradation**
  - No broken layouts
  - No horizontal overflow
  - Clear visual hierarchy
- [x] **Warning system**
  - Inform when degrading
  - Explain what changed
  - Suggest alternatives

## Confidence

**HIGH** - This resolution:

1. **Addresses root cause** - Defines complete single-column transformation for all layout types
2. **Preserves semantics** - Priority, relationships, visibility rules still apply in single-column
3. **Graceful degradation** - Multi-column layouts adapt smoothly to single-column constraints
4. **User-friendly** - Clear vertical hierarchy, no broken layouts
5. **Testable** - Deterministic transformation with specific ordering rules
6. **Follows spec patterns** - Uses priority (§11.3), relationships (§11.5), breakpoints (§11.11)
7. **Adapter-friendly** - Simple stack rendering, full-width blocks
8. **Performance-conscious** - Flattens deep nesting to avoid rendering overhead
