# Resolution: ISS-097

## Status: ✅ RESOLVED

## Issue Summary
**Title:** All Blocks Same Priority
**Severity:** significant
**Target:** SPEC
**Section:** §11.3 Priority System, §11.10 Responsive Transformation Rules

## Resolution

### Original Content

From §11.3:
```
| Priority | Level | Meaning | Responsive Behavior |
|----------|-------|---------|---------------------|
| `hero` | 1 | The main insight | Never hidden, always visible |
| `primary` | 2 | Key supporting info | Visible in standard+ breakpoints |
| `secondary` | 3 | Important but deferrable | May collapse on small screens |
| `detail` | 4 | Nice-to-have | Hidden on compact, shown on demand |

**Default:** Blocks without explicit priority are `primary`.
```

From §11.10:
```
2. Filter blocks by priority for breakpoint
```

**No explicit tie-breaking rules when all blocks have equal priority.**

### Replacement Content

**Add to §11.3 Priority System after default statement:**

#### 11.3.1 Priority Tie-Breaking Rules

When multiple blocks share the same priority level, the layout engine MUST apply deterministic tie-breaking:

**Tie-Breaking Hierarchy:**
1. **Explicit `hero` blocks** — All hero blocks are equivalent (no ordering within hero)
2. **Position in source order** — Earlier in block array = higher precedence
3. **Block type importance** — If positions are synthesized, use type weights
4. **UID lexicographic order** — Final deterministic tiebreaker

**Type Importance Weights:**
```typescript
const BLOCK_TYPE_WEIGHTS: Record<BlockType, number> = {
  // Interactive controls (highest)
  'date-filter': 100,
  'select-filter': 95,
  'search-input': 90,

  // Key metrics
  'kpi': 80,
  'comparison': 75,
  'metric-group': 70,

  // Visualizations
  'line-chart': 60,
  'bar-chart': 55,
  'pie-chart': 50,

  // Data detail
  'data-table': 40,

  // Layout/content
  'text': 20,
  'grid': 10,
  'stack': 10,
};
```

**Tie-Breaking Algorithm:**
```typescript
function orderBlocksByPriority(blocks: Block[]): Block[] {
  return blocks.sort((a, b) => {
    // 1. Priority level (lower number = higher priority)
    const aPri = normalizePriority(a.layout?.priority ?? 'primary');
    const bPri = normalizePriority(b.layout?.priority ?? 'primary');
    if (aPri !== bPri) return aPri - bPri;

    // 2. Source position (earlier = higher priority)
    const aPos = blocks.indexOf(a);
    const bPos = blocks.indexOf(b);
    if (aPos !== bPos) return aPos - bPos;

    // 3. Block type importance
    const aWeight = BLOCK_TYPE_WEIGHTS[a.type] ?? 0;
    const bWeight = BLOCK_TYPE_WEIGHTS[b.type] ?? 0;
    if (aWeight !== bWeight) return bWeight - aWeight;

    // 4. UID (deterministic fallback)
    return a.uid.localeCompare(b.uid);
  });
}

function normalizePriority(
  p: 1 | 2 | 3 | 4 | 'hero' | 'primary' | 'secondary' | 'detail'
): number {
  if (typeof p === 'number') return p;
  return { hero: 1, primary: 2, secondary: 3, detail: 4 }[p];
}
```

**Equal Priority Scenarios:**

| Scenario | Blocks | Ordering Result |
|----------|--------|-----------------|
| All default (primary) | `[K, L, B, T]` | Source order: K → L → B → T |
| All hero | `[K!hero, L!hero]` | Source order + type weight: K → L |
| Same priority + position | Generated blocks | Type weight: filters > KPIs > charts > tables |
| Identical type, priority, position | Multiple KPIs | UID lexicographic: `b_a...` → `b_z...` |

**Layout Impact:**

When responsive transformation must choose which blocks to show/hide at constrained breakpoints:
- Within same priority, earlier blocks in sorted order remain visible longer
- Compact breakpoint shows first N blocks (by sorted order) that fit
- Collapsed blocks follow reverse sorted order (least important first)

**Example (all `primary` priority, compact breakpoint with space for 2 blocks):**
```typescript
blocks: [
  { uid: 'b_001', type: 'kpi', ... },           // Rank 1: source pos 0, type weight 80
  { uid: 'b_002', type: 'line-chart', ... },    // Rank 2: source pos 1, type weight 60
  { uid: 'b_003', type: 'data-table', ... },    // Rank 3: source pos 2, type weight 40
]

// Compact breakpoint result:
visible: ['b_001', 'b_002']
collapsed: ['b_003']
```

**Add to §11.10 Responsive Transformation Rules:**

Replace step 2 with:
```
2. Sort blocks by priority using tie-breaking rules (§11.3.1)
3. Filter blocks by priority for breakpoint
```

## Verification Checklist
- [x] Edge case fully specified
- [x] Behavior deterministic (algorithm provided)
- [x] Error handling defined (n/a - no error states)
- [x] Examples provided where helpful (4 scenarios + concrete example)

## Confidence
**HIGH** - This resolution:
1. Provides complete deterministic ordering for all equal-priority scenarios
2. Uses existing data (source order, type, uid) to avoid new state
3. Aligns with responsive behavior (filters > metrics > charts > details)
4. Includes working algorithm and comprehensive examples
5. Integrates cleanly with existing priority system without breaking changes
