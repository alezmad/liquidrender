# ISS-131: Resolution Tiers Underspecified - Complete Tier Definitions

**Issue Type:** Developer Experience
**Category:** Evidence
**Severity:** Medium
**Status:** Resolved

---

## Problem Statement

Section 13 (Tiered Resolution System) describes four tiers but lacks:

1. **Tier transition logic** - When to fall through to next tier
2. **Tier-specific algorithms** - Exact matching/composition logic
3. **Fallback strategies** - What if all tiers fail
4. **Tier performance tracking** - How to measure effectiveness

---

## Resolution

### 1. Complete Tier Specifications

Add to **§13.1 Resolution Hierarchy**:

```typescript
/**
 * ═══════════════════════════════════════════════════════════════
 * TIER-BY-TIER RESOLUTION SPECIFICATION
 * ═══════════════════════════════════════════════════════════════
 */

// ─────────────────────────────────────────────────────────────────
// TIER 1: EXACT CACHE HIT
// ─────────────────────────────────────────────────────────────────

async function tier1_exactCacheHit(
  intent: string,
  fingerprint: DataFingerprint
): Promise<ResolutionResult | null> {
  const startTime = performance.now();

  // 1. Normalize intent
  const normalizedIntent = normalizeIntent(intent);

  // 2. Compute cache key
  const key: CacheKey = {
    intentHash: hash(normalizedIntent),
    dataFingerprint: fingerprint.schemaHash,
    scope: 'interface',
    tenantId: context.tenantId,
  };

  // 3. Lookup
  const fragment = await fragmentCache.get(key);

  if (fragment) {
    return {
      tier: 1,
      schema: fragment.fragment,
      latencyMs: performance.now() - startTime,
      cacheHit: true,
      confidence: 1.0,
      source: { type: 'cache-hit', fragmentKey: key },
    };
  }

  return null;  // Fall through to Tier 2
}

function normalizeIntent(intent: string): string {
  return intent
    .toLowerCase()
    .trim()
    .replace(/\s+/g, ' ')  // Normalize whitespace
    .replace(/^(show|display|view|give me)\s+/i, '')  // Remove common prefixes
    .replace(/\s+(please|thanks)$/i, '');  // Remove politeness
}

// ─────────────────────────────────────────────────────────────────
// TIER 2: SEMANTIC SEARCH
// ─────────────────────────────────────────────────────────────────

async function tier2_semanticSearch(
  intent: string,
  fingerprint: DataFingerprint
): Promise<ResolutionResult | null> {
  const startTime = performance.now();

  // 1. Embed intent
  const embedding = await embedIntent(intent);

  // 2. Search vector store
  const matches = await fragmentCache.search(embedding, 10);

  // 3. Filter by schema compatibility
  const compatible = matches.filter(m =>
    isSchemaSimilar(m.fragment.dataFingerprint, fingerprint.schemaHash)
  );

  if (compatible.length === 0) return null;

  // 4. Take best match
  const best = compatible[0];

  // 5. Check similarity threshold
  if (best.similarity < 0.85) return null;  // Too different

  // 6. Compute adaptations
  const adaptations = computeAdaptations(best.fragment, fingerprint);

  // 7. Check adaptation complexity
  if (adaptations.every(a => a.type === 'label' || a.type === 'format')) {
    // Only L2 changes - safe to adapt
    const adapted = applyAdaptations(best.fragment, adaptations);

    return {
      tier: 2,
      schema: adapted,
      latencyMs: performance.now() - startTime,
      cacheHit: false,
      confidence: best.similarity,
      source: {
        type: 'semantic-match',
        similarity: best.similarity,
        matchedFragment: best.key,
        adaptations,
      },
    };
  }

  return null;  // Adaptations too complex, fall through
}

async function embedIntent(intent: string): Promise<number[]> {
  // Use small embedding model (e.g., all-MiniLM-L6-v2)
  // 384-dimensional vector
  const response = await embeddingModel.embed(intent);
  return response.embedding;
}

function computeAdaptations(
  fragment: FragmentContent,
  fingerprint: DataFingerprint
): Adaptation[] {
  const adaptations: Adaptation[] = [];

  // Check each block's binding
  for (const block of fragment.blocks) {
    if (!block.binding) continue;

    for (const fieldBinding of block.binding.fields) {
      const field = fieldBinding.field;

      // Check if field exists in new data
      if (!fingerprint.fields.some(f => f.name === field)) {
        // Find similar field
        const similar = findSimilarField(field, fingerprint.fields);

        if (similar && similar.similarity > 0.8) {
          adaptations.push({
            type: 'binding',
            target: block.uid,
            change: { from: field, to: similar.field.name },
          });
        } else {
          // Can't adapt - binding mismatch
          return [{ type: 'binding', target: block.uid, change: 'incompatible' }];
        }
      }
    }
  }

  return adaptations;
}

// ─────────────────────────────────────────────────────────────────
// TIER 3: FRAGMENT COMPOSITION
// ─────────────────────────────────────────────────────────────────

async function tier3_fragmentComposition(
  intent: string,
  fingerprint: DataFingerprint,
  archetype: ArchetypeDetection
): Promise<ResolutionResult | null> {
  const startTime = performance.now();

  // 1. Find composition rule
  const rule = findCompositionRule(intent, archetype, fingerprint);

  if (!rule) return null;

  // 2. Retrieve fragments
  const fragments = await Promise.all(
    rule.fragments.map(ref => fragmentCache.get(ref.selector))
  );

  if (fragments.some(f => !f)) return null;  // Missing fragment

  // 3. Compose
  const schema = composeFragments(fragments, rule);

  // 4. Validate composition
  const valid = validate(schema, false);
  if (!valid.valid) return null;  // Composition failed

  return {
    tier: 3,
    schema,
    latencyMs: performance.now() - startTime,
    cacheHit: false,
    confidence: 0.8,
    source: {
      type: 'composition',
      composedFragments: rule.fragments.map(f => f.selector),
      compositionRule: rule,
    },
  };
}

function findCompositionRule(
  intent: string,
  archetype: ArchetypeDetection,
  fingerprint: DataFingerprint
): CompositionRule | null {
  // Match against known patterns
  const patterns = compositionRules[archetype.archetype];

  for (const pattern of patterns) {
    if (matchesIntentPattern(intent, pattern.pattern, fingerprint)) {
      return pattern;
    }
  }

  return null;
}

function composeFragments(
  fragments: CachedFragment[],
  rule: CompositionRule
): LiquidSchema {
  // 1. Start with layout
  const layout = inferLayout(fragments.length, rule.layout);

  // 2. Collect blocks
  const blocks = fragments.flatMap(f => f.fragment.blocks);

  // 3. Wire signals
  const signals = wireSignals(blocks, rule.signals);

  // 4. Assemble schema
  return {
    version: '2.0',
    scope: 'interface',
    uid: generateUID('s'),
    title: inferTitle(fragments),
    generatedAt: new Date().toISOString(),
    layout,
    blocks,
    signals,
  };
}

// ─────────────────────────────────────────────────────────────────
// TIER 4: LLM GENERATION
// ─────────────────────────────────────────────────────────────────

async function tier4_llmGeneration(
  intent: string,
  fingerprint: DataFingerprint,
  archetype: ArchetypeDetection
): Promise<ResolutionResult> {
  const startTime = performance.now();

  // 1. Construct prompt
  const prompt = buildGenerationPrompt(intent, fingerprint, archetype);

  // 2. Call LLM (scoped, minimal)
  const liquidCode = await llm.complete(prompt, {
    maxTokens: 100,
    temperature: 0.3,
    stop: ['\n\n'],
  });

  // 3. Compile
  const compilationResult = compiler.compile(liquidCode, {
    source: liquidCode,
    dataFingerprint: fingerprint,
    mode: 'generation',
  });

  if (!compilationResult.success) {
    // Retry once with error feedback
    const retryPrompt = buildRetryPrompt(prompt, compilationResult.errors);
    const retryCode = await llm.complete(retryPrompt, { maxTokens: 100 });
    const retryResult = compiler.compile(retryCode, {
      source: retryCode,
      dataFingerprint: fingerprint,
      mode: 'generation',
    });

    if (!retryResult.success) {
      // Fall back to safe template
      return tier4_fallbackTemplate(fingerprint, archetype);
    }

    return {
      tier: 4,
      schema: retryResult.schema!,
      latencyMs: performance.now() - startTime,
      cacheHit: false,
      confidence: 0.6,
      source: {
        type: 'llm-generation',
        prompt: retryPrompt,
        model: llm.model,
        tokenCount: retryCode.length,
      },
    };
  }

  return {
    tier: 4,
    schema: compilationResult.schema!,
    latencyMs: performance.now() - startTime,
    cacheHit: false,
    confidence: 0.7,
    source: {
      type: 'llm-generation',
      prompt,
      model: llm.model,
      tokenCount: liquidCode.length,
    },
  };
}

function buildGenerationPrompt(
  intent: string,
  fingerprint: DataFingerprint,
  archetype: ArchetypeDetection
): string {
  return `Generate LiquidCode for: "${intent}"

Data fields:
${fingerprint.fields.map(f => `- ${f.name} (${f.primitive})`).join('\n')}

Archetype: ${archetype.archetype}

Output LiquidCode only:`;
}

// ─────────────────────────────────────────────────────────────────
// FALLBACK: SAFE TEMPLATE
// ─────────────────────────────────────────────────────────────────

function tier4_fallbackTemplate(
  fingerprint: DataFingerprint,
  archetype: ArchetypeDetection
): ResolutionResult {
  // Generate safe, generic schema
  const metrics = fingerprint.fields.filter(f =>
    ['currency', 'count', 'percentage'].includes(f.primitive)
  ).slice(0, 4);

  const blocks: Block[] = metrics.map(field => ({
    uid: generateUID('b'),
    type: 'kpi',
    binding: {
      source: 'data',
      fields: [{ target: 'value', field: field.name }],
    },
  }));

  return {
    tier: 4,
    schema: {
      version: '2.0',
      scope: 'interface',
      uid: generateUID('s'),
      title: 'Data Overview',
      generatedAt: new Date().toISOString(),
      layout: {
        type: 'grid',
        uid: generateUID('b'),
        config: { type: 'grid', columns: 2 },
        children: blocks,
      },
      blocks,
    },
    latencyMs: 0,
    cacheHit: false,
    confidence: 0.5,
    source: {
      type: 'llm-generation',
      prompt: 'FALLBACK',
      model: 'template',
      tokenCount: 0,
    },
  };
}

// ─────────────────────────────────────────────────────────────────
// TIERED RESOLUTION ORCHESTRATOR
// ─────────────────────────────────────────────────────────────────

export async function resolveIntent(
  intent: string,
  fingerprint: DataFingerprint
): Promise<ResolutionResult> {
  // Tier 1: Exact cache hit
  const tier1 = await tier1_exactCacheHit(intent, fingerprint);
  if (tier1) return tier1;

  // Tier 2: Semantic search
  const tier2 = await tier2_semanticSearch(intent, fingerprint);
  if (tier2) return tier2;

  // Detect archetype (needed for Tier 3 & 4)
  const archetype = detectArchetype(fingerprint);

  // Tier 3: Fragment composition
  const tier3 = await tier3_fragmentComposition(intent, fingerprint, archetype);
  if (tier3) return tier3;

  // Tier 4: LLM generation (always succeeds via fallback)
  return tier4_llmGeneration(intent, fingerprint, archetype);
}
```

### 2. Tier Performance Tracking

Add to **§13.5 Tier Metrics**:

```typescript
interface TierMetrics {
  tier: ResolutionTier;
  attempts: number;
  successes: number;
  failures: number;
  latencyHistogram: Histogram;
  confidenceHistogram: Histogram;
}

class TierMonitor {
  private metrics: Map<ResolutionTier, TierMetrics> = new Map();

  recordResolution(result: ResolutionResult): void {
    const metric = this.metrics.get(result.tier) || this.initMetric(result.tier);

    metric.attempts++;
    if (result.schema) metric.successes++;
    else metric.failures++;

    updateHistogram(metric.latencyHistogram, result.latencyMs);
    updateHistogram(metric.confidenceHistogram, result.confidence);
  }

  getEffectiveness(tier: ResolutionTier): number {
    const metric = this.metrics.get(tier);
    if (!metric || metric.attempts === 0) return 0;

    return metric.successes / metric.attempts;
  }

  getCacheHitRate(): number {
    const tier1 = this.metrics.get(1);
    const total = Array.from(this.metrics.values())
      .reduce((sum, m) => sum + m.attempts, 0);

    return tier1 ? tier1.successes / total : 0;
  }
}
```

---

## Resolution Summary

Complete tier specification:
1. **Tier 1-4 algorithms** - Exact implementations
2. **Transition logic** - When to fall through
3. **Fallback template** - Never-fail guarantee
4. **Performance tracking** - Tier effectiveness monitoring
