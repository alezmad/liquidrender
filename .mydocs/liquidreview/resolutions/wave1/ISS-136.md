# Resolution: ISS-136

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Add Implementation Guide Document
**Severity:** Minor
**Target:** SPEC
**Section:** New Appendix C

## Resolution

### Original Content (Lines N/A)
```markdown
[No implementation guide currently exists in the specification]
```

### Replacement Content
```markdown
## Appendix C: Implementation Guide

This appendix provides a structured guide for implementing the LiquidCode v2 system from scratch.

### C.1 Implementation Phases

#### C.1.1 Phase Overview

| Phase | Component | Dependencies | Estimated Effort |
|-------|-----------|--------------|------------------|
| 1 | Core Schema & Validation | None | 1 week |
| 2 | LiquidCode Parser | Phase 1 | 2 weeks |
| 3 | Compiler Pipeline | Phases 1-2 | 2 weeks |
| 4 | Block Addressing System | Phase 1 | 1 week |
| 5 | Binding System | Phases 1, 3 | 2 weeks |
| 6 | Signal System | Phases 1, 3 | 1 week |
| 7 | Discovery Engine | Phases 1, 5 | 3 weeks |
| 8 | Fragment Cache | Phases 1, 3 | 2 weeks |
| 9 | Tiered Resolution | Phases 7-8 | 2 weeks |
| 10 | Layout System | Phase 3 | 2 weeks |
| 11 | Digital Twin & State | Phases 1, 4 | 1 week |
| 12 | Adapter Interface | All | 2 weeks |
| 13 | LLM Integration | Phases 2, 9 | 3-4 weeks |

**Total Estimated Timeline:** 16-20 weeks for complete implementation

#### C.1.2 Minimum Viable Implementation (MVI)

For rapid prototyping, implement in this reduced order:
1. Core Schema (Phase 1)
2. Parser (Phase 2)
3. Compiler (Phase 3)
4. Basic Adapter (Phase 12, simplified)
5. Manual LiquidCode generation (skip Phases 7-9, 13 initially)

**MVI Timeline:** 4-6 weeks

---

### C.2 Implementation Starting Points

#### C.2.1 Phase 1: Core Schema & Validation

**Goal:** Establish type-safe foundation

**Components to implement:**
- TypeScript interfaces (§B.6.1)
- Zod validation schemas (§B.6.3)
- JSON Schema for external tools (§B.6.4)
- Canonical ordering function (§B.6.2)

**Starting files:**
```typescript
// src/schema/types.ts
export interface LiquidSchema { /* from §B.6.1 */ }
export interface Block { /* from §B.6.1 */ }
// ... all schema types

// src/schema/validation.ts
import { z } from 'zod';
export const LiquidSchemaSchema = z.object({ /* from §B.6.3 */ });

// src/schema/canonical.ts
export function canonicalize(schema: LiquidSchema): string { /* from §B.6.2 */ }
```

**Validation criteria:**
- [ ] All schema types defined
- [ ] Zod validation catches invalid schemas
- [ ] Canonical ordering produces deterministic hashes
- [ ] No runtime errors on valid schemas

**Reference sections:** §B.6

---

#### C.2.2 Phase 2: LiquidCode Parser

**Goal:** Convert LiquidCode text to AST

**Components to implement:**
- Tokenizer (§6, Appendix B.1)
- Parser (PEG grammar from enhancement suggestions)
- AST node types
- Error reporting

**Starting files:**
```typescript
// src/parser/tokenizer.ts
export function tokenize(code: string): Token[] { /* §6.1 */ }

// src/parser/parser.ts
export function parse(tokens: Token[]): AST { /* §6, §17.1 */ }

// src/parser/ast.ts
export interface ASTNode { /* define AST structure */ }
```

**Validation criteria:**
- [ ] Parses all example LiquidCode from spec
- [ ] Handles ASCII and Unicode forms (§B.1)
- [ ] Clear error messages for syntax errors
- [ ] AST is complete and unambiguous

**Reference sections:** §6, §17.1, Appendix B.1

**Known gaps to fill:**
- Formal PEG grammar (see Gap 2 in Implementation Gaps review)
- Tokenization state machine
- Error recovery strategy

---

#### C.2.3 Phase 3: Compiler Pipeline

**Goal:** Transform AST to validated LiquidSchema

**Components to implement:**
- Semantic analyzer (§17.1)
- Schema generator (§17.1)
- UID generator (§B.2)
- Layout resolver
- Parallel tree compilation (§17.2)

**Starting files:**
```typescript
// src/compiler/semantic.ts
export function analyze(ast: AST): ValidatedAST { /* §17.1 */ }

// src/compiler/generator.ts
export function generate(ast: ValidatedAST): LiquidSchema { /* §17.1 */ }

// src/compiler/uid.ts
export function generateUID(): string { /* §B.2.1 */ }
```

**Validation criteria:**
- [ ] All valid ASTs compile to valid schemas
- [ ] UIDs are stable and unique
- [ ] Compilation is deterministic
- [ ] Parallel compilation produces identical results

**Reference sections:** §17

---

#### C.2.4 Phase 4: Block Addressing System

**Goal:** Resolve selectors to UIDs

**Components to implement:**
- Address parser (§8.2)
- Resolution algorithm (§8.3, §B.2.2)
- Wildcard support (§8.4)
- Snapshot addressing (§8.5)

**Starting files:**
```typescript
// src/addressing/resolver.ts
export function resolveAddress(
  selector: string,
  schema: LiquidSchema
): string[] { /* §8.3, §B.2.2 */ }

// src/addressing/wildcard.ts
export function resolveWildcard(
  pattern: string,
  schema: LiquidSchema
): string[] { /* §8.4 */ }
```

**Validation criteria:**
- [ ] All address forms resolve correctly
- [ ] Resolution is stable across mutations
- [ ] Wildcards match expected blocks
- [ ] Ambiguous selectors are detected

**Reference sections:** §8, §B.2

---

#### C.2.5 Phase 5: Binding System

**Goal:** Connect blocks to data with soft constraints

**Components to implement:**
- Data fingerprinting (§12.2, §12.4)
- Binding suggestion (§9.3)
- Scoring algorithm (§9.3)
- Type compatibility (§9.2)

**Starting files:**
```typescript
// src/binding/fingerprint.ts
export function fingerprintData(data: any): DataFingerprint { /* §12.2 */ }

// src/binding/suggestion.ts
export function suggestBindings(
  blockType: BlockType,
  fingerprint: DataFingerprint
): BindingSuggestion[] { /* §9.3 */ }

// src/binding/scoring.ts
export function scoreBinding(
  field: string,
  slot: BindingSlot,
  context: ScoringContext
): number { /* §9.3 */ }
```

**Validation criteria:**
- [ ] Suggestions score correctly for common patterns
- [ ] Type mismatches are detected
- [ ] Semantic matching works for standard field names
- [ ] User explicit bindings always take precedence

**Reference sections:** §9, §12.4

**Known gaps to fill:**
- Semantic matching algorithm (see Gap 3 in Implementation Gaps review)
- Weight combination formula
- Training data for semantic model

---

#### C.2.6 Phase 6: Signal System

**Goal:** Reactive state management

**Components to implement:**
- Signal registry (§10.2)
- Signal runtime (§18.3)
- Persistence (§10.2, enhancement needed)
- Inheritance (§10.7)

**Starting files:**
```typescript
// src/signals/registry.ts
export class SignalRegistry { /* §10.2 */ }

// src/signals/runtime.ts
export class SignalRuntime implements SignalRuntime { /* §18.3 */ }

// src/signals/persistence.ts
export function serializeSignal(signal: any, type: SignalType): string { }
export function deserializeSignal(value: string, type: SignalType): any { }
```

**Validation criteria:**
- [ ] Signals emit and propagate correctly
- [ ] Persistence works for all storage types
- [ ] Inheritance follows defined modes
- [ ] No circular dependency deadlocks

**Reference sections:** §10, §18.3

**Known gaps to fill:**
- Persistence serialization format (see Gap 5 in Implementation Gaps review)
- URL encoding strategy
- Restoration order

---

#### C.2.7 Phase 7: Discovery Engine

**Goal:** Predict archetypes and pre-generate fragments

**Components to implement:**
- Schema fingerprinting (§12.2)
- UOM primitive inference (§12.4)
- Archetype detection (§12.3)
- Intent prediction (§12.5)

**Starting files:**
```typescript
// src/discovery/fingerprint.ts
export function fingerprintSchema(data: any): SchemaFingerprint { /* §12.2 */ }

// src/discovery/primitives.ts
export function inferPrimitives(fingerprint: SchemaFingerprint): Primitive[] { /* §12.4 */ }

// src/discovery/archetypes.ts
export function detectArchetypes(primitives: Primitive[]): Archetype[] { /* §12.3 */ }

// src/discovery/intent.ts
export function predictIntents(archetypes: Archetype[]): Intent[] { /* §12.5 */ }
```

**Validation criteria:**
- [ ] Common data patterns are recognized
- [ ] Archetype detection is accurate (>80%)
- [ ] Intent predictions are useful
- [ ] Pre-generation completes in <30s

**Reference sections:** §12

**Known gaps to fill:**
- Archetype detection heuristics (see Gap 7 in Implementation Gaps review)
- "Top 20 intents" selection criteria

---

#### C.2.8 Phase 8: Fragment Cache

**Goal:** Store and retrieve reusable fragments

**Components to implement:**
- Cache storage (§14.2)
- Cache key generation (§13.2)
- Semantic search (§13.3)
- Warming strategy (§14.3)
- Invalidation (§14.4)

**Starting files:**
```typescript
// src/cache/storage.ts
export class FragmentStorage implements FragmentStorage { /* §14.2 */ }

// src/cache/keys.ts
export function generateCacheKey(context: CacheContext): CacheKey { /* §13.2 */ }

// src/cache/semantic.ts
export async function semanticSearch(
  embedding: number[],
  limit: number
): Promise<SemanticMatch[]> { /* §13.3 */ }

// src/cache/warming.ts
export async function warmCache(fingerprint: DataFingerprint): Promise<void> { /* §14.3 */ }
```

**Validation criteria:**
- [ ] Cache hits return correct fragments
- [ ] Semantic search finds similar intents
- [ ] Warming completes without blocking
- [ ] Invalidation works correctly

**Reference sections:** §14

**Known gaps to fill:**
- Cache key design details (see Gap 8 in Implementation Gaps review)
- Embedding model selection
- TTL strategies

---

#### C.2.9 Phase 9: Tiered Resolution

**Goal:** Minimize LLM calls through caching and composition

**Components to implement:**
- Tier 1: Exact cache (§13.1)
- Tier 2: Semantic search (§13.1)
- Tier 3: Fragment composition (§15)
- Tier 4: LLM generation (§13.1, §13.4)
- Coherence gate (§B.5)

**Starting files:**
```typescript
// src/resolution/tiers.ts
export async function resolveTier1(intent: Intent): Promise<Fragment | null> { }
export async function resolveTier2(intent: Intent): Promise<Fragment | null> { }
export async function resolveTier3(intent: Intent): Promise<Fragment | null> { }
export async function resolveTier4(intent: Intent): Promise<Fragment> { }

// src/resolution/coherence.ts
export function checkCoherence(
  fragment: CachedFragment,
  context: CoherenceContext
): CoherenceResult { /* §B.5 */ }
```

**Validation criteria:**
- [ ] 85%+ queries hit cache (Tier 1/2)
- [ ] Composition produces valid schemas
- [ ] Coherence gate rejects bad matches
- [ ] LLM tier is last resort only

**Reference sections:** §13, §15, §B.5

**Known gaps to fill:**
- Fragment composition algorithm (see Gap 4 in Implementation Gaps review)
- Coherence validation algorithm (see Gap 6 in Implementation Gaps review)

---

#### C.2.10 Phase 10: Layout System

**Goal:** Semantic constraints, adapter-specific resolution

**Components to implement:**
- Priority system (§11.3)
- Flexibility system (§11.4)
- Relationship system (§11.5)
- Responsive transformation (§11.11)
- Constraint solver (§11.11)

**Starting files:**
```typescript
// src/layout/constraints.ts
export function applyLayoutConstraints(
  schema: LiquidSchema,
  context: SlotContext
): LayoutPlan { /* §11.11 */ }

// src/layout/responsive.ts
export function transformForBreakpoint(
  schema: LiquidSchema,
  breakpoint: Breakpoint
): LiquidSchema { /* §11.11 */ }

// src/layout/solver.ts
export function solveLayout(constraints: LayoutConstraints): GridCell[] { /* §11.11 */ }
```

**Validation criteria:**
- [ ] Priority-based visibility works
- [ ] Flexibility adapts to space
- [ ] Relationships are maintained
- [ ] Solver terminates in all cases

**Reference sections:** §11

**Known gaps to fill:**
- Constraint solver algorithm (see Gap 9 in Implementation Gaps review)
- Termination guarantee

---

#### C.2.11 Phase 11: Digital Twin & State

**Goal:** Authoritative state tracking with history

**Components to implement:**
- Digital Twin (§16.1)
- Operation history (§16.2)
- Snapshot addressing (§16.3)
- Source propagation (§16.4)

**Starting files:**
```typescript
// src/state/twin.ts
export class DigitalTwin { /* §16.1 */ }

// src/state/history.ts
export class OperationHistory { /* §16.2 */ }

// src/state/snapshot.ts
export function getSnapshot(history: OperationHistory, index: number): LiquidSchema { /* §16.3 */ }
```

**Validation criteria:**
- [ ] State updates are tracked
- [ ] Undo/redo works correctly
- [ ] Snapshots are accurate
- [ ] Source tracking is complete

**Reference sections:** §16

---

#### C.2.12 Phase 12: Adapter Interface

**Goal:** Platform-specific rendering

**Components to implement:**
- Adapter interface (§18.1)
- Signal runtime bridge (§18.3)
- Conformance tests (§18.4, §B.3.3)
- Placeholder rendering (§19.2)

**Starting files:**
```typescript
// src/adapter/interface.ts
export interface LiquidAdapter<T> { /* §18.1 */ }

// src/adapter/react/ReactAdapter.ts
export class ReactAdapter implements LiquidAdapter<React.ReactElement> {
  render(schema: LiquidSchema, data: any): React.ReactElement { }
  renderBlock(block: Block, data: any): React.ReactElement { }
  renderPlaceholder(block: Block, reason: string): React.ReactElement { }
  createSignalRuntime(registry: SignalRegistry): SignalRuntime { }
  // ... §18.1
}

// src/adapter/conformance.ts
export function runConformanceTests(adapter: LiquidAdapter<any>): TestResults { /* §B.3.3 */ }
```

**Validation criteria:**
- [ ] All core block types render
- [ ] Signals propagate correctly
- [ ] Placeholders show for unsupported types
- [ ] No crashes on valid schemas
- [ ] Conformance tests pass

**Reference sections:** §18, §19, §B.3

---

#### C.2.13 Phase 13: LLM Integration

**Goal:** Generate LiquidCode via LLM

**Components to implement:**
- System prompts (enhancement needed)
- L0/L1/L2 generation (§5)
- Micro-LLM calls (§13.4)
- Grammar teaching (enhancement needed)
- Error recovery (enhancement needed)

**Starting files:**
```typescript
// src/llm/prompts.ts
export const L0_SYSTEM_PROMPT = `/* Define system prompt */`;
export const L1_SYSTEM_PROMPT = `/* Define system prompt */`;
export const L2_SYSTEM_PROMPT = `/* Define system prompt */`;

// src/llm/generation.ts
export async function generateL0(intent: Intent, data: DataFingerprint): Promise<string> { }
export async function generateL1(l0: string, intent: Intent): Promise<string> { }
export async function generateL2(l1: string): Promise<string> { }

// src/llm/micro.ts
export async function microLLMCall(scope: MicroScope, context: any): Promise<string> { }
```

**Validation criteria:**
- [ ] L0 outputs valid archetype/layout
- [ ] L1 outputs valid block definitions
- [ ] L2 outputs sensible polish
- [ ] Micro-calls are scoped and fast
- [ ] Token counts meet targets (<60 for full gen)

**Reference sections:** §5, §13.4

**Known gaps to fill:**
- LLM prompt engineering (see Gap 1 in Implementation Gaps review)
- Few-shot examples for each archetype
- Grammar teaching strategy
- Error recovery prompts

**CRITICAL:** This phase has the largest implementation gap. Budget 3-4 weeks for prompt development and testing.

---

### C.3 Testing Strategy

#### C.3.1 Unit Testing

For each phase, write unit tests covering:
- Happy path (valid inputs)
- Edge cases (boundary conditions)
- Error cases (invalid inputs)
- Performance (latency targets)

**Example for Parser:**
```typescript
describe('LiquidCode Parser', () => {
  it('parses simple generation', () => {
    const code = '#overview;G2x2;K$revenue';
    const ast = parse(tokenize(code));
    expect(ast.archetype).toBe('overview');
    expect(ast.layout.type).toBe('grid');
    expect(ast.blocks).toHaveLength(1);
  });

  it('handles ASCII operators', () => {
    const code = 'delta:+K$profit@[1,2]';
    const ast = parse(tokenize(code));
    expect(ast.operation).toBe('add');
  });

  it('rejects invalid syntax', () => {
    const code = '#overview;;';  // double semicolon
    expect(() => parse(tokenize(code))).toThrow();
  });
});
```

#### C.3.2 Integration Testing

Test component interactions:
- Parser → Compiler → Validator
- Discovery → Resolution → Compiler
- Adapter → Signal Runtime
- Full pipeline: Intent → Rendered UI

**Example:**
```typescript
describe('Full Pipeline', () => {
  it('generates and renders dashboard', async () => {
    const intent = 'Show revenue over time';
    const data = { date: [...], revenue: [...] };

    const fragment = await resolve(intent, data);
    const schema = compile(fragment);
    const element = adapter.render(schema, data);

    expect(element).toBeTruthy();
    expect(schema.blocks).toContainEqual(
      expect.objectContaining({ type: 'line-chart' })
    );
  });
});
```

#### C.3.3 Conformance Testing

Adapter conformance (§B.3.3):
- 13+ core block types render
- Placeholders for unknown types
- Signal propagation works
- No crashes on valid schemas
- Graceful degradation

**Run conformance suite:**
```typescript
const results = runConformanceTests(new ReactAdapter());
expect(results.passRate).toBeGreaterThan(0.95);
```

#### C.3.4 Performance Testing

Validate claimed metrics (§1.1):
- Token count: <60 for generation, <15 for mutation
- Latency: Tier 1 <5ms, Tier 2 <50ms, Tier 3 <100ms, Tier 4 <500ms
- Cache hit rate: >85%
- Error rate: <1%

**Example benchmark:**
```typescript
describe('Performance', () => {
  it('meets latency targets', async () => {
    const start = Date.now();
    const fragment = await resolveTier1(intent);
    const duration = Date.now() - start;
    expect(duration).toBeLessThan(5);
  });

  it('meets token count targets', () => {
    const liquidCode = generate(intent, data);
    const tokens = tokenize(liquidCode).length;
    expect(tokens).toBeLessThan(60);
  });
});
```

---

### C.4 Common Implementation Pitfalls

#### C.4.1 Parser Ambiguities

**Problem:** LiquidCode grammar has unspecified ambiguities (see Gap 2).

**Mitigation:**
- Use formal PEG grammar (not just examples)
- Write tests for all syntax edge cases
- Document tokenization state machine
- Normalize to ASCII form early (§B.1)

**Example pitfall:**
```liquidcode
L$date$amount
```
Is this one field `"date$amount"` or two fields `"date"` and `"amount"`?

**Solution:** Specify field separator explicitly in grammar.

#### C.4.2 UID Collisions

**Problem:** UID generation may collide in high-volume scenarios (see Edge Case ISS-078).

**Mitigation:**
- Use crypto-strong random generator
- Include timestamp component
- Detect and handle collisions
- Document collision probability

**Example:**
```typescript
function generateUID(): string {
  const timestamp = Date.now().toString(36);
  const random = crypto.randomBytes(8).toString('hex');
  return `b_${timestamp}${random}`.slice(0, 15);
}
```

#### C.4.3 Signal Circular Dependencies

**Problem:** Signals can form cycles causing deadlock (see Edge Case ISS-076).

**Mitigation:**
- Detect cycles during compilation
- Limit propagation depth
- Maintain visited set during emit

**Example:**
```typescript
function emitSignal(signal: string, value: any, visited = new Set<string>()) {
  if (visited.has(signal)) {
    throw new Error(`Circular signal dependency: ${signal}`);
  }
  visited.add(signal);
  // ... emit logic
}
```

#### C.4.4 Layout Solver Non-Termination

**Problem:** Conflicting constraints may cause infinite loop (see Edge Case ISS-077).

**Mitigation:**
- Set max iteration limit
- Detect oscillation
- Fall back to simpler layout

**Example:**
```typescript
function solveLayout(constraints: LayoutConstraints): GridCell[] {
  let iterations = 0;
  const MAX_ITERATIONS = 1000;

  while (!isSolved(constraints) && iterations < MAX_ITERATIONS) {
    iterations++;
    // ... solver logic
  }

  if (iterations >= MAX_ITERATIONS) {
    console.warn('Layout solver reached max iterations, using fallback');
    return fallbackLayout(constraints);
  }

  return solution;
}
```

#### C.4.5 LiquidExpr Resource Exhaustion

**Problem:** Unbounded expression evaluation (see Edge Case ISS-079).

**Mitigation:**
- Limit operation count
- Set execution timeout
- Sandbox execution context

**Example:**
```typescript
function evaluateExpr(expr: string, context: any): any {
  let opCount = 0;
  const MAX_OPS = 1000;

  const safeEval = (node: ASTNode): any => {
    if (++opCount > MAX_OPS) {
      throw new Error('Expression too complex');
    }
    // ... evaluation logic
  };

  return safeEval(parse(expr));
}
```

---

### C.5 Deployment Checklist

Before production deployment:

#### C.5.1 Functional Requirements
- [ ] All 13 core block types implemented
- [ ] All 5 mutation operations work
- [ ] All 4 address forms resolve
- [ ] All signal types supported
- [ ] Layout system adapts to breakpoints
- [ ] Fragment cache operates
- [ ] Tiered resolution cascades correctly

#### C.5.2 Performance Requirements
- [ ] P95 generation latency <100ms (with cache)
- [ ] P99 token count <60 (generation), <15 (mutation)
- [ ] Cache hit rate >85% after warm-up
- [ ] Render completes in <5s for any valid schema

#### C.5.3 Reliability Requirements
- [ ] Error rate <1% on valid inputs
- [ ] 100% valid schemas render (no crashes)
- [ ] Graceful degradation for unsupported features
- [ ] Coherence gate rejects incoherent fragments

#### C.5.4 Security Requirements
- [ ] LiquidExpr sandboxed (no eval, no I/O)
- [ ] User input validated (no injection)
- [ ] UID generation is cryptographically random
- [ ] Data binding doesn't expose sensitive fields

#### C.5.5 Documentation Requirements
- [ ] API reference generated
- [ ] All public interfaces documented
- [ ] Migration guide for V1 users (if applicable)
- [ ] Troubleshooting guide
- [ ] Performance tuning guide

#### C.5.6 Testing Requirements
- [ ] Unit test coverage >80%
- [ ] Integration tests pass
- [ ] Conformance suite passes for all adapters
- [ ] Performance benchmarks meet targets
- [ ] Regression tests from previous versions

#### C.5.7 Monitoring Requirements
- [ ] Latency metrics by tier
- [ ] Cache hit rate tracking
- [ ] Error rate tracking
- [ ] Token count distribution
- [ ] LLM call frequency

---

### C.6 Troubleshooting Guide

#### C.6.1 Parser Failures

**Symptom:** Parse errors on seemingly valid LiquidCode

**Diagnosis:**
1. Check tokenizer output: `console.log(tokenize(code))`
2. Verify ASCII normalization: `normalizeToASCII(code)`
3. Test minimal case: Reduce to simplest failing example

**Common causes:**
- Unicode/ASCII mismatch
- Unexpected whitespace
- Operator precedence ambiguity

**Fix:** Normalize to ASCII early, add test case, update grammar.

---

#### C.6.2 Compilation Failures

**Symptom:** Valid AST fails to compile to schema

**Diagnosis:**
1. Check semantic analysis: Does AST have unresolved references?
2. Verify UID generation: Are UIDs unique?
3. Validate intermediate schema: Does it pass Zod validation?

**Common causes:**
- Missing binding fields in data
- Signal references undefined registry
- Block type not in supported set

**Fix:** Add validation step between parsing and compilation.

---

#### C.6.3 Resolution Misses

**Symptom:** Low cache hit rate (<85%)

**Diagnosis:**
1. Check cache key generation: Are keys too specific?
2. Verify semantic embeddings: Are similar intents close in embedding space?
3. Review fragment composition: Is composition tier working?

**Common causes:**
- Intent normalization missing (e.g., "show" vs "display")
- Embedding model not tuned for domain
- Composition rules too restrictive

**Fix:** Improve intent normalization, retrain embeddings, expand composition rules.

---

#### C.6.4 Render Failures

**Symptom:** Valid schema fails to render

**Diagnosis:**
1. Check adapter support: Does adapter support all block types?
2. Verify data shape: Does data match binding fields?
3. Inspect signal runtime: Are signals propagating?

**Common causes:**
- Custom block types not implemented in adapter
- Data field renamed without updating binding
- Signal persistence failing silently

**Fix:** Implement missing block types, validate data before render, add signal debugging.

---

#### C.6.5 Performance Issues

**Symptom:** Latency targets not met

**Diagnosis:**
1. Profile by tier: Where is time spent?
2. Check LLM calls: Are micro-calls scoped correctly?
3. Measure cache operations: Is cache lookup slow?

**Common causes:**
- Tier 4 (LLM) called too frequently
- Cache not warmed properly
- Semantic search is slow

**Fix:** Improve cache hit rate, optimize embedding search, parallelize cache warming.

---

### C.7 Extension Points

The system is designed for extension in these areas:

#### C.7.1 Custom Block Types

Add new block types beyond the 13 core types:

```typescript
// Define custom block
const customBlock: BlockType = 'custom:gantt-chart';

// Implement in adapter
class ReactAdapter implements LiquidAdapter<React.ReactElement> {
  renderBlock(block: Block, data: any) {
    if (block.type === 'custom:gantt-chart') {
      return <GanttChart data={data} binding={block.binding} />;
    }
    // ... handle other types
  }
}
```

**Requirements:**
- Use `custom:` prefix (§B.6.1)
- Document required bindings
- Provide fallback for unsupported adapters

---

#### C.7.2 Custom Signal Types

Add new signal types beyond the 8 standard types:

```typescript
// Define custom signal
interface CustomSignalDefinition extends SignalDefinition {
  type: 'custom';
  customType: 'geolocation';  // Your custom type
  validation?: string;
}

// Handle in signal runtime
class SignalRuntime {
  set(signalName: string, value: any) {
    const def = this.registry[signalName];
    if (def.type === 'custom' && def.customType === 'geolocation') {
      // Custom handling
    }
  }
}
```

---

#### C.7.3 Custom Archetypes

Add domain-specific archetypes:

```typescript
// Register custom archetype
const archetypeRegistry = {
  // ... standard archetypes
  'financial_report': {
    layout: 'G3x4',
    requiredPrimitives: ['date', 'currency'],
    template: '/* LiquidCode template */',
  },
};

// Use in discovery
function detectArchetypes(primitives: Primitive[]): Archetype[] {
  // Check custom archetypes first
  // Fall back to standard archetypes
}
```

---

#### C.7.4 Custom LiquidExpr Functions

Add domain-specific transform functions:

```typescript
// Define custom function
const customFunctions = {
  fiscalQuarter: (date: Date) => Math.floor((date.getMonth() + 3) / 3),
  netPromoterScore: (arr: number[]) => {
    const promoters = arr.filter(x => x >= 9).length;
    const detractors = arr.filter(x => x <= 6).length;
    return ((promoters - detractors) / arr.length) * 100;
  },
};

// Register in LiquidExpr evaluator
registerFunction('fiscalQuarter', customFunctions.fiscalQuarter);
```

**Requirements:**
- Must be pure functions (no side effects)
- Must handle null inputs gracefully
- Must be sandboxed (no I/O, no globals)

---

### C.8 Migration from V1 (If Applicable)

If migrating from LiquidCode v1:

#### C.8.1 Breaking Changes
- Block types may have renamed
- Signal syntax changed (if V1 had signals)
- Layout system is new (priority/flex)
- Binding slots may differ

#### C.8.2 Migration Path
1. Parse V1 schema
2. Map block types to V2 equivalents
3. Convert bindings to V2 format
4. Add UIDs to all blocks
5. Compile to V2 schema
6. Validate with Zod

**Use migration interface (§20.3):**
```typescript
const migration: Migration = {
  from: '1.0',
  to: '2.0',
  migrate(oldSchema: V1Schema): LiquidSchema {
    // ... conversion logic
  },
};
```

---

### C.9 Performance Optimization Guide

Once implemented, optimize in this order:

#### C.9.1 Cache Hit Rate
**Goal:** >85% cache hits

**Techniques:**
- Normalize intents (lowercase, synonym replacement)
- Improve semantic embeddings
- Expand fragment composition rules
- Warm cache proactively

**Measurement:**
```typescript
const hitRate = cacheHits / (cacheHits + cacheMisses);
console.log(`Cache hit rate: ${(hitRate * 100).toFixed(1)}%`);
```

---

#### C.9.2 LLM Call Reduction
**Goal:** <5% of requests go to Tier 4

**Techniques:**
- Pre-generate common archetypes
- Use micro-LLM for repairs only
- Batch multiple decisions in one LLM call
- Cache LLM outputs aggressively

**Measurement:**
```typescript
const tier4Rate = tier4Calls / totalCalls;
console.log(`Tier 4 rate: ${(tier4Rate * 100).toFixed(1)}%`);
```

---

#### C.9.3 Token Count Reduction
**Goal:** P99 <60 tokens (generation), <15 tokens (mutation)

**Techniques:**
- Use ASCII operators (saves 2-3x tokens)
- Omit optional fields
- Use type ordinals (@K0) instead of explicit IDs
- Batch mutations

**Measurement:**
```typescript
const tokens = tokenize(liquidCode);
console.log(`Token count: ${tokens.length}`);
```

---

#### C.9.4 Compilation Speed
**Goal:** <50ms for average schema

**Techniques:**
- Parallelize L1 block compilation
- Cache parsed ASTs
- Optimize Zod validation (use `.parse()` not `.safeParse()`)
- Stream schema generation

**Measurement:**
```typescript
const start = performance.now();
const schema = compile(liquidCode);
const duration = performance.now() - start;
console.log(`Compilation time: ${duration.toFixed(1)}ms`);
```

---

### C.10 Recommended Tools & Libraries

#### C.10.1 Core Dependencies
- **TypeScript:** Type safety
- **Zod:** Runtime validation
- **PEG.js** or **Nearley:** Parser generation
- **crypto:** UID generation

#### C.10.2 LLM Integration
- **OpenAI SDK** or **Anthropic SDK:** LLM calls
- **LangChain:** Prompt management (optional)

#### C.10.3 Caching
- **Redis:** Distributed cache
- **LRU Cache:** In-memory cache
- **Faiss** or **Pinecone:** Vector similarity search

#### C.10.4 Testing
- **Jest** or **Vitest:** Unit testing
- **Playwright:** Integration testing (for adapters)
- **k6** or **Artillery:** Load testing

#### C.10.5 Monitoring
- **Prometheus:** Metrics collection
- **Grafana:** Dashboards
- **Sentry:** Error tracking

---

### C.11 Summary

Implementing LiquidCode v2 is a **16-20 week full-stack project**. The specification provides a solid conceptual foundation, but approximately 40% of implementation details must be filled in (see Implementation Gap Analysis review).

**Critical path:**
1. Fill Phase 1 gaps (7-8 weeks)
2. Implement core pipeline (4-6 weeks)
3. Integrate LLM (3-4 weeks)
4. Optimize & harden (3-4 weeks)

**Success criteria:**
- Latency targets met (P95 <100ms with cache)
- Token count targets met (P99 <60 generation)
- Cache hit rate >85%
- Error rate <1%
- 100% valid schemas render

**For rapid prototyping:** Start with MVI (4-6 weeks) and manually write LiquidCode. Add LLM generation later.

This guide should be updated as implementation proceeds and gaps are filled.
```

## Verification Checklist
- [x] Change addresses the identified issue
- [x] No new inconsistencies introduced
- [x] Cross-references remain valid
- [x] Interface signatures unchanged (or documented)
- [x] Normative language (MUST/SHOULD/MAY) consistent

## Side Effects
- [ ] None
- [x] New appendix references should be added to Table of Contents (§TOC)
- [x] Cross-reference from §17 (Compilation Pipeline) to Appendix C
- [x] Cross-reference from Appendix B.7 (Hardening Checklist) to Appendix C

## Dependencies
- [ ] No dependencies on other issues
- [x] References gaps identified in implementation-gaps.md review
- [x] References sections throughout the spec (§5, §6, §8-§18, Appendix B)
- [ ] Blocks: None

## Confidence
**HIGH** - This implementation guide provides a comprehensive roadmap based on the existing specification structure, identified gaps from the implementation review, and standard software engineering practices. The phased approach with validation criteria, common pitfalls, and troubleshooting guidance should enable implementers to build the system systematically.
