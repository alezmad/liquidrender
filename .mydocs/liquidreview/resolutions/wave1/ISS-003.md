# Resolution: ISS-003

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Binding Inference - ScoringSignal Implementation
**Severity:** critical
**Target:** SPEC
**Section:** §9.3

## Resolution

### Original Content (Lines 693-711)

```typescript
interface ScoringSignal {
  source: 'type' | 'semantic' | 'pattern' | 'position' | 'user';
  weight: number;
  reason: string;
}
```

**Scoring signals:**

| Signal | Weight | Example |
|--------|--------|---------|
| Type match | 0.3 | Numeric field → value slot |
| Semantic match | 0.3 | "revenue" → financial KPI |
| Pattern match | 0.2 | Date column → X axis |
| Position match | 0.1 | First numeric → primary metric |
| User history | 0.1 | Previously used this binding |

**Confidence thresholds:**

| Score | Behavior |
|-------|----------|
| > 0.8 | Auto-bind (high confidence) |
| 0.5 - 0.8 | Bind with "best guess" flag |
| < 0.5 | Prompt for clarification |

### Replacement Content

```typescript
interface ScoringSignal {
  source: 'type' | 'semantic' | 'pattern' | 'position' | 'user';
  weight: number;
  reason: string;
}
```

**Scoring algorithms:**

#### 1. Type Match Scoring
```typescript
function scoreTypeMatch(field: DataField, slot: BindingSlot): number {
  const matches: Record<string, BindingSlot[]> = {
    'number': ['value', 'x', 'y', 'current', 'previous'],
    'string': ['label', 'category', 'series'],
    'date': ['x', 'label'],
    'boolean': ['toggle', 'filter'],
  };

  const validSlots = matches[field.type] || [];
  return validSlots.includes(slot) ? 1.0 : 0.0;
}
```

#### 2. Semantic Match Scoring
```typescript
function scoreSemanticMatch(fieldName: string, slot: BindingSlot): number {
  const semanticPatterns = {
    'value': ['revenue', 'amount', 'total', 'sum', 'count', 'price', 'cost'],
    'label': ['name', 'title', 'description', 'category', 'type'],
    'x': ['date', 'time', 'month', 'year', 'period'],
    'y': ['amount', 'value', 'count', 'revenue', 'total'],
    'category': ['region', 'segment', 'type', 'status', 'group'],
    'current': ['actual', 'current', 'ytd', 'mtd'],
    'previous': ['prior', 'previous', 'last', 'budget', 'target'],
  };

  const patterns = semanticPatterns[slot] || [];
  const normalized = fieldName.toLowerCase();

  // Exact substring match
  for (const pattern of patterns) {
    if (normalized.includes(pattern)) {
      return 1.0;
    }
  }

  // Partial match (Levenshtein distance < 3)
  for (const pattern of patterns) {
    if (levenshteinDistance(normalized, pattern) < 3) {
      return 0.6;
    }
  }

  return 0.0;
}
```

#### 3. Pattern Match Scoring
```typescript
function scorePatternMatch(field: DataField, slot: BindingSlot): number {
  const patterns = [
    // Date patterns for X axis
    { test: (f: DataField) => f.type === 'date', slot: 'x', score: 1.0 },

    // High cardinality string → category
    {
      test: (f: DataField) => f.type === 'string' && f.cardinality && f.cardinality < 50,
      slot: 'category',
      score: 0.9
    },

    // Low cardinality → series
    {
      test: (f: DataField) => f.type === 'string' && f.cardinality && f.cardinality < 10,
      slot: 'series',
      score: 0.8
    },

    // Integer with "count" semantics
    {
      test: (f: DataField) => f.type === 'number' && Number.isInteger(f.min || 0),
      slot: 'value',
      score: 0.7
    },
  ];

  for (const pattern of patterns) {
    if (pattern.slot === slot && pattern.test(field)) {
      return pattern.score;
    }
  }

  return 0.0;
}
```

#### 4. Position Match Scoring
```typescript
function scorePositionMatch(
  fieldIndex: number,
  totalFields: number,
  slot: BindingSlot
): number {
  // First numeric field → value
  if (fieldIndex === 0 && slot === 'value') return 0.8;

  // Second numeric → secondary value or comparison
  if (fieldIndex === 1 && (slot === 'y' || slot === 'previous')) return 0.6;

  // First string → label
  if (fieldIndex === 0 && slot === 'label') return 0.7;

  // Last field → often a total or summary
  if (fieldIndex === totalFields - 1 && slot === 'value') return 0.5;

  return 0.0;
}
```

#### 5. User History Scoring
```typescript
function scoreUserHistory(
  field: string,
  slot: BindingSlot,
  history: BindingHistory
): number {
  const key = `${field}:${slot}`;
  const usage = history.get(key);

  if (!usage) return 0.0;

  // Score based on frequency and recency
  const frequencyScore = Math.min(usage.count / 10, 1.0);
  const recencyScore = Math.exp(-(Date.now() - usage.lastUsed) / (30 * 24 * 60 * 60 * 1000)); // 30-day decay

  return (frequencyScore * 0.6) + (recencyScore * 0.4);
}
```

#### 6. Weight Combination
```typescript
function calculateBindingScore(
  field: DataField,
  fieldIndex: number,
  totalFields: number,
  slot: BindingSlot,
  history: BindingHistory
): number {
  const weights = {
    type: 0.3,
    semantic: 0.3,
    pattern: 0.2,
    position: 0.1,
    user: 0.1,
  };

  const scores = {
    type: scoreTypeMatch(field, slot),
    semantic: scoreSemanticMatch(field.name, slot),
    pattern: scorePatternMatch(field, slot),
    position: scorePositionMatch(fieldIndex, totalFields, slot),
    user: scoreUserHistory(field.name, slot, history),
  };

  // Weighted sum
  const totalScore = Object.entries(weights).reduce(
    (sum, [key, weight]) => sum + (scores[key as keyof typeof scores] * weight),
    0
  );

  return totalScore;
}

interface BindingSuggestion {
  field: string;
  slot: BindingSlot;
  score: number;           // 0-1 confidence (from calculateBindingScore)
  signals: ScoringSignal[];
}

// Generate suggestions for a block
function suggestBindings(
  blockType: BlockType,
  dataFields: DataField[],
  history: BindingHistory
): BindingSuggestion[] {
  const requiredSlots = getRequiredSlots(blockType);
  const suggestions: BindingSuggestion[] = [];

  for (const slot of requiredSlots) {
    const candidates = dataFields.map((field, index) => ({
      field: field.name,
      slot,
      score: calculateBindingScore(field, index, dataFields.length, slot, history),
      signals: [
        { source: 'type', weight: 0.3, reason: `Type ${field.type} matches slot ${slot}` },
        { source: 'semantic', weight: 0.3, reason: `Field name "${field.name}" suggests ${slot}` },
        { source: 'pattern', weight: 0.2, reason: `Data pattern matches ${slot}` },
        { source: 'position', weight: 0.1, reason: `Position ${index} suggests ${slot}` },
        { source: 'user', weight: 0.1, reason: `User history for ${field.name}:${slot}` },
      ],
    }));

    // Take highest-scoring candidate for this slot
    const best = candidates.sort((a, b) => b.score - a.score)[0];
    if (best && best.score > 0) {
      suggestions.push(best);
    }
  }

  return suggestions;
}
```

**Confidence thresholds:**

| Score | Behavior |
|-------|----------|
| > 0.8 | Auto-bind (high confidence) |
| 0.5 - 0.8 | Bind with "best guess" flag |
| < 0.5 | Prompt for clarification |

**Supporting types:**

```typescript
interface DataField {
  name: string;
  type: 'string' | 'number' | 'date' | 'boolean';
  cardinality?: number;    // Distinct value count
  min?: number;
  max?: number;
}

interface BindingHistory {
  get(key: string): { count: number; lastUsed: number } | undefined;
}

function levenshteinDistance(a: string, b: string): number {
  const matrix: number[][] = [];

  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }

  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }

  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }

  return matrix[b.length][a.length];
}
```

## Verification Checklist
- [x] Change addresses the identified issue (adds complete algorithms for all scoring sources)
- [x] No new inconsistencies introduced (algorithms use types from §9.1-9.2)
- [x] Cross-references remain valid (references to confidence thresholds maintained)

## Confidence
**HIGH** - Implementation provides concrete, testable algorithms for each scoring signal source with clear weight combination logic. Algorithms are based on established patterns (Levenshtein distance for fuzzy matching, exponential decay for recency). All five scoring sources are fully specified with executable TypeScript.
