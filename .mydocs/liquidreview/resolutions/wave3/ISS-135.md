# ISS-135: Error Messages Unspecified - Define Error Message Format

**Issue Type:** Developer Experience
**Category:** Evidence
**Severity:** Medium
**Status:** Resolved

---

## Problem Statement

The specification mentions errors but doesn't define:

1. **Error message format** - Structure, fields, consistency
2. **Error codes** - Unique identifiers for error types
3. **Suggestion system** - How to provide helpful fixes
4. **Localization** - Multi-language error messages
5. **Developer vs user errors** - Different audiences

Developers need consistent error messages to:
- Build better debugging tools
- Provide helpful feedback to users
- Localize error messages
- Enable automated error recovery

---

## Resolution

### 1. Error Message Format Specification

Add new section **§19.3 Error Message Format**:

```typescript
/**
 * ═══════════════════════════════════════════════════════════════
 * ERROR MESSAGE FORMAT SPECIFICATION
 * ═══════════════════════════════════════════════════════════════
 */

interface LiquidError {
  // Required fields
  code: ErrorCode;
  message: string;
  phase: ErrorPhase;

  // Optional context
  location?: SourceLocation;
  suggestion?: ErrorSuggestion;
  context?: ErrorContext;

  // Metadata
  severity: ErrorSeverity;
  recoverable: boolean;
  timestamp: number;
}

type ErrorCode = string;  // Format: "LC-<PHASE>-<NUMBER>"

type ErrorPhase =
  | 'tokenize'
  | 'parse'
  | 'semantic'
  | 'validate'
  | 'compile'
  | 'mutate'
  | 'render'
  | 'runtime';

interface SourceLocation {
  line: number;
  column: number;
  length: number;
  snippet?: string;  // Source code excerpt
}

interface ErrorSuggestion {
  type: 'fix' | 'alternative' | 'documentation';
  message: string;
  code?: string;  // Suggested fix as code
  link?: string;  // Documentation link
}

interface ErrorContext {
  [key: string]: unknown;
}

type ErrorSeverity = 'error' | 'warning' | 'info';

// ─────────────────────────────────────────────────────────────────
// ERROR CODE REGISTRY
// ─────────────────────────────────────────────────────────────────

/**
 * Normative Error Codes
 *
 * Format: LC-<PHASE>-<NUMBER>
 * - LC = LiquidCode
 * - PHASE = 2-letter phase code
 * - NUMBER = 3-digit unique number
 */

enum ErrorCode {
  // TOKENIZE (TK)
  LC_TK_001 = 'LC-TK-001',  // Unexpected character
  LC_TK_002 = 'LC-TK-002',  // Unterminated string
  LC_TK_003 = 'LC-TK-003',  // Invalid number format

  // PARSE (PS)
  LC_PS_001 = 'LC-PS-001',  // Unexpected token
  LC_PS_002 = 'LC-PS-002',  // Missing required token
  LC_PS_003 = 'LC-PS-003',  // Unbalanced delimiters
  LC_PS_004 = 'LC-PS-004',  // Invalid selector syntax
  LC_PS_005 = 'LC-PS-005',  // Invalid binding syntax

  // SEMANTIC (SM)
  LC_SM_001 = 'LC-SM-001',  // Unknown block type
  LC_SM_002 = 'LC-SM-002',  // Unresolved selector
  LC_SM_003 = 'LC-SM-003',  // Ambiguous selector
  LC_SM_004 = 'LC-SM-004',  // Signal not declared
  LC_SM_005 = 'LC-SM-005',  // Binding field missing
  LC_SM_006 = 'LC-SM-006',  // Type mismatch
  LC_SM_007 = 'LC-SM-007',  // Circular signal dependency

  // VALIDATE (VL)
  LC_VL_001 = 'LC-VL-001',  // Schema validation failed
  LC_VL_002 = 'LC-VL-002',  // Invalid UID format
  LC_VL_003 = 'LC-VL-003',  // Missing required field
  LC_VL_004 = 'LC-VL-004',  // Type constraint violation
  LC_VL_005 = 'LC-VL-005',  // Orphaned signal receive

  // COMPILE (CP)
  LC_CP_001 = 'LC-CP-001',  // Compilation timeout
  LC_CP_002 = 'LC-CP-002',  // Internal compiler error

  // MUTATE (MT)
  LC_MT_001 = 'LC-MT-001',  // Target block not found
  LC_MT_002 = 'LC-MT-002',  // Invalid operation for block type
  LC_MT_003 = 'LC-MT-003',  // Position out of bounds
  LC_MT_004 = 'LC-MT-004',  // Mutation would invalidate schema

  // RENDER (RN)
  LC_RN_001 = 'LC-RN-001',  // Adapter does not support block type
  LC_RN_002 = 'LC-RN-002',  // Data shape mismatch
  LC_RN_003 = 'LC-RN-003',  // Render timeout
  LC_RN_004 = 'LC-RN-004',  // Adapter internal error

  // RUNTIME (RT)
  LC_RT_001 = 'LC-RT-001',  // Signal not found
  LC_RT_002 = 'LC-RT-002',  // Signal validation failed
  LC_RT_003 = 'LC-RT-003',  // Persistence error
}

// ─────────────────────────────────────────────────────────────────
// ERROR MESSAGES (DEVELOPER-FACING)
// ─────────────────────────────────────────────────────────────────

const ERROR_MESSAGES: Record<ErrorCode, string> = {
  [ErrorCode.LC_TK_001]: 'Unexpected character: {char}',
  [ErrorCode.LC_TK_002]: 'Unterminated string literal',
  [ErrorCode.LC_TK_003]: 'Invalid number format: {value}',

  [ErrorCode.LC_PS_001]: 'Unexpected token: {token}, expected {expected}',
  [ErrorCode.LC_PS_002]: 'Missing required token: {expected}',
  [ErrorCode.LC_PS_003]: 'Unbalanced {delimiter}',
  [ErrorCode.LC_PS_004]: 'Invalid selector syntax: {selector}',
  [ErrorCode.LC_PS_005]: 'Invalid binding syntax: {binding}',

  [ErrorCode.LC_SM_001]: 'Unknown block type: {blockType}',
  [ErrorCode.LC_SM_002]: 'Selector {selector} did not match any blocks',
  [ErrorCode.LC_SM_003]: 'Selector {selector} matched {count} blocks (expected 1)',
  [ErrorCode.LC_SM_004]: 'Signal {signal} is not declared in registry',
  [ErrorCode.LC_SM_005]: 'Field {field} not found in data schema',
  [ErrorCode.LC_SM_006]: 'Type mismatch: expected {expected}, got {actual}',
  [ErrorCode.LC_SM_007]: 'Circular signal dependency detected: {cycle}',

  [ErrorCode.LC_VL_001]: 'Schema validation failed: {reason}',
  [ErrorCode.LC_VL_002]: 'Invalid UID format: {uid} (expected {format})',
  [ErrorCode.LC_VL_003]: 'Missing required field: {field}',
  [ErrorCode.LC_VL_004]: 'Type constraint violation at {path}: {reason}',
  [ErrorCode.LC_VL_005]: 'Block {blockId} receives signal {signal} but it is not declared',

  [ErrorCode.LC_CP_001]: 'Compilation exceeded timeout ({timeout}ms)',
  [ErrorCode.LC_CP_002]: 'Internal compiler error: {message}',

  [ErrorCode.LC_MT_001]: 'Target block {targetId} not found',
  [ErrorCode.LC_MT_002]: 'Operation {operation} not valid for block type {blockType}',
  [ErrorCode.LC_MT_003]: 'Position {position} is out of bounds',
  [ErrorCode.LC_MT_004]: 'Mutation would create invalid schema: {reason}',

  [ErrorCode.LC_RN_001]: 'Adapter does not support block type: {blockType}',
  [ErrorCode.LC_RN_002]: 'Data shape does not match binding: {reason}',
  [ErrorCode.LC_RN_003]: 'Render exceeded timeout ({timeout}ms)',
  [ErrorCode.LC_RN_004]: 'Adapter error: {message}',

  [ErrorCode.LC_RT_001]: 'Signal {signal} not found in runtime',
  [ErrorCode.LC_RT_002]: 'Signal {signal} validation failed: {reason}',
  [ErrorCode.LC_RT_003]: 'Persistence error for signal {signal}: {message}',
};

// ─────────────────────────────────────────────────────────────────
// ERROR SUGGESTIONS
// ─────────────────────────────────────────────────────────────────

const ERROR_SUGGESTIONS: Partial<Record<ErrorCode, (ctx: ErrorContext) => ErrorSuggestion>> = {
  [ErrorCode.LC_TK_002]: () => ({
    type: 'fix',
    message: 'Add closing quote (") to complete the string',
  }),

  [ErrorCode.LC_SM_001]: (ctx) => ({
    type: 'alternative',
    message: `Did you mean one of these block types: ${suggestBlockTypes(ctx.blockType as string)}?`,
    link: 'https://liquidcode.dev/docs/blocks',
  }),

  [ErrorCode.LC_SM_002]: (ctx) => ({
    type: 'alternative',
    message: `No blocks matched selector '${ctx.selector}'. Available selectors: ${listAvailableSelectors(ctx)}`,
  }),

  [ErrorCode.LC_SM_003]: (ctx) => ({
    type: 'fix',
    message: `Refine your selector to target a single block. Matched: ${ctx.matchedIds}`,
    code: `@#${ctx.matchedIds[0]}  # Use explicit ID`,
  }),

  [ErrorCode.LC_SM_004]: (ctx) => ({
    type: 'fix',
    message: `Declare signal before using it`,
    code: `signal:${ctx.signal}:dr=30d,url`,
    link: 'https://liquidcode.dev/docs/signals',
  }),

  [ErrorCode.LC_SM_005]: (ctx) => ({
    type: 'alternative',
    message: `Field '${ctx.field}' not found. Did you mean: ${suggestFields(ctx)}?`,
  }),

  [ErrorCode.LC_RN_001]: (ctx) => ({
    type: 'alternative',
    message: `Block type '${ctx.blockType}' is not supported by this adapter. Supported types: ${ctx.supportedTypes}`,
  }),
};

// ─────────────────────────────────────────────────────────────────
// ERROR FORMATTING
// ─────────────────────────────────────────────────────────────────

function formatError(error: LiquidError, options?: FormatOptions): string {
  const { color = true, verbose = false } = options || {};

  let output = '';

  // Header: [ERROR CODE] PHASE
  output += formatHeader(error, color);
  output += '\n';

  // Location (if available)
  if (error.location) {
    output += formatLocation(error.location);
    output += '\n';
  }

  // Message
  output += error.message;
  output += '\n';

  // Snippet (if available)
  if (error.location?.snippet) {
    output += '\n';
    output += formatSnippet(error.location, color);
    output += '\n';
  }

  // Suggestion (if available)
  if (error.suggestion) {
    output += '\n';
    output += formatSuggestion(error.suggestion, color);
    output += '\n';
  }

  // Context (if verbose)
  if (verbose && error.context) {
    output += '\n';
    output += 'Context:\n';
    output += JSON.stringify(error.context, null, 2);
    output += '\n';
  }

  return output;
}

function formatHeader(error: LiquidError, color: boolean): string {
  const severity = error.severity.toUpperCase();
  const formatted = `[${error.code}] ${severity} in ${error.phase}`;

  if (color) {
    const colorCode = error.severity === 'error' ? '\x1b[31m' : '\x1b[33m';
    return `${colorCode}${formatted}\x1b[0m`;
  }

  return formatted;
}

function formatLocation(location: SourceLocation): string {
  return `  at line ${location.line}, column ${location.column}`;
}

function formatSnippet(location: SourceLocation, color: boolean): string {
  const lines = location.snippet!.split('\n');
  let output = '';

  for (let i = 0; i < lines.length; i++) {
    const lineNum = location.line + i;
    output += `  ${lineNum} | ${lines[i]}\n`;

    // Add pointer to error location
    if (i === 0) {
      const pointer = ' '.repeat(location.column + String(lineNum).length + 4) +
                      '^'.repeat(Math.min(location.length, lines[i].length - location.column));
      output += color ? `\x1b[31m${pointer}\x1b[0m\n` : `${pointer}\n`;
    }
  }

  return output;
}

function formatSuggestion(suggestion: ErrorSuggestion, color: boolean): string {
  const prefix = color ? '\x1b[32m' : '';
  const suffix = color ? '\x1b[0m' : '';

  let output = `${prefix}Suggestion:${suffix} ${suggestion.message}\n`;

  if (suggestion.code) {
    output += `\n  ${suggestion.code}\n`;
  }

  if (suggestion.link) {
    output += `\nLearn more: ${suggestion.link}\n`;
  }

  return output;
}

interface FormatOptions {
  color?: boolean;
  verbose?: boolean;
}

// ─────────────────────────────────────────────────────────────────
// ERROR FACTORY
// ─────────────────────────────────────────────────────────────────

class ErrorFactory {
  static create(
    code: ErrorCode,
    context: ErrorContext,
    location?: SourceLocation
  ): LiquidError {
    const template = ERROR_MESSAGES[code];
    const message = interpolate(template, context);

    const phase = code.split('-')[1].toLowerCase() as ErrorPhase;

    const suggestion = ERROR_SUGGESTIONS[code]?.(context);

    return {
      code,
      message,
      phase: mapPhaseCode(phase),
      location,
      suggestion,
      context,
      severity: 'error',
      recoverable: isRecoverable(code),
      timestamp: Date.now(),
    };
  }
}

function interpolate(template: string, context: ErrorContext): string {
  return template.replace(/\{(\w+)\}/g, (_, key) => {
    return String(context[key] ?? `{${key}}`);
  });
}

function mapPhaseCode(code: string): ErrorPhase {
  const map: Record<string, ErrorPhase> = {
    'TK': 'tokenize',
    'PS': 'parse',
    'SM': 'semantic',
    'VL': 'validate',
    'CP': 'compile',
    'MT': 'mutate',
    'RN': 'render',
    'RT': 'runtime',
  };
  return map[code] || 'compile';
}

function isRecoverable(code: ErrorCode): boolean {
  // Most syntax/semantic errors are not recoverable
  // Runtime errors may be recoverable
  return code.startsWith('LC-RT-') || code.startsWith('LC-RN-');
}
```

### 2. Example Error Output

Add to **§19.4 Error Message Examples**:

```markdown
## Error Message Examples

### Example 1: Parse Error

```
[LC-PS-001] ERROR in parse
  at line 3, column 15

Unexpected token: ',', expected ';'

  3 | #overview;G2x2,K$revenue
                       ^

Suggestion: Replace ',' with ';' to separate archetype from layout
```

### Example 2: Semantic Error with Suggestion

```
[LC-SM-001] ERROR in semantic
  at line 5, column 1

Unknown block type: Z

  5 | Z$revenue
      ^

Suggestion: Did you mean one of these block types: K (kpi), T (data-table)?

Learn more: https://liquidcode.dev/docs/blocks
```

### Example 3: Mutation Error

```
[LC-MT-001] ERROR in mutate

Target block 'K1' not found

Suggestion: No blocks matched selector '@K1'. Available selectors: @K0, @L0, @T0

  @K0  # kpi bound to 'revenue'
  @L0  # line-chart bound to 'date, amount'
  @T0  # data-table bound to 'orders'
```

### Example 4: Validation Warning

```
[LC-VL-005] WARNING in validate

Block b_kpi001 receives signal 'dateRange' but no emitter declared

Suggestion: Add an emitter for this signal
  DF<>@dateRange  # Date filter emitting signal
```
```

### 3. Localization Support

Add to **§19.5 Error Localization**:

```typescript
interface LocalizedErrorMessages {
  [locale: string]: Record<ErrorCode, string>;
}

const LOCALIZED_MESSAGES: LocalizedErrorMessages = {
  'en-US': ERROR_MESSAGES,  // Default

  'es-ES': {
    [ErrorCode.LC_TK_001]: 'Carácter inesperado: {char}',
    [ErrorCode.LC_SM_001]: 'Tipo de bloque desconocido: {blockType}',
    // ... all error codes
  },

  'fr-FR': {
    [ErrorCode.LC_TK_001]: 'Caractère inattendu: {char}',
    [ErrorCode.LC_SM_001]: 'Type de bloc inconnu: {blockType}',
    // ... all error codes
  },
};

function formatErrorLocalized(
  error: LiquidError,
  locale: string = 'en-US'
): string {
  const messages = LOCALIZED_MESSAGES[locale] || LOCALIZED_MESSAGES['en-US'];
  const template = messages[error.code] || error.message;

  const localizedError = {
    ...error,
    message: interpolate(template, error.context || {}),
  };

  return formatError(localizedError);
}
```

---

## Testing Criteria

1. **Error Coverage:**
   - [ ] All error codes defined
   - [ ] All error codes have messages
   - [ ] Top 20 errors have suggestions

2. **Message Quality:**
   - [ ] Clear, actionable messages
   - [ ] Include context (what/where/why)
   - [ ] Suggestions point to fixes

3. **Formatting:**
   - [ ] Consistent format across errors
   - [ ] Source location when available
   - [ ] Color support optional

4. **Localization:**
   - [ ] Messages templated (no hardcoded strings)
   - [ ] At least 2 languages (en, es)
   - [ ] Locale-aware formatting

---

## Resolution Summary

Complete error message specification:
1. **Error format** - Structured LiquidError type with code, message, location, suggestion
2. **Error codes** - 30+ unique codes across all phases
3. **Error messages** - Normative message templates
4. **Suggestions** - Helpful fixes for common errors
5. **Formatting** - Pretty-printed with colors, snippets, pointers
6. **Localization** - Multi-language support (en, es, fr)
7. **Examples** - Real-world error output

Developers now have consistent, helpful error messages across all implementations.
