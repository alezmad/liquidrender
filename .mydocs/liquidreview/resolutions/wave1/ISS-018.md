# ISS-018: Address Resolution Priority Order

**Issue Type:** Consistency Issue
**Severity:** Medium
**Status:** Resolved
**Date:** 2025-12-21

---

## Problem Statement

The priority order for resolving block addresses is defined inconsistently between §8.3 (Block Addressing System) and B.6.1 (Address Resolution in UID context), creating ambiguity about which selector takes precedence when multiple could match.

### Location A: §8.3 (Lines 586-595)

```markdown
### 8.3 Resolution Priority

When resolving an address:

1. **Explicit ID** — `@#myId` matches block with `id: "myId"`
2. **Grid position** — `@[0,1]` matches block at row 0, column 1
3. **Type ordinal** — `@K0` matches first KPI
4. **Binding signature** — `@:revenue` matches block bound to revenue
5. **Pure ordinal** — `@0` matches first block in traversal order
```

### Location B: B.6.1 (Lines 2966-2988 in B.2.2)

```typescript
interface AddressResolution {
  selector: string;           // Original: "@K0"
  resolvedUids: string[];     // ["b_a7f3c9e2b4d1"]
  ambiguous: boolean;         // True if multiple matches for singular selector
  timestamp: number;          // When resolved
}

**Resolution algorithm:**
```
1. Parse selector (e.g., @K0 = "first KPI")
2. Query current schema for matching blocks
3. Return uid(s) of matching block(s)
4. If ambiguous and operation expects singular:
   a. Return error with disambiguation options
   b. OR use deterministic tiebreaker (first in traversal order)
```
```

### Location C: B.2.4 (Lines 2004-2020)

```markdown
#### B.2.4 Explicit ID Addressing

Users can assign semantic IDs for stable human-readable addresses:

```liquidcode
# Assign ID at creation
K$revenue#main_revenue

# Address by ID (stable)
delta:~@#main_revenue.label:"New Label"
```

IDs are:
- Optional (uid is always present)
- User-controlled (not auto-generated)
- Must be unique within schema
- Immutable once assigned
```

---

## Discrepancies Identified

1. **Incomplete Priority List:**
   - §8.3 lists 5 selector types in priority order
   - B.2.2 describes the algorithm but doesn't specify priority between different selector types
   - Neither location addresses what happens if multiple selector types could match the same selector string

2. **Ambiguity Resolution:**
   - §8.3 implies strict priority (first match wins)
   - B.2.2 introduces "ambiguous" flag and tiebreaker logic
   - These aren't contradictory but aren't clearly unified

3. **Missing Edge Cases:**
   - What if a block has both `id: "0"` and is the first in traversal order? Does `@0` mean pure ordinal or explicit ID `@#0`?
   - What if grid position `@[0,0]` also happens to be `@K0`? Does syntax determine priority?

4. **Documentation Split:**
   - §8.3 is pedagogical (user-facing)
   - B.2.2 is implementation-focused (developer-facing)
   - Neither fully captures the complete resolution logic

---

## Root Cause Analysis

The issue arises from **incomplete specification of selector syntax parsing**:

- §8.3 describes **what** selectors can match
- B.2.2 describes **how** to resolve once selector type is determined
- **Missing:** How to parse a selector string to determine its type

### Example Ambiguity

Given selector `@0`:

- Could be **pure ordinal** (first block in tree)
- Could be **explicit ID** if there's a block with `id: "0"`
- Could be **type ordinal** if there's a block type with code `0` (unlikely but not prevented)

The spec doesn't clarify that **syntax determines type**, not matching results.

---

## Resolution

### Principle: Syntax-Driven Resolution

**Key Insight:** Resolution priority is determined by **selector syntax**, not by trying each type until one matches.

The selector string's syntax unambiguously determines its type, then resolution proceeds within that type.

### Selector Syntax Classification

| Selector Syntax | Type | Example | Priority |
|-----------------|------|---------|----------|
| `@#<identifier>` | Explicit ID | `@#main_revenue` | 1 (highest) |
| `@[<row>,<col>]` | Grid Position | `@[0,1]` | 2 |
| `@<TYPE><digit>` | Type Ordinal | `@K0`, `@L1` | 3 |
| `@:<identifier>` | Binding Signature | `@:revenue` | 4 |
| `@<digit>` | Pure Ordinal | `@0`, `@3` | 5 (lowest) |
| `@<wildcard>` | Wildcard | `@K*`, `@[*,0]` | Special (returns set) |

**Priority only matters when selectors overlap** (e.g., mutation batch with multiple selectors). Within a single selector, syntax determines type unambiguously.

### Updated Resolution Algorithm

```typescript
function resolveAddress(
  selector: string,
  schema: LiquidSchema
): AddressResolution {
  // Step 1: Parse selector syntax to determine type
  const type = parseAddressSyntax(selector);

  // Step 2: Resolve within that type
  const matches = resolveByType(type, selector, schema);

  // Step 3: Handle ambiguity if singular expected
  if (matches.length > 1 && !isWildcard(selector)) {
    // Tiebreaker: first in traversal order
    return {
      selector,
      resolvedUids: [matches[0].uid],
      ambiguous: true,
      timestamp: Date.now(),
      tiebreaker: 'traversal-order',
    };
  }

  return {
    selector,
    resolvedUids: matches.map(b => b.uid),
    ambiguous: false,
    timestamp: Date.now(),
  };
}

function parseAddressSyntax(selector: string): AddressType {
  if (selector.startsWith('@#')) return 'explicit-id';
  if (selector.match(/^@\[\d+,\d+\]$/)) return 'grid-position';
  if (selector.match(/^@[A-Z]+\d+$/)) return 'type-ordinal';
  if (selector.startsWith('@:')) return 'binding-signature';
  if (selector.match(/^@\d+$/)) return 'pure-ordinal';
  if (selector.includes('*')) return 'wildcard';
  throw new Error(`Invalid address syntax: ${selector}`);
}
```

---

## Required Changes

### 1. Update §8.3 - Clarify Syntax-Driven Resolution

**Insert before current "8.3 Resolution Priority" (line 586):**

```markdown
### 8.3 Address Syntax

Each address type has a unique syntax. The syntax determines resolution type unambiguously:

| Syntax Pattern | Type | Example | Matches |
|----------------|------|---------|---------|
| `@#<id>` | Explicit ID | `@#main` | Block with `id: "main"` |
| `@[<r>,<c>]` | Grid Position | `@[0,1]` | Block at row 0, column 1 |
| `@<TYPE><n>` | Type Ordinal | `@K0` | Nth block of type (0-indexed) |
| `@:<field>` | Binding Signature | `@:revenue` | Block bound to field |
| `@<n>` | Pure Ordinal | `@0` | Nth block in traversal (0-indexed) |
| `@<wildcard>` | Wildcard | `@K*` | All blocks matching pattern |

**Parsing Rule:** Syntax determines type; priority only applies to conflict resolution within a type.
```

**Replace current "8.3 Resolution Priority" with:**

```markdown
### 8.3 Resolution Algorithm

1. **Parse selector syntax** to determine address type (see table above)
2. **Query schema** for blocks matching that address type
3. **Return matching block(s)**:
   - For explicit ID: exact match or error
   - For positional: calculate position, return block at that position or error
   - For wildcard: return all matches (can be empty set)
4. **Handle ambiguity** (if multiple blocks match singular selector):
   - Use deterministic tiebreaker: first in tree traversal order
   - Flag result as ambiguous for logging/debugging

**Priority applies only when:**
- Multiple selectors in a batch operation could conflict
- User disambiguation is needed

**Priority order (for conflict resolution):**
1. Explicit ID (most stable, user-controlled)
2. Grid Position (spatial, layout-dependent)
3. Type Ordinal (type-dependent, position-independent)
4. Binding Signature (semantic, data-dependent)
5. Pure Ordinal (least stable, pure position)
```

### 2. Update B.2.2 - Add Syntax Parsing

**Add to B.2.2 (after line 2976, before "Resolution algorithm"):**

```typescript
/**
 * Address Syntax Parsing
 *
 * REQUIREMENT: All address selectors MUST match exactly one syntax pattern.
 * Invalid syntax MUST throw CompileError at parse time, not resolution time.
 */

type AddressType =
  | 'explicit-id'        // @#<identifier>
  | 'grid-position'      // @[<row>,<col>]
  | 'type-ordinal'       // @<TYPE><digit>
  | 'binding-signature'  // @:<identifier>
  | 'pure-ordinal'       // @<digit>
  | 'wildcard';          // Contains *

const ADDRESS_PATTERNS: Record<AddressType, RegExp> = {
  'explicit-id': /^@#[a-zA-Z_][a-zA-Z0-9_]*$/,
  'grid-position': /^@\[\d+,\d+\]$/,
  'type-ordinal': /^@[A-Z]+\d+$/,
  'binding-signature': /^@:[a-zA-Z_][a-zA-Z0-9_.]*$/,
  'pure-ordinal': /^@\d+$/,
  'wildcard': /\*/,  // Any selector containing *
};

function parseAddressType(selector: string): AddressType {
  for (const [type, pattern] of Object.entries(ADDRESS_PATTERNS)) {
    if (pattern.test(selector)) {
      return type as AddressType;
    }
  }
  throw new CompileError(
    `Invalid address syntax: ${selector}`,
    `Expected one of: @#id, @[r,c], @Type0, @:field, @0, @wildcard`
  );
}
```

**Update "Resolution algorithm" (lines 2979-2987) to:**

```typescript
**Resolution algorithm:**
```
1. Parse selector syntax → determine address type (see parseAddressType above)
2. Query current schema for blocks matching that type:
   - explicit-id: find block where block.id === extractedId
   - grid-position: find block at calculated grid position
   - type-ordinal: find blocks of type, return nth
   - binding-signature: find blocks with binding to field
   - pure-ordinal: return nth block in traversal order
   - wildcard: find all blocks matching pattern
3. Return uid(s) of matching block(s)
4. If ambiguous and operation expects singular:
   a. Apply tiebreaker: first in traversal order
   b. Log warning with ambiguity details
   c. Return resolved uid with ambiguous flag set
```
```

### 3. Add Edge Case Handling

**Add new section B.2.5:**

```markdown
#### B.2.5 Edge Cases and Ambiguity

**Edge Case: Numeric ID vs Pure Ordinal**

If a block has `id: "0"` and is also the first block in traversal:

```liquidcode
K$revenue#0       # Block with id="0"
```

- `@#0` matches the block with `id: "0"` (explicit ID syntax)
- `@0` matches the first block in traversal (pure ordinal syntax)
- If they happen to be the same block, no conflict
- If they're different blocks, syntax determines which is selected

**Edge Case: Grid Position Equals Type Ordinal**

If the first KPI happens to be at grid position `[0,0]`:

- `@[0,0]` matches by grid position
- `@K0` matches first KPI
- If same block, no issue
- If different (e.g., grid starts with a filter, not a KPI), syntax determines target

**Edge Case: Multiple Wildcards in Batch**

```liquidcode
delta:[~@K*.format:"currency", ~@[*,0].width:200]
```

- Both wildcards may overlap (if column 0 contains KPIs)
- Operations apply in order; duplicates are idempotent
- Last write wins for same property on same block

**Ambiguity Resolution Policy:**

1. **Syntax is truth:** If selector syntax is unambiguous, resolution proceeds regardless of potential conceptual overlap
2. **Tiebreaker is deterministic:** Traversal order (depth-first, left-to-right)
3. **Log ambiguities:** All ambiguous resolutions SHOULD be logged for debugging
4. **User feedback:** UI should highlight ambiguous selections for user review
```

---

## Validation

After applying these changes:

1. ✅ Selector syntax unambiguously determines address type
2. ✅ Resolution algorithm is fully specified (parse → query → resolve → tiebreak)
3. ✅ Edge cases are documented with handling rules
4. ✅ Ambiguity handling is deterministic
5. ✅ §8.3 and B.2 are consistent and complementary

---

## Implementation Notes

### For Spec Editors

- §8.3 remains user-focused (syntax examples, common cases)
- B.2 provides implementation requirements (regex, algorithm, edge cases)
- Consider adding a decision tree diagram to §8.3 for visual learners

### For Implementers

**Required Functions:**

```typescript
// 1. Parse address syntax (MUST validate at compile time)
function parseAddress(selector: string): {
  type: AddressType;
  params: AddressParams;
} {
  const type = parseAddressType(selector);
  const params = extractParams(type, selector);
  return { type, params };
}

// 2. Resolve address to UIDs
function resolveAddress(
  selector: string,
  schema: LiquidSchema
): AddressResolution {
  const { type, params } = parseAddress(selector);
  const matches = queryByType(type, params, schema);

  if (matches.length === 0) {
    throw new ResolutionError(`No blocks match selector: ${selector}`);
  }

  if (matches.length > 1 && !isWildcard(selector)) {
    // Ambiguous: apply tiebreaker
    return {
      selector,
      resolvedUids: [matches[0].uid],
      ambiguous: true,
      tiebreaker: 'traversal-order',
      timestamp: Date.now(),
    };
  }

  return {
    selector,
    resolvedUids: matches.map(b => b.uid),
    ambiguous: false,
    timestamp: Date.now(),
  };
}

// 3. Query blocks by address type
function queryByType(
  type: AddressType,
  params: AddressParams,
  schema: LiquidSchema
): Block[] {
  switch (type) {
    case 'explicit-id':
      return schema.blocks.filter(b => b.id === params.id);
    case 'grid-position':
      return [findBlockAtGridPosition(schema, params.row, params.col)];
    case 'type-ordinal':
      return [findNthBlockOfType(schema, params.type, params.index)];
    case 'binding-signature':
      return findBlocksBoundToField(schema, params.field);
    case 'pure-ordinal':
      return [findNthBlock(schema, params.index)];
    case 'wildcard':
      return findBlocksMatchingPattern(schema, params.pattern);
  }
}
```

**Traversal Order Definition:**

```typescript
// Deterministic tree traversal for tiebreaking
function* traverseBlocks(schema: LiquidSchema): Generator<Block> {
  // Depth-first, left-to-right
  const queue = [...schema.blocks];
  while (queue.length > 0) {
    const block = queue.shift()!;
    yield block;
    if (block.slots) {
      for (const slotBlocks of Object.values(block.slots)) {
        queue.push(...slotBlocks);
      }
    }
  }
}
```

### Testing Requirements

```typescript
// Test: Syntax parsing
test('parseAddress rejects invalid syntax', () => {
  expect(() => parseAddress('@invalid')).toThrow(CompileError);
  expect(() => parseAddress('@#')).toThrow(CompileError);
  expect(() => parseAddress('@[]')).toThrow(CompileError);
});

// Test: Ambiguity resolution
test('resolveAddress uses traversal order for tiebreaker', () => {
  const schema = createSchemaWithDuplicateTypeOrdinals();
  const result = resolveAddress('@K0', schema);
  expect(result.ambiguous).toBe(true);
  expect(result.resolvedUids[0]).toBe(schema.blocks[0].uid); // First in traversal
});

// Test: Edge case - numeric ID vs ordinal
test('resolveAddress distinguishes @#0 from @0', () => {
  const schema = {
    blocks: [
      { uid: 'b_aaa', type: 'kpi', id: '0' },    // Has id="0"
      { uid: 'b_bbb', type: 'kpi' },             // First in traversal
    ],
  };
  expect(resolveAddress('@#0', schema).resolvedUids[0]).toBe('b_aaa');
  expect(resolveAddress('@0', schema).resolvedUids[0]).toBe('b_aaa'); // Also first in traversal
});
```

---

## Migration Impact

### No Breaking Changes

This resolution is **purely clarifying**. Existing implementations that:

- Parse syntax to determine type (implicitly or explicitly)
- Use deterministic resolution

...will continue to work unchanged.

### Risk: Under-Specified Implementations

If an implementation tries **all** address types until one matches (rather than parsing syntax first), it may have ambiguity issues:

**Problematic Implementation:**
```typescript
// BAD: Sequential trial-and-error
function resolve(selector: string, schema: LiquidSchema): Block | null {
  return tryExplicitId(selector, schema)
      || tryGridPosition(selector, schema)
      || tryTypeOrdinal(selector, schema)
      || tryBindingSignature(selector, schema)
      || tryPureOrdinal(selector, schema);
}
```

This fails because `@0` might incorrectly match as explicit ID if a block has `id: "0"`.

**Correct Implementation:**
```typescript
// GOOD: Syntax-driven
function resolve(selector: string, schema: LiquidSchema): Block | null {
  const type = parseAddressType(selector); // Determines type from syntax
  return queryByType(type, selector, schema);
}
```

---

## Related Issues

- ISS-016: Block Interface Definition (UID system enables stable addressing)
- **Future:** Consider visual address builder UI to prevent user syntax errors

---

## Checklist

- [x] Discrepancies identified
- [x] Root cause analyzed (missing syntax parsing specification)
- [x] Authoritative source determined (synthesis of §8.3 and B.2)
- [x] Specific changes documented
- [x] Edge cases enumerated and handled
- [x] Implementation requirements specified
- [x] Test cases provided
- [x] Migration impact assessed

---

**Resolution Authority:** Synthesis of §8.3 (user-facing) and B.2 (implementation)
**Change Scope:** Non-breaking (clarification and formalization)
**Priority:** Should fix before v2.0 publication (improves implementer experience)
