# ISS-115: Operator Extensibility

**Issue Type:** Extension Gap
**Category:** Extensibility and Evolution
**Priority:** Medium
**Affects:** Interface Algebra (Section 7), Mutation Operations

---

## Problem Statement

LiquidCode v2 defines a fixed set of mutation operators:
- `+` (add), `-` (remove), `→` (replace), `~` (modify), `↑` (move)

Common mutation patterns cannot be expressed efficiently:

| Desired Operation | Current Workaround | Inefficiency |
|-------------------|-------------------|--------------|
| Duplicate block | Query + Add with same config | 2 operations instead of 1 |
| Swap positions | 3 moves (A→temp, B→A, temp→B) | 3 operations instead of 1 |
| Batch transform | Wildcard modify works! | ✅ Exists |
| Conditional modify | No support, must use external logic | Not declarative |
| Merge blocks | Manual reconstruction | Complex, error-prone |

Domain-specific workflows need custom operators (e.g., "medical dashboard refactoring" or "financial report templating").

---

## Resolution

### Extension Mechanism

Make the mutation operator set extensible via registration, allowing domain-specific batch operations.

### Implementation

#### 1. Operator Definition Interface

```typescript
interface MutationOperator {
  // Identification
  symbol: string;                      // '*' for duplicate
  name: string;                        // 'duplicate'
  version: string;                     // Semver

  // Execution
  arity: number | 'variadic';          // How many operands
  execute(
    twin: DigitalTwin,
    operands: Operand[]
  ): LiquidSchema;

  // Undo support
  invert?(operation: Operation): Operation;

  // LiquidCode syntax
  syntax: string;                      // 'Δ*@address'
  syntaxPattern: RegExp;               // Parser pattern

  // Metadata
  description: string;
  category: 'structural' | 'batch' | 'transform' | 'custom';
  examples: string[];
}

interface Operand {
  type: 'address' | 'value' | 'expression';
  value: any;
}
```

#### 2. Operator Registry

```typescript
interface MutationOperatorRegistry {
  register(operator: MutationOperator): void;
  get(symbol: string): MutationOperator | undefined;
  has(symbol: string): boolean;
  list(): string[];
  unregister(symbol: string): void;
}

class MutationOperatorRegistry {
  private operators: Map<string, MutationOperator> = new Map();

  register(operator: MutationOperator): void {
    if (this.operators.has(operator.symbol)) {
      throw new Error(`Operator '${operator.symbol}' already registered`);
    }

    this.operators.set(operator.symbol, operator);
  }

  parse(liquidCode: string): Operation | null {
    for (const [symbol, operator] of this.operators) {
      const match = operator.syntaxPattern.exec(liquidCode);
      if (match) {
        return {
          type: operator.name,
          operator: operator,
          operands: this.extractOperands(match, operator.arity)
        };
      }
    }
    return null;
  }
}
```

#### 3. Example: Duplicate Operator

```typescript
engine.mutations.registerOperator({
  symbol: '*',
  name: 'duplicate',
  version: '1.0.0',
  arity: 1,

  execute(twin: DigitalTwin, [target]: Operand[]): LiquidSchema {
    // Resolve address to block
    const block = resolveAddress(twin.schema, target.value);

    if (!block) {
      throw new MutationError(`Block not found: ${target.value}`);
    }

    // Create duplicate with new UID
    const duplicate = {
      ...block,
      uid: generateUID(),
      id: block.id ? `${block.id}_copy` : undefined
    };

    // Insert after original
    return insertBlockAfter(twin.schema, block.uid, duplicate);
  },

  invert(operation: Operation): Operation {
    // Undo is removing the duplicate
    return {
      type: 'remove',
      target: operation.result.uid
    };
  },

  syntax: 'Δ*@address',
  syntaxPattern: /^Δ\*@(.+)$/,
  description: 'Duplicate a block, creating an exact copy with new UID',
  category: 'structural',
  examples: [
    'Δ*@K0      # Duplicate first KPI',
    'Δ*@[0,1]   # Duplicate block at grid position [0,1]',
    'Δ*@#hero   # Duplicate block with id="hero"'
  ]
});
```

#### 4. Example: Swap Operator

```typescript
engine.mutations.registerOperator({
  symbol: '↔',
  name: 'swap',
  version: '1.0.0',
  arity: 2,

  execute(twin: DigitalTwin, [targetA, targetB]: Operand[]): LiquidSchema {
    const blockA = resolveAddress(twin.schema, targetA.value);
    const blockB = resolveAddress(twin.schema, targetB.value);

    if (!blockA || !blockB) {
      throw new MutationError('Both blocks must exist for swap');
    }

    // Swap positions in schema
    const schema = { ...twin.schema };
    const posA = findBlockPosition(schema, blockA.uid);
    const posB = findBlockPosition(schema, blockB.uid);

    setBlockPosition(schema, blockA.uid, posB);
    setBlockPosition(schema, blockB.uid, posA);

    return schema;
  },

  invert(operation: Operation): Operation {
    // Swap is its own inverse
    return operation;
  },

  syntax: 'Δ↔@address1,@address2',
  syntaxPattern: /^Δ↔@(.+),@(.+)$/,
  description: 'Swap positions of two blocks',
  category: 'structural',
  examples: [
    'Δ↔@K0,@K1        # Swap first two KPIs',
    'Δ↔@[0,0],@[1,1]  # Swap diagonal blocks'
  ]
});
```

#### 5. Example: Merge Operator

```typescript
engine.mutations.registerOperator({
  symbol: '⊕',
  name: 'merge',
  version: '1.0.0',
  arity: 'variadic',

  execute(twin: DigitalTwin, operands: Operand[]): LiquidSchema {
    const blocks = operands.map(op =>
      resolveAddress(twin.schema, op.value)
    ).filter(Boolean);

    if (blocks.length < 2) {
      throw new MutationError('Merge requires at least 2 blocks');
    }

    // Create merged block (e.g., metric-group)
    const merged: Block = {
      uid: generateUID(),
      type: 'metric-group',
      slots: {
        metrics: blocks
      },
      layout: blocks[0].layout  // Inherit first block's layout
    };

    // Remove originals, insert merged
    let schema = twin.schema;
    blocks.forEach(b => {
      schema = removeBlock(schema, b.uid);
    });
    schema = insertBlock(schema, merged, blocks[0].position);

    return schema;
  },

  syntax: 'Δ⊕@address1,@address2,...',
  syntaxPattern: /^Δ⊕@(.+)$/,
  description: 'Merge multiple blocks into a composite block',
  category: 'structural',
  examples: [
    'Δ⊕@K0,@K1,@K2   # Merge three KPIs into metric-group'
  ]
});
```

#### 6. Built-in Operators as Registered

Migrate existing operators to use the same registry:

```typescript
class LiquidEngine {
  constructor() {
    this.mutations = new MutationOperatorRegistry();
    this.registerCoreOperators();
  }

  private registerCoreOperators() {
    // + (add)
    this.mutations.registerOperator({
      symbol: '+',
      name: 'add',
      execute: (twin, [block, position]) => { /* ... */ },
      // ...
    });

    // - (remove)
    this.mutations.registerOperator({
      symbol: '-',
      name: 'remove',
      execute: (twin, [target]) => { /* ... */ },
      // ...
    });

    // → (replace)
    // ~ (modify)
    // ↑ (move)
    // ...
  }
}
```

---

## Conservative Approach

If full extensibility is too complex initially, add the **most common built-in operators** first:

### Proposed Additional Built-ins

```typescript
// Duplicate (most requested)
'Δ*@K0' → duplicate first KPI

// Swap (very common in manual editing)
'Δ↔@K0,@K1' → swap two blocks

// Merge (useful for grouping)
'Δ⊕@K0,@K1' → merge into metric-group

// Split (inverse of merge)
'Δ⊖@M0' → split metric-group into individual blocks

// Batch modify with filter
'Δ~@K*[revenue>1000].highlight:true' → conditional highlighting
```

Start with these 5 additions as built-ins in v2.2, then add full extensibility in v2.5 if demand exists.

---

## Migration Path

### Phase 1: Registry Infrastructure (v2.1)
- Implement operator registry
- Register existing 5 operators as built-ins
- No user-visible changes (internal refactor)

### Phase 2: Add Common Operators (v2.2)
- Add duplicate, swap, merge, split as built-ins
- Document new operators
- Gather usage data

### Phase 3: Open Extensibility (v2.5)
- Public API for registering custom operators
- Domain packages can add operators
- Example: `@liquidcode/financial-ops` with portfolio rebalancing operators

---

## Benefits

### Efficiency
- Duplicate: 1 operation instead of 2
- Swap: 1 operation instead of 3
- Domain batches: 1 operation instead of N

### Expressiveness
- Domain workflows become first-class
- Complex mutations declarative, not imperative

### Ecosystem
- Domain packages can ship custom operators
- Medical, financial, logistics domains get domain-specific mutation languages

---

## Testing Requirements

```typescript
describe('Operator Extensibility', () => {
  it('registers custom operators', () => {
    registry.register({ symbol: '⊗', name: 'custom-op', ... });
    expect(registry.has('⊗')).toBe(true);
  });

  it('executes duplicate operator', () => {
    const schema = {
      blocks: [{ uid: 'b1', type: 'kpi', binding: { ... } }]
    };
    const twin = new DigitalTwin(schema);

    const result = registry.get('*').execute(twin, [{ type: 'address', value: '@0' }]);

    expect(result.blocks).toHaveLength(2);
    expect(result.blocks[1].type).toBe('kpi');
    expect(result.blocks[1].uid).not.toBe('b1');  // New UID
  });

  it('inverts operations for undo', () => {
    const op = { type: 'duplicate', target: '@K0', result: { uid: 'b2' } };
    const inverse = registry.get('*').invert(op);

    expect(inverse.type).toBe('remove');
    expect(inverse.target).toBe('b2');
  });
});
```

---

## Documentation Requirements

### User Guide: Mutation Operators

**Contents:**
1. Built-in operators reference
2. New operators: duplicate, swap, merge, split
3. When to use each operator
4. Batching patterns
5. Undo/redo behavior

### Developer Guide: Custom Operators (v2.5+)

**Contents:**
1. When to create custom operators
2. Registration API
3. Execution semantics (pure, deterministic)
4. Undo support
5. Testing custom operators
6. Publishing operator packages

---

## Implementation Checklist

### Phase 1 (v2.1)
- [ ] Define `MutationOperator` interface
- [ ] Implement `MutationOperatorRegistry`
- [ ] Migrate existing 5 operators to registry
- [ ] Write operator execution tests

### Phase 2 (v2.2)
- [ ] Implement duplicate operator
- [ ] Implement swap operator
- [ ] Implement merge operator
- [ ] Implement split operator
- [ ] Document new operators
- [ ] Add LiquidCode syntax support

### Phase 3 (v2.5)
- [ ] Public registration API
- [ ] Operator validation
- [ ] Custom operator examples
- [ ] Developer documentation

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** Medium (adds new operators, optional extensibility API)
**Breaking Changes:** None (all additive)
**Version Target:** v2.1 (infrastructure), v2.2 (new operators), v2.5 (extensibility)

**Rationale Integration:** Domain-specific workflows need domain-specific operations. While the core 5 operators handle 90% of cases, the remaining 10% (especially batch operations and domain patterns) benefit greatly from custom operators. The conservative approach (add common built-ins first) balances pragmatism with future extensibility.
