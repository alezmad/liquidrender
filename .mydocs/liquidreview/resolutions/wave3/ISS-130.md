# ISS-130: Discovery Engine Vague - Clarify Discovery Process

**Issue Type:** Developer Experience
**Category:** Evidence
**Severity:** Medium
**Status:** Resolved

---

## Problem Statement

Section 12 (Discovery Engine) describes the concept but lacks implementation details:

1. **Fingerprinting algorithm** - How to extract schema signals
2. **Primitive inference rules** - How to detect UOM primitives
3. **Archetype detection algorithm** - Scoring system
4. **Pre-generation triggers** - When to warm cache
5. **Discovery performance** - How fast must it be?

---

## Resolution

### 1. Complete Fingerprinting Algorithm

Add to **§12.3 Schema Archetypes**:

```typescript
/**
 * Data Fingerprinting Algorithm
 */

function fingerprintDataSource(data: unknown[]): DataFingerprint {
  if (!Array.isArray(data) || data.length === 0) {
    throw new Error('Data must be non-empty array');
  }

  const sample = data.slice(0, Math.min(1000, data.length));
  const fields = extractFields(sample[0]);

  const fingerprint: DataFingerprint = {
    schemaHash: hashSchema(fields),
    fieldCount: fields.length,
    fields: fields.map(f => fingerprintField(f, sample)),
    relationships: detectRelationships(sample),
    statistics: {
      rowCount: data.length,
      completeness: calculateCompleteness(sample),
      uniquenessMean: calculateUniqueness(sample),
    },
  };

  return fingerprint;
}

function fingerprintField(fieldName: string, sample: unknown[]): FieldFingerprint {
  const values = sample.map(row => row[fieldName]).filter(v => v != null);

  return {
    name: fieldName,
    type: inferDataType(values),
    primitive: inferUOMPrimitive(fieldName, values),
    cardinality: new Set(values).size,
    nullRate: 1 - (values.length / sample.length),
    sampleValues: values.slice(0, 5),
  };
}

function inferDataType(values: unknown[]): DataType {
  const types = new Set(values.map(v => typeof v));

  if (types.has('number')) return 'number';
  if (types.has('boolean')) return 'boolean';
  if (types.has('string')) {
    // Check if dates
    if (values.every(v => !isNaN(Date.parse(String(v))))) {
      return 'date';
    }
    return 'string';
  }
  if (types.has('object')) return 'object';

  return 'unknown';
}

function inferUOMPrimitive(fieldName: string, values: unknown[]): UOMPrimitive {
  const name = fieldName.toLowerCase();
  const type = inferDataType(values);

  // Date detection
  if (type === 'date' || /date|time|created|updated/.test(name)) {
    return 'date';
  }

  // Currency detection
  if (/price|cost|revenue|amount|total|sales/.test(name)) {
    return 'currency';
  }

  // Count detection
  if (type === 'number' && /count|qty|quantity|num|number/.test(name)) {
    return 'count';
  }

  // Percentage detection
  if (type === 'number') {
    const nums = values as number[];
    if (nums.every(n => n >= 0 && n <= 1)) return 'percentage';
    if (nums.every(n => n >= 0 && n <= 100) && /rate|pct|percent/.test(name)) {
      return 'percentage';
    }
  }

  // Category detection
  if (type === 'string') {
    const cardinality = new Set(values).size;
    const uniquenessRatio = cardinality / values.length;
    if (uniquenessRatio < 0.1) return 'category';  // Low uniqueness = category
  }

  // Identifier detection
  if (type === 'string' || type === 'number') {
    const cardinality = new Set(values).size;
    const uniquenessRatio = cardinality / values.length;
    if (uniquenessRatio > 0.9 && /id|key|code/.test(name)) {
      return 'identifier';
    }
  }

  // Boolean detection
  if (type === 'boolean') return 'boolean';

  // Text detection
  if (type === 'string') {
    const avgLength = values.reduce((sum, v) => sum + String(v).length, 0) / values.length;
    if (avgLength > 50) return 'text';  // Long strings = text
  }

  return 'unknown';
}
```

### 2. Archetype Detection Algorithm

Add to **§12.4 UOM Primitive Inference**:

```typescript
/**
 * Archetype Detection with Scoring
 */

function detectArchetype(fingerprint: DataFingerprint): ArchetypeDetection {
  const scores: Record<ArchetypeType, number> = {
    overview: scoreOverview(fingerprint),
    time_series: scoreTimeSeries(fingerprint),
    comparison: scoreComparison(fingerprint),
    funnel: scoreFunnel(fingerprint),
    hierarchical: scoreHierarchical(fingerprint),
    distribution: scoreDistribution(fingerprint),
    correlation: scoreCorrelation(fingerprint),
    detail: scoreDetail(fingerprint),
    custom: 0,
  };

  const bestArchetype = Object.entries(scores)
    .sort(([, a], [, b]) => b - a)[0];

  return {
    archetype: bestArchetype[0] as ArchetypeType,
    confidence: bestArchetype[1],
    signals: explainArchetypeScore(bestArchetype[0] as ArchetypeType, fingerprint),
  };
}

function scoreOverview(fp: DataFingerprint): number {
  let score = 0;

  // Has mix of metrics and dimensions
  const metrics = fp.fields.filter(f => ['currency', 'count', 'percentage'].includes(f.primitive));
  const dimensions = fp.fields.filter(f => ['category', 'date'].includes(f.primitive));

  if (metrics.length >= 2) score += 0.3;
  if (dimensions.length >= 1) score += 0.2;

  // Has multiple different primitive types
  const primitiveTypes = new Set(fp.fields.map(f => f.primitive));
  score += primitiveTypes.size * 0.1;

  // Moderate field count (not too simple, not too detailed)
  if (fp.fieldCount >= 4 && fp.fieldCount <= 12) score += 0.2;

  return Math.min(score, 1.0);
}

function scoreTimeSeries(fp: DataFingerprint): number {
  let score = 0;

  // MUST have date field
  const hasDate = fp.fields.some(f => f.primitive === 'date');
  if (!hasDate) return 0;

  score += 0.4;  // Base score for having date

  // Has measures
  const measures = fp.fields.filter(f => ['currency', 'count', 'percentage'].includes(f.primitive));
  if (measures.length >= 1) score += 0.3;
  if (measures.length >= 2) score += 0.2;

  // High row count (time series have many points)
  if (fp.statistics.rowCount > 50) score += 0.1;

  return Math.min(score, 1.0);
}

function scoreComparison(fp: DataFingerprint): number {
  let score = 0;

  // Look for pairs: current/previous, actual/budget, etc.
  const pairPatterns = [
    ['current', 'previous'],
    ['actual', 'budget'],
    ['this', 'last'],
  ];

  for (const [a, b] of pairPatterns) {
    const hasA = fp.fields.some(f => f.name.toLowerCase().includes(a));
    const hasB = fp.fields.some(f => f.name.toLowerCase().includes(b));
    if (hasA && hasB) {
      score += 0.5;
      break;
    }
  }

  // Has exactly 2 numeric fields
  const numerics = fp.fields.filter(f => f.type === 'number');
  if (numerics.length === 2) score += 0.3;

  return Math.min(score, 1.0);
}

// ... similar scoring functions for other archetypes
```

### 3. Pre-Generation Strategy

Add to **§12.6 Pre-Generation Strategy**:

```markdown
## Pre-Generation Triggers

Pre-generation occurs when:

1. **Data source first connected** → Fingerprint + detect archetypes + generate top 3
2. **Schema changes** → Re-fingerprint + invalidate cache + regenerate
3. **Low cache hit rate** (<70%) → Expand predictions + generate more variants
4. **Idle time** → Proactively generate long-tail intents

**Budget:**
- Generate ≤20 fragments per data source
- Total pre-generation latency ≤5s
- Background generation (non-blocking)

**Algorithm:**

```typescript
async function pregenerateFragments(dataSource: DataSource): Promise<void> {
  const startTime = Date.now();
  const budget = 5000; // 5s budget

  // 1. Fingerprint
  const fingerprint = await fingerprintDataSource(dataSource);

  // 2. Detect archetypes
  const archetypeDetection = detectArchetype(fingerprint);

  // 3. Generate top-K intents
  const intents = predictIntents(fingerprint, archetypeDetection, 20);

  // 4. Generate fragments (budget-aware)
  for (const intent of intents) {
    if (Date.now() - startTime > budget) break;

    try {
      const fragment = await generateFragment(intent, fingerprint);
      await cacheFragment(fragment);
    } catch (error) {
      // Log but continue
      logger.warn('Pre-generation failed for intent', { intent, error });
    }
  }
}

function predictIntents(
  fp: DataFingerprint,
  archetype: ArchetypeDetection,
  limit: number
): string[] {
  const intents: string[] = [];

  // Intent templates by archetype
  const templates = {
    overview: [
      `Show ${fp.fields[0].name} overview`,
      `Dashboard for ${fp.fields[0].name}`,
    ],
    time_series: [
      `Show ${fp.fields.find(f => f.primitive === 'currency')?.name} over time`,
      `Trend of ${fp.fields.find(f => f.primitive === 'count')?.name}`,
    ],
    // ... more templates
  };

  // Generate from templates
  const archetypeTemplates = templates[archetype.archetype] || [];
  for (const template of archetypeTemplates) {
    intents.push(template);
  }

  // Add field-based intents
  for (const field of fp.fields) {
    if (field.primitive === 'currency') {
      intents.push(`Show total ${field.name}`);
      intents.push(`Compare ${field.name} by category`);
    }
  }

  return intents.slice(0, limit);
}
```
```

### 4. Performance Requirements

Add to **§12.7 Discovery Performance**:

```markdown
## Discovery Performance Requirements

| Operation | P50 | P95 | P99 | Budget |
|-----------|-----|-----|-----|--------|
| Fingerprinting | <50ms | <100ms | <200ms | 500ms |
| Primitive inference | <10ms | <20ms | <50ms | 100ms |
| Archetype detection | <20ms | <50ms | <100ms | 200ms |
| Intent prediction | <30ms | <60ms | <100ms | 200ms |
| Full discovery | <100ms | <200ms | <500ms | 1000ms |
| Pre-generation (background) | <2s | <5s | <10s | 30s |

**Sample size limits:**
- Max 10,000 rows for fingerprinting
- Max 1,000 rows for statistical analysis
- Max 100 values per field for primitive inference

**Caching:**
- Fingerprints cached by schema hash (1 hour TTL)
- Archetype detections cached (indefinite, invalidate on schema change)
```

---

## Testing Criteria

1. **Fingerprinting Accuracy:**
   - [ ] Primitives detected correctly (>90% accuracy on test corpus)
   - [ ] Archetypes detected correctly (>80% top-3 accuracy)

2. **Performance:**
   - [ ] Meets latency budgets
   - [ ] Handles large datasets (100K+ rows)

3. **Pre-generation:**
   - [ ] Cache hit rate >85% after pre-generation
   - [ ] Stays within budget

---

## Resolution Summary

Complete discovery specification:
1. **Fingerprinting algorithm** - Field extraction, type inference, statistics
2. **Primitive inference** - 8 UOM primitives with detection rules
3. **Archetype detection** - Scoring system for 8 archetypes
4. **Pre-generation strategy** - When/what/how to warm cache
5. **Performance requirements** - Latency budgets for all operations
