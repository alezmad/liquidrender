# ISS-110: Adapter Not Supporting Required Block Type

**Category:** Minor Edge Cases
**Priority:** Medium
**Status:** Resolved

## Issue

What happens when a validated LiquidSchema contains a block type that the selected adapter does not support? How should the system degrade gracefully?

## Resolution

### Block Support Detection

**Adapters declare supported block types via metadata:**

```typescript
interface AdapterMetadata {
  name: string;
  supportedBlockTypes: BlockType[] | 'all';  // Explicit list or universal
  fallbackStrategy: FallbackStrategy;

  // ... other metadata fields
}

type FallbackStrategy =
  | 'placeholder'     // Render placeholder with info
  | 'skip'           // Omit block from layout
  | 'error'          // Throw error (strict mode)
  | 'custom';        // Adapter-defined fallback
```

### Pre-Render Validation

```typescript
function validateAdapterSupport(
  schema: LiquidSchema,
  adapter: LiquidAdapter
): ValidationResult {
  const unsupported: Block[] = [];

  for (const block of schema.blocks) {
    if (!adapter.supports(block.type)) {
      unsupported.push(block);
    }
  }

  return {
    compatible: unsupported.length === 0,
    unsupportedBlocks: unsupported,
    canDegrade: adapter.metadata.fallbackStrategy !== 'error'
  };
}
```

### Fallback Rendering

```typescript
interface LiquidAdapter<T> {
  // Required: check support
  supports(blockType: BlockType): boolean;

  // Required: render placeholder for unsupported types
  renderPlaceholder(block: Block, reason: string): T;

  // Optional: suggest alternative block type
  suggestAlternative?(blockType: BlockType): BlockType | null;
}

// Example placeholder rendering
function renderPlaceholder(block: Block, reason: string): ReactNode {
  return (
    <div className="unsupported-block-placeholder">
      <Icon name="alert-triangle" />
      <h4>Unsupported Block: {block.type}</h4>
      <p>{reason}</p>
      {block.binding && (
        <code>Binding: {JSON.stringify(block.binding.fields)}</code>
      )}
      <button onClick={() => requestBlockTypeChange(block.uid)}>
        Change Block Type
      </button>
    </div>
  );
}
```

### Automatic Substitution

Some adapters can suggest alternatives:

```typescript
interface AdapterMetadata {
  // ... existing fields
  blockTypeAliases?: Record<BlockType, BlockType>;
}

// Example: Mobile adapter doesn't support data-table, uses list instead
const mobileAdapter: AdapterMetadata = {
  name: 'react-native',
  supportedBlockTypes: ['kpi', 'bar-chart', 'line-chart', 'list'],
  blockTypeAliases: {
    'data-table': 'list'  // Substitute table with list
  },
  fallbackStrategy: 'placeholder'
};

// During rendering
function resolveBlockType(
  blockType: BlockType,
  adapter: LiquidAdapter
): BlockType {
  if (adapter.supports(blockType)) {
    return blockType;
  }

  const alias = adapter.metadata.blockTypeAliases?.[blockType];
  if (alias && adapter.supports(alias)) {
    console.warn(`Substituting ${blockType} with ${alias}`);
    return alias;
  }

  return blockType;  // Will render as placeholder
}
```

### User Notification

```typescript
interface RenderResult<T> {
  output: T;
  success: boolean;
  warnings: RenderWarning[];
}

interface RenderWarning {
  type: 'unsupported-block' | 'degraded-feature' | 'substitution';
  blockUid: string;
  message: string;
  suggestion?: string;
}

// Example
const result = adapter.render(schema, data);
// result.warnings = [
//   {
//     type: 'unsupported-block',
//     blockUid: 'b_a7f3c9e2b4d1',
//     message: 'Block type "heatmap" not supported by react-native adapter',
//     suggestion: 'Use "bar-chart" instead or switch to web adapter'
//   }
// ]
```

### Adapter Selection

```typescript
// Engine can auto-select compatible adapter
function selectAdapter(
  schema: LiquidSchema,
  availableAdapters: LiquidAdapter[]
): LiquidAdapter {
  const blockTypes = new Set(schema.blocks.map(b => b.type));

  // Prefer adapter that supports all blocks
  const fullSupport = availableAdapters.find(adapter =>
    [...blockTypes].every(type => adapter.supports(type))
  );

  if (fullSupport) return fullSupport;

  // Fallback: adapter with most coverage
  const scored = availableAdapters.map(adapter => ({
    adapter,
    coverage: [...blockTypes].filter(type => adapter.supports(type)).length
  }));

  return scored.sort((a, b) => b.coverage - a.coverage)[0].adapter;
}
```

### Custom Block Types

For `custom:*` block types:

```typescript
interface LiquidAdapter {
  // Optional: register custom block renderer
  registerCustomBlock?(
    blockType: string,
    renderer: (block: Block, data: any) => RenderOutput
  ): void;
}

// Usage
adapter.registerCustomBlock('custom:heatmap', (block, data) => {
  return <HeatmapComponent data={data} binding={block.binding} />;
});
```

## Specification Impact

**Update §18.1 (Adapter Interface Contract):**

Make `supports()` and `renderPlaceholder()` methods REQUIRED.

**Update §18.2 (Adapter Metadata):**

Add `fallbackStrategy` and optional `blockTypeAliases` fields.

**New section §19.4 (Block Support Degradation):**

Define fallback strategies and substitution rules.

## Related Sections

- §18.1: Core Adapter Interface
- §18.2: Adapter Metadata
- §19.2: Graceful Degradation
- §B.3: Testable Render Guarantee
