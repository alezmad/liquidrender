# Resolution: ISS-092

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Signal with No Subscribers
**Severity:** significant
**Category:** edge-cases
**Target:** SPEC
**Section:** §10 Signal System

## Problem Statement

Behavior when signals have no subscribers is undefined. The specification describes signal emission and reception (§10.3-10.4) but does not define what happens when:

1. A signal is declared but never received by any block
2. A block emits a signal that no other block listens to
3. All receivers are removed/hidden but emitter remains
4. A signal is in the registry but never emitted or received

This creates ambiguity around:
- Whether unused signals consume resources
- Whether emitting to no subscribers is an error
- How to handle orphaned signal declarations
- Memory management for signal state

## Resolution

### Specification Addition

Add the following subsection to §10 Signal System, after §10.7 Signal Inheritance:

#### §10.8 Signal Lifecycle and Orphaned Signals

Signals follow a **lazy initialization** model. Declared signals that have no emitters or receivers are inert and consume minimal resources.

**Signal States:**

| State | Emitters | Receivers | Behavior | Resource Cost |
|-------|----------|-----------|----------|---------------|
| **Dormant** | 0 | 0 | Declaration exists, no runtime state | None (zero allocation) |
| **Emit-only** | ≥1 | 0 | Emits to void, value stored for persistence | Minimal (state only if persisted) |
| **Receive-only** | 0 | ≥1 | Receivers use default value | Minimal (default value only) |
| **Active** | ≥1 | ≥1 | Normal signal flow | Normal (state + subscriptions) |

**Lifecycle Rules:**

```typescript
interface SignalLifecycle {
  name: string;
  state: 'dormant' | 'emit-only' | 'receive-only' | 'active';
  emitterCount: number;
  receiverCount: number;
  hasValue: boolean;
  isPersisted: boolean;
}

function determineSignalState(
  signal: SignalDefinition,
  blocks: Block[]
): SignalLifecycle {
  const emitters = blocks.filter(b =>
    b.signals?.emits?.some(e => e.signal === signal.name)
  );
  const receivers = blocks.filter(b =>
    b.signals?.receives?.some(r => r.signal === signal.name)
  );

  const lifecycle: SignalLifecycle = {
    name: signal.name,
    emitterCount: emitters.length,
    receiverCount: receivers.length,
    hasValue: signal.default !== undefined,
    isPersisted: signal.persist !== 'none',
    state: 'dormant',
  };

  if (lifecycle.emitterCount > 0 && lifecycle.receiverCount > 0) {
    lifecycle.state = 'active';
  } else if (lifecycle.emitterCount > 0) {
    lifecycle.state = 'emit-only';
  } else if (lifecycle.receiverCount > 0) {
    lifecycle.state = 'receive-only';
  }

  return lifecycle;
}
```

**Behavior by State:**

**1. Dormant Signals:**

```typescript
// Signal declared but never used
signals: {
  unusedFilter: { type: 'filter', default: {} }
}

// Behavior:
// - No runtime allocation (not initialized)
// - No subscription management
// - No persistence (even if persist specified)
// - Warning emitted at compile time
```

**2. Emit-Only Signals:**

```typescript
// Signal emitted but no receivers
signals: {
  dateRange: { type: 'dateRange', default: '30d', persist: 'url' }
}
blocks: [
  { type: 'date-filter', signals: { emits: [{ signal: 'dateRange' }] } }
  // No blocks receive dateRange
]

// Behavior:
// - Emitter functions normally
// - Value stored in signal runtime
// - Persistence honored (URL updated if persist: 'url')
// - Warning emitted: "Signal 'dateRange' has no subscribers"
// - No error, rendering continues
```

**3. Receive-Only Signals:**

```typescript
// Signal received but never emitted
signals: {
  category: { type: 'selection', default: 'all' }
}
blocks: [
  { type: 'kpi', signals: { receives: [{ signal: 'category', target: 'filter.category' }] } }
  // No blocks emit category
]

// Behavior:
// - Receivers use default value
// - Default value never changes (no emitter to update it)
// - If default undefined, receivers get null
// - Warning emitted: "Signal 'category' has no emitters"
// - No error, rendering continues
```

**4. Active Signals:**

```typescript
// Normal case: signal emitted and received
signals: {
  dateRange: { type: 'dateRange', default: '30d' }
}
blocks: [
  { type: 'date-filter', signals: { emits: [{ signal: 'dateRange' }] } },
  { type: 'kpi', signals: { receives: [{ signal: 'dateRange' }] } }
]

// Behavior:
// - Full signal flow
// - Value propagates from emitter to receivers
// - Normal resource allocation
```

**Compilation Warnings:**

The compiler SHOULD emit warnings for unused signals to help developers identify configuration issues:

```typescript
interface SignalWarning {
  severity: 'info' | 'warning';
  code: 'SIGNAL_DORMANT' | 'SIGNAL_EMIT_ONLY' | 'SIGNAL_RECEIVE_ONLY';
  signal: string;
  message: string;
  suggestion: string;
}

function checkSignalUsage(schema: LiquidSchema): SignalWarning[] {
  const warnings: SignalWarning[] = [];

  for (const [name, signal] of Object.entries(schema.signals || {})) {
    const lifecycle = determineSignalState(signal, schema.blocks);

    switch (lifecycle.state) {
      case 'dormant':
        warnings.push({
          severity: 'info',
          code: 'SIGNAL_DORMANT',
          signal: name,
          message: `Signal '${name}' is declared but never used`,
          suggestion: 'Remove unused signal declaration or add emitters/receivers',
        });
        break;

      case 'emit-only':
        warnings.push({
          severity: 'warning',
          code: 'SIGNAL_EMIT_ONLY',
          signal: name,
          message: `Signal '${name}' is emitted but has no receivers`,
          suggestion: lifecycle.isPersisted
            ? 'Signal is persisted but has no effect on UI. Add receivers or remove signal.'
            : 'Add receivers to respond to this signal or remove the emitter',
        });
        break;

      case 'receive-only':
        warnings.push({
          severity: 'warning',
          code: 'SIGNAL_RECEIVE_ONLY',
          signal: name,
          message: `Signal '${name}' is received but never emitted`,
          suggestion: lifecycle.hasValue
            ? `Receivers will always use default value: ${JSON.stringify(signal.default)}`
            : 'Add an emitter or remove receivers (they will always receive null)',
        });
        break;
    }
  }

  return warnings;
}
```

**Runtime Behavior:**

Signal runtime MUST handle orphaned signals gracefully:

```typescript
class SignalRuntime {
  private values: Map<string, any> = new Map();
  private subscriptions: Map<string, Set<Callback>> = new Map();

  // Emit to signal with no subscribers
  set(signalName: string, value: any): void {
    // Store value even if no subscribers
    this.values.set(signalName, value);

    // Notify subscribers (may be empty set)
    const subscribers = this.subscriptions.get(signalName) || new Set();

    if (subscribers.size === 0) {
      // Emit-only case: log debug message
      console.debug(`Signal '${signalName}' emitted with no subscribers`);
    }

    for (const callback of subscribers) {
      callback(value);
    }

    // Handle persistence regardless of subscribers
    this.persist(signalName, value);
  }

  // Subscribe to signal that may never emit
  subscribe(signalName: string, callback: Callback): Unsubscribe {
    if (!this.subscriptions.has(signalName)) {
      this.subscriptions.set(signalName, new Set());
    }

    this.subscriptions.get(signalName)!.add(callback);

    // Immediately call with current value (or default)
    const currentValue = this.values.get(signalName);
    if (currentValue !== undefined) {
      callback(currentValue);
    }

    return () => {
      this.subscriptions.get(signalName)?.delete(callback);

      // Cleanup empty subscription sets
      if (this.subscriptions.get(signalName)?.size === 0) {
        this.subscriptions.delete(signalName);
      }
    };
  }

  // Get value of signal that may be dormant
  get(signalName: string): any {
    return this.values.get(signalName);
  }
}
```

**Persistence Behavior:**

Signals with `persist` set are stored even if they have no subscribers:

| Persist Mode | Emit-Only Behavior | Receive-Only Behavior | Dormant Behavior |
|--------------|-------------------|----------------------|------------------|
| `url` | Updates URL when emitted | Reads from URL on mount | Not persisted |
| `session` | Stores in sessionStorage | Reads from sessionStorage | Not persisted |
| `local` | Stores in localStorage | Reads from localStorage | Not persisted |
| `none` | Value discarded | Uses default only | Not persisted |

**Dynamic Subscriber Changes:**

Signals can transition between states as blocks are added/removed:

```typescript
// Initial: emit-only (no receivers)
// Block A emits dateRange
// No receivers

// User adds Block B which receives dateRange
// Signal transitions: emit-only → active
// Immediately receives current value from emitter

// User hides Block B (but doesn't remove)
// Signal remains active (block still exists)

// User removes Block B
// Signal transitions: active → emit-only
// Emitter continues emitting to void
```

**Memory Management:**

To prevent memory leaks with orphaned signals:

```typescript
interface SignalCleanupPolicy {
  removeOrphanedDeclarations: boolean;     // Remove dormant signals
  cleanupEmitOnly: boolean;                // Cleanup emit-only after timeout
  cleanupReceiveOnly: boolean;             // Remove receive-only subscriptions
}

const DEFAULT_CLEANUP_POLICY: SignalCleanupPolicy = {
  removeOrphanedDeclarations: true,        // Remove dormant on compile
  cleanupEmitOnly: false,                   // Keep (may be intentional for persistence)
  cleanupReceiveOnly: true,                // Remove (no purpose)
};

function cleanupOrphanedSignals(
  schema: LiquidSchema,
  policy: SignalCleanupPolicy = DEFAULT_CLEANUP_POLICY
): LiquidSchema {
  const cleaned = { ...schema };

  if (policy.removeOrphanedDeclarations) {
    // Remove dormant signals
    const lifecycles = Object.keys(schema.signals || {}).map(name =>
      determineSignalState(schema.signals![name], schema.blocks)
    );

    cleaned.signals = Object.fromEntries(
      Object.entries(schema.signals || {}).filter(([name]) => {
        const lifecycle = lifecycles.find(l => l.name === name);
        return lifecycle?.state !== 'dormant';
      })
    );
  }

  return cleaned;
}
```

### Integration Points

1. **Signal System (§10)** - Defines lifecycle for all signal states
2. **Adapter Contract (§18)** - Signal runtime must handle zero subscribers gracefully
3. **Compilation Pipeline (§17)** - Add signal usage analysis phase
4. **Error Handling (§19)** - Orphaned signals are warnings, not errors

### Examples

**Example 1: Dormant Signal (Removed)**

```liquidcode
# Signal declared but never used
§search:str=,none
K$revenue
K$orders

# Compilation:
# - Detects search signal is dormant (no emitters, no receivers)
# - Emits info: "Signal 'search' is declared but never used"
# - Removes from compiled schema (cleanup policy)

# Compiled schema:
{
  "signals": {},  // search removed
  "blocks": [...]
}
```

**Example 2: Emit-Only Signal (Persisted)**

```liquidcode
# Signal emitted but no receivers
§dateRange:dr=30d,url
DF<>@dateRange
K$revenue  # Does not receive dateRange

# Compilation:
# - Detects dateRange has emitter but no receivers
# - Emits warning: "Signal 'dateRange' is emitted but has no receivers"
# - Keeps signal (persisted to URL)

# Runtime:
# - User changes date filter
# - Signal emits new value
# - URL updates: ?dateRange=2024-01-01,2024-12-31
# - No blocks update (no receivers)
# - No error
```

**Example 3: Receive-Only Signal (Default Value)**

```liquidcode
# Signal received but never emitted
§category:sel=all,session
K$revenue<@category  # Receives category

# Compilation:
# - Detects category has receiver but no emitter
# - Emits warning: "Signal 'category' is received but never emitted"
# - Suggests: "Receivers will always use default value: 'all'"

# Runtime:
# - KPI always filters by category='all' (default)
# - Category never changes (no emitter)
# - No error
```

**Example 4: Dynamic Transition**

```liquidcode
# Start with emit-only
§search:str=,none
SI<>@search
K$revenue  # No receiver initially

# User adds mutation:
Δ~@K0<@search→filter.name

# Signal transitions: emit-only → active
# - KPI now receives search signal
# - Immediately gets current search value
# - Updates filter accordingly
```

## Verification Checklist

- [x] **All orphan states defined**
  - Dormant (no emitters, no receivers)
  - Emit-only (emitters, no receivers)
  - Receive-only (no emitters, receivers)
  - Dynamic transitions between states
- [x] **Clear behavior for each state**
  - Resource allocation specified
  - Persistence behavior defined
  - Warning/error behavior specified
- [x] **Memory management**
  - Cleanup policies defined
  - No memory leaks
  - Efficient resource usage
- [x] **Graceful degradation**
  - No errors for orphaned signals
  - Warnings help debugging
  - Runtime handles all cases
- [x] **Integration defined**
  - Signal runtime interface
  - Compilation warning system
  - Cleanup policies

## Confidence

**HIGH** - This resolution:

1. **Addresses root cause** - Defines complete lifecycle for all signal states including orphaned cases
2. **Follows spec patterns** - Uses warning system (§19), lazy initialization (matches overall philosophy)
3. **Graceful behavior** - No errors for orphaned signals, only helpful warnings
4. **Prevents resource leaks** - Clear cleanup policies and memory management
5. **User-friendly** - Warnings explain why signal has no effect and suggest fixes
6. **Testable** - Deterministic state transitions and cleanup behavior
7. **Consistent** - Signal behavior predictable regardless of subscriber count
