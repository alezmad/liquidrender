# Resolution: ISS-094

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Conflicting Priority Assignments
**Severity:** significant
**Category:** edge-cases
**Target:** SPEC
**Section:** §11 Layout & Responsiveness System

## Problem Statement

Resolution of conflicting layout priorities is undefined. The specification defines priority levels (§11.3) but does not specify what happens when:

1. Multiple blocks claim the same priority level (e.g., three blocks marked `hero`)
2. Priority conflicts with layout constraints (e.g., grid can only show N blocks at once)
3. Relationship groups conflict with priority (e.g., grouped blocks have different priorities)
4. Breakpoint-specific priorities override base priorities
5. Nested blocks inherit or override parent priorities

Without defined conflict resolution, adapters may:
- Show different results for the same schema
- Have unpredictable responsive behavior
- Hide wrong blocks when space is limited

## Resolution

### Specification Addition

Add the following subsection to §11 Layout & Responsiveness System, after §11.15 Layout Examples by Context:

#### §11.16 Priority Conflict Resolution

When multiple blocks have the same priority level, or when priorities conflict with layout constraints, the system uses **deterministic tie-breaking** rules.

**Priority Conflict Scenarios:**

| Scenario | Example | Resolution |
|----------|---------|------------|
| Multiple blocks same priority | Three blocks all marked `hero` | Ordinal tie-breaker (first in schema wins) |
| Priority vs. layout capacity | 5 hero blocks, grid shows max 4 | Ordinal tie-breaker for 5th |
| Grouped blocks, different priorities | Group has hero + secondary | Use highest priority in group |
| Breakpoint-specific override | Base: hero, compact: secondary | Breakpoint-specific wins |
| Nested block priority | Parent: hero, child: secondary | Child inherits parent priority unless explicit |

**Conflict Resolution Algorithm:**

```typescript
interface PriorityResolution {
  blockUid: string;
  declaredPriority?: Priority;
  effectivePriority: Priority;
  visibleAtBreakpoint: Record<Breakpoint, boolean>;
  reason: string;
}

type Priority = 1 | 2 | 3 | 4 | 'hero' | 'primary' | 'secondary' | 'detail';
type Breakpoint = 'compact' | 'standard' | 'expanded';

function resolvePriorityConflicts(
  blocks: Block[],
  breakpoint: Breakpoint,
  layoutCapacity: LayoutCapacity
): PriorityResolution[] {
  const resolutions: PriorityResolution[] = [];

  // Normalize priorities (hero → 1, primary → 2, etc.)
  const normalized = blocks.map(block => ({
    block,
    priority: normalizePriority(block.layout?.priority),
    ordinal: blocks.indexOf(block),
  }));

  // Sort by priority (lower number = higher priority), then by ordinal
  normalized.sort((a, b) => {
    if (a.priority !== b.priority) {
      return a.priority - b.priority;
    }
    return a.ordinal - b.ordinal; // Tie-breaker: schema order
  });

  // Apply layout capacity constraints
  let remainingCapacity = layoutCapacity.maxVisible[breakpoint];

  for (const { block, priority, ordinal } of normalized) {
    const visible = remainingCapacity > 0 &&
                    isVisibleAtPriority(priority, breakpoint);

    if (visible) {
      remainingCapacity--;
    }

    resolutions.push({
      blockUid: block.uid,
      declaredPriority: block.layout?.priority,
      effectivePriority: priority,
      visibleAtBreakpoint: {
        compact: isVisibleAtPriority(priority, 'compact'),
        standard: isVisibleAtPriority(priority, 'standard'),
        expanded: isVisibleAtPriority(priority, 'expanded'),
      },
      reason: visible
        ? `Visible (priority ${priority}, ordinal ${ordinal})`
        : `Hidden (${remainingCapacity === 0 ? 'capacity exceeded' : 'breakpoint filter'})`,
    });
  }

  return resolutions;
}

function normalizePriority(priority?: Priority): number {
  if (priority === undefined) return 2; // Default: primary
  if (priority === 'hero') return 1;
  if (priority === 'primary') return 2;
  if (priority === 'secondary') return 3;
  if (priority === 'detail') return 4;
  return priority; // Already numeric
}

function isVisibleAtPriority(priority: number, breakpoint: Breakpoint): boolean {
  // Visibility rules by breakpoint
  const rules = {
    compact: [1], // Only hero (priority 1)
    standard: [1, 2], // Hero + primary (1-2)
    expanded: [1, 2, 3, 4], // All priorities
  };

  return rules[breakpoint].includes(priority);
}
```

**Ordinal Tie-Breaker:**

When multiple blocks have the same priority, schema order (ordinal) determines precedence:

```typescript
// Schema order determines tie-breaking
blocks: [
  { uid: 'b_1', type: 'kpi', layout: { priority: 'hero' } },      // Wins tie
  { uid: 'b_2', type: 'kpi', layout: { priority: 'hero' } },      // Second
  { uid: 'b_3', type: 'kpi', layout: { priority: 'hero' } },      // Third
]

// In compact breakpoint (capacity: 1):
// - b_1 visible (hero, ordinal 0)
// - b_2 hidden (hero, ordinal 1 - capacity exceeded)
// - b_3 hidden (hero, ordinal 2 - capacity exceeded)
```

**Group Priority Resolution:**

Grouped blocks (§11.5) are treated as a single unit with the **highest priority** in the group:

```typescript
interface RelationshipSpec {
  type: 'group' | 'compare' | 'detail' | 'flow';
  with?: string[];
}

function resolveGroupPriority(group: Block[]): number {
  // Group priority = highest (lowest numeric) priority in group
  const priorities = group.map(b =>
    normalizePriority(b.layout?.priority)
  );

  return Math.min(...priorities);
}

// Example:
const group = [
  { priority: 'hero' },      // Priority 1
  { priority: 'secondary' }, // Priority 3
  { priority: 'primary' },   // Priority 2
];

// Group effective priority: 1 (hero - highest in group)
// All members visible/hidden together based on group priority
```

**Breakpoint Override:**

Explicit breakpoint overrides (§11.13) take precedence over base priority:

```typescript
interface BreakpointPriorityOverride {
  breakpoint: Breakpoint;
  priority: Priority;
}

// Example: Different priority per breakpoint
{
  layout: {
    priority: 'hero',  // Base priority
    breakpoints: {
      compact: { priority: 'secondary' },   // Override for compact
      standard: { priority: 'primary' },    // Override for standard
      expanded: { priority: 'hero' },       // Explicit (same as base)
    }
  }
}

function getEffectivePriority(
  block: Block,
  breakpoint: Breakpoint
): number {
  // Check for breakpoint-specific override
  const override = block.layout?.breakpoints?.[breakpoint]?.priority;
  if (override !== undefined) {
    return normalizePriority(override);
  }

  // Fall back to base priority
  return normalizePriority(block.layout?.priority);
}
```

**Nested Block Priority Inheritance:**

Nested blocks (in slots) inherit parent priority unless explicitly overridden:

```typescript
function resolveNestedPriority(
  block: Block,
  parent?: Block
): number {
  // Explicit priority on block always wins
  if (block.layout?.priority !== undefined) {
    return normalizePriority(block.layout.priority);
  }

  // Inherit from parent if no explicit priority
  if (parent?.layout?.priority !== undefined) {
    return normalizePriority(parent.layout.priority);
  }

  // Default: primary
  return 2;
}

// Example:
{
  uid: 'parent',
  type: 'grid',
  layout: { priority: 'hero' },
  slots: {
    children: [
      { uid: 'child1', type: 'kpi' },                          // Inherits hero
      { uid: 'child2', type: 'kpi', layout: { priority: 3 } }, // Explicit: 3
    ]
  }
}

// Effective priorities:
// - parent: 1 (hero)
// - child1: 1 (inherited from parent)
// - child2: 3 (explicit)
```

**Layout Capacity Constraints:**

Different layouts have different capacity at each breakpoint:

```typescript
interface LayoutCapacity {
  maxVisible: Record<Breakpoint, number>;
  strategy: 'truncate' | 'scroll' | 'paginate' | 'collapse';
}

function getLayoutCapacity(
  layout: LayoutBlock,
  breakpoint: Breakpoint
): LayoutCapacity {
  if (layout.type === 'grid') {
    const config = layout.responsive?.breakpoints?.[breakpoint];
    const columns = config?.columns || inferColumns(layout, breakpoint);
    const rows = estimateRows(layout.children.length, columns);

    return {
      maxVisible: {
        compact: columns * Math.min(rows, 3),   // Max 3 rows on compact
        standard: columns * Math.min(rows, 5),  // Max 5 rows on standard
        expanded: layout.children.length,       // All visible on expanded
      },
      strategy: 'scroll',
    };
  }

  if (layout.type === 'stack') {
    return {
      maxVisible: {
        compact: 3,     // Show top 3
        standard: 10,   // Show top 10
        expanded: Infinity, // All
      },
      strategy: 'collapse',
    };
  }

  // Default: show all
  return {
    maxVisible: {
      compact: Infinity,
      standard: Infinity,
      expanded: Infinity,
    },
    strategy: 'truncate',
  };
}
```

**Conflict Warning System:**

Compiler SHOULD emit warnings when priority conflicts are resolved via tie-breaking:

```typescript
interface PriorityConflictWarning {
  severity: 'info';
  code: 'PRIORITY_TIE_BREAKER' | 'CAPACITY_EXCEEDED' | 'GROUP_PRIORITY_MIXED';
  blocks: string[];
  breakpoint?: Breakpoint;
  message: string;
}

function detectPriorityConflicts(
  resolutions: PriorityResolution[]
): PriorityConflictWarning[] {
  const warnings: PriorityConflictWarning[] = [];

  // Detect multiple blocks with same priority
  const byPriority = new Map<number, PriorityResolution[]>();
  for (const res of resolutions) {
    const priority = res.effectivePriority;
    if (!byPriority.has(priority)) {
      byPriority.set(priority, []);
    }
    byPriority.get(priority)!.push(res);
  }

  for (const [priority, blocks] of byPriority) {
    if (blocks.length > 1 && priority === 1) { // Multiple hero
      warnings.push({
        severity: 'info',
        code: 'PRIORITY_TIE_BREAKER',
        blocks: blocks.map(b => b.blockUid),
        message: `Multiple blocks marked as 'hero' (priority ${priority}). ` +
                 `Using schema order to break tie. First block wins.`,
      });
    }
  }

  // Detect capacity exceeded
  const hidden = resolutions.filter(r =>
    r.reason.includes('capacity exceeded')
  );

  if (hidden.length > 0) {
    warnings.push({
      severity: 'info',
      code: 'CAPACITY_EXCEEDED',
      blocks: hidden.map(r => r.blockUid),
      message: `${hidden.length} blocks hidden due to layout capacity constraints. ` +
               `Consider increasing grid size or using pagination.`,
    });
  }

  return warnings;
}
```

**Deterministic Guarantee:**

Priority conflict resolution MUST be deterministic:

> **Guarantee:** Given the same schema and breakpoint, priority resolution produces the same visibility decisions every time.

This is ensured by:
1. Ordinal tie-breaker uses stable schema order (UID-based traversal)
2. Priority normalization is pure function
3. No randomness or timestamps in resolution
4. Capacity constraints are deterministic

### Integration Points

1. **Layout System (§11)** - Priority resolution integrated into responsive transformation
2. **Compilation Pipeline (§17)** - Priority conflict detection in validation phase
3. **Adapter Contract (§18)** - Adapters use resolved priorities for rendering
4. **Digital Twin (§16)** - Track priority resolutions in metadata

### Examples

**Example 1: Multiple Hero Blocks (Tie-Breaker)**

```liquidcode
# Three blocks marked hero
K$revenue!hero
K$orders!hero
K$profit!hero

# Compact breakpoint (capacity: 1)
# Resolution:
# - revenue: visible (hero, ordinal 0) ✓
# - orders: hidden (hero, ordinal 1 - capacity exceeded)
# - profit: hidden (hero, ordinal 2 - capacity exceeded)

# Warning emitted:
"Multiple blocks marked as 'hero'. Using schema order to break tie."
```

**Example 2: Group with Mixed Priorities**

```liquidcode
# Grouped blocks with different priorities
[K$revenue!hero K$orders!2 K$profit!3]=group

# Group resolution:
# - Group priority: 1 (hero - highest in group)
# - All members treated as priority 1
# - Group visible/hidden as unit

# Compact breakpoint:
# - Entire group visible (hero priority)

# Standard breakpoint:
# - Entire group visible (hero priority)
```

**Example 3: Breakpoint Override**

```liquidcode
# Base hero, but secondary on compact
K$revenue!hero @compact:!secondary

# Priority resolution:
# - Expanded: hero (1)
# - Standard: hero (1)
# - Compact: secondary (3) - override

# Compact breakpoint:
# - Revenue hidden (secondary not shown on compact)
```

**Example 4: Nested Inheritance**

```liquidcode
# Parent grid is hero, children inherit
G!hero{
  K$revenue      # Inherits hero (1)
  K$orders!3     # Explicit: secondary (3)
}

# Priority resolution:
# - Grid: 1 (hero)
# - revenue: 1 (inherited from grid)
# - orders: 3 (explicit override)

# Compact breakpoint (shows only hero):
# - Grid: visible (hero)
# - revenue: visible (hero, inside visible parent)
# - orders: hidden (secondary not shown on compact)
```

**Example 5: Capacity Exceeded**

```liquidcode
# 10 blocks, but grid shows max 6 on standard
G2x3;K$a!1,K$b!1,K$c!1,K$d!1,K$e!1,K$f!1,K$g!2,K$h!2,K$i!2,K$j!2

# Standard breakpoint (2x3 grid = 6 capacity):
# Resolution (priority, ordinal):
# 1. a: visible (1, 0)
# 2. b: visible (1, 1)
# 3. c: visible (1, 2)
# 4. d: visible (1, 3)
# 5. e: visible (1, 4)
# 6. f: visible (1, 5)
# 7. g: hidden (2, 6 - capacity exceeded)
# 8. h: hidden (2, 7 - capacity exceeded)
# 9. i: hidden (2, 8 - capacity exceeded)
# 10. j: hidden (2, 9 - capacity exceeded)

# Warning:
"4 blocks hidden due to layout capacity constraints. Consider increasing grid size."
```

## Verification Checklist

- [x] **All conflict scenarios covered**
  - Multiple blocks same priority
  - Priority vs. layout capacity
  - Grouped blocks with mixed priorities
  - Breakpoint overrides
  - Nested block inheritance
- [x] **Deterministic resolution**
  - Ordinal tie-breaker uses stable schema order
  - No randomness in algorithm
  - Same input = same output guaranteed
- [x] **Clear precedence rules**
  - Breakpoint-specific > base priority
  - Explicit > inherited
  - Group uses highest priority in group
  - Ordinal breaks ties
- [x] **User-friendly warnings**
  - Detect and report conflicts
  - Explain resolution decisions
  - Suggest alternatives
- [x] **Integration defined**
  - Layout system integration
  - Warning system
  - Metadata tracking

## Confidence

**HIGH** - This resolution:

1. **Addresses root cause** - Defines complete conflict resolution for all priority scenarios
2. **Deterministic** - Same schema always produces same visibility decisions (critical for caching)
3. **Follows spec patterns** - Uses ordinal addressing (§8), relationship groups (§11.5), breakpoint overrides (§11.13)
4. **User-friendly** - Clear warnings explain why blocks are hidden and suggest fixes
5. **Testable** - Deterministic algorithm with specific test cases
6. **Comprehensive** - Handles capacity constraints, nested blocks, groups, overrides
7. **Backward compatible** - Default behavior (no conflicts) unchanged
