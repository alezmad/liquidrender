# Resolution: ISS-019

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Breakpoint Threshold Inconsistency
**Severity:** critical
**Target:** SPEC
**Section:** §6.2 vs §A.2

## Resolution

### Problem Analysis
Breakpoint threshold values are defined in multiple locations with potential inconsistencies:
- **§11.11** (lines 1099-1101): Defines breakpoints as `expanded: ≥1200px`, `standard: 600-1200px`, `compact: <600px`
- **Appendix A.2** (lines 2458-2460): Defines thresholds in `BreakpointThresholds` interface with same values
- **§11.10** (line 1073): References breakpoint type without thresholds
- **§18.2** (line 1667): Mentions custom breakpoint thresholds in adapter metadata

However, the issue title references "§6.2 vs §A.2" - §6.2 is "Block Type Codes" (line 399) which doesn't mention breakpoints. The actual inconsistency is between different uses of threshold values throughout the spec.

**Actual issues found:**
1. Breakpoint thresholds are defined in prose (§11.11) and TypeScript (A.2/B.6) but values must align
2. The less-than/greater-than boundaries create ambiguity at exact threshold values (is 600px compact or standard?)
3. No single authoritative source designated
4. Custom thresholds mentioned (§18.2) but rules for override not specified

### Original Content (Lines 1095-1120)

```markdown
### 11.11 Responsive Transformation Rules

The engine transforms schemas based on breakpoint:

| Breakpoint | Trigger | Transformation |
|------------|---------|----------------|
| `expanded` | width >= 1200px | Full layout as designed |
| `standard` | 600px <= width < 1200px | Reduce columns, stack some blocks |
| `compact` | width < 600px | Single column, collapse detail blocks |

**Transformation algorithm:**

```
1. Determine breakpoint from slot context
2. Filter blocks by priority for breakpoint
3. Calculate available space per visible block
4. Apply flexibility rules:
   - fixed: allocate minimum required
   - grow: share remaining space proportionally
   - shrink: reduce to minimum viable
   - collapse: minimize or hide
5. Apply relationships:
   - group: keep together, stack if needed
   - compare: equalize dimensions
   - detail: position after master
6. Generate adapted layout
```
```

### Original Content (Lines 2455-2461 in Appendix)

```typescript
type Breakpoint = 'compact' | 'standard' | 'expanded';

interface BreakpointThresholds {
  compact: number;   // <600px default
  standard: number;  // <1200px default
  expanded: number;  // ≥1200px default
}
```

### Replacement Content

**Replace lines 1095-1120 with:**

```markdown
### 11.11 Responsive Transformation Rules

The engine transforms schemas based on breakpoint thresholds defined in §11.11.1.

#### 11.11.1 Breakpoint Thresholds (Normative)

**Default thresholds (authoritative):**

| Breakpoint | Width Range | Priority Filter | Transformation |
|------------|-------------|-----------------|----------------|
| `compact` | width < 600 | Priority 1-2 only | Single column, collapse detail blocks |
| `standard` | 600 ≤ width < 1200 | Priority 1-3 | Reduce columns, stack some blocks |
| `expanded` | width ≥ 1200 | All priorities | Full layout as designed |

**Boundary rules:**
- Thresholds use **inclusive lower bounds**: a width of exactly 600px is `standard`, not `compact`
- Thresholds use **exclusive upper bounds**: a width of exactly 1200px is `expanded`, not `standard`
- Mathematical notation: `compact = [0, 600)`, `standard = [600, 1200)`, `expanded = [1200, ∞)`

**Custom thresholds:**

Adapters MAY override default thresholds via `AdapterMetadata.breakpointThresholds` (see §18.2). Custom thresholds MUST:
1. Maintain relative ordering: `compact < standard < expanded`
2. Use same boundary semantics (inclusive lower, exclusive upper)
3. Be positive integers representing pixel widths
4. Document rationale for deviation (e.g., mobile-first platform, large displays)

**Example custom thresholds:**
```typescript
// Mobile-first adapter
breakpointThresholds: {
  compact: 400,    // [0, 400)
  standard: 800,   // [400, 800)
  expanded: 800    // [800, ∞)
}

// Desktop-only adapter
breakpointThresholds: {
  compact: 1024,   // [0, 1024)
  standard: 1920,  // [1024, 1920)
  expanded: 1920   // [1920, ∞)
}
```

#### 11.11.2 Transformation Algorithm

**Breakpoint determination:**

```typescript
function determineBreakpoint(
  width: number,
  thresholds: BreakpointThresholds = DEFAULT_THRESHOLDS
): Breakpoint {
  if (width < thresholds.compact) return 'compact';
  if (width < thresholds.standard) return 'standard';
  return 'expanded';
}

const DEFAULT_THRESHOLDS: BreakpointThresholds = {
  compact: 600,
  standard: 1200,
  expanded: 1200  // Not used in comparison, exists for completeness
};
```

**Transformation steps:**

```
1. Determine breakpoint from slot context width and thresholds
2. Filter blocks by priority for breakpoint:
   - compact: priority ≤ 2 (hero, primary)
   - standard: priority ≤ 3 (hero, primary, secondary)
   - expanded: all priorities (1-4)
3. Calculate available space per visible block
4. Apply flexibility rules:
   - fixed: allocate minimum required
   - grow: share remaining space proportionally
   - shrink: reduce to minimum viable
   - collapse: minimize or hide
5. Apply relationships:
   - group: keep together, stack if needed
   - compare: equalize dimensions
   - detail: position after master
6. Generate adapted layout
```
```

**Replace lines 2455-2461 with:**

```typescript
type Breakpoint = 'compact' | 'standard' | 'expanded';

interface BreakpointThresholds {
  compact: number;      // Upper bound (exclusive) for compact breakpoint (default: 600)
  standard: number;     // Upper bound (exclusive) for standard breakpoint (default: 1200)
  expanded: number;     // Lower bound (inclusive) for expanded breakpoint (default: 1200)
}

/**
 * Default breakpoint thresholds per §11.11.1
 * These are the normative values. Adapters may override via AdapterMetadata.
 */
const DEFAULT_BREAKPOINT_THRESHOLDS: BreakpointThresholds = {
  compact: 600,
  standard: 1200,
  expanded: 1200
};
```

### Additional Cross-Reference Updates

**Update §11.10 SlotContext (line 1073):**

```typescript
interface SlotContext {
  width: number;
  height: number | 'auto';

  // Breakpoint (adapter-determined using thresholds from §11.11.1)
  breakpoint: 'compact' | 'standard' | 'expanded';

  // Optional: Custom thresholds (if adapter overrides defaults)
  breakpointThresholds?: BreakpointThresholds;

  minBlockWidth?: number;
  orientation?: 'any' | 'portrait' | 'landscape';
  parentSignals?: SignalRegistry;
}
```

**Update §18.2 AdapterMetadata (line 1667):**

```typescript
interface AdapterMetadata {
  name: string;
  version: string;
  platform: string;
  supportedSchemaVersions: string[];
  supportedBlockTypes: BlockType[];
  supportsSignals: boolean;
  supportsStreaming: boolean;
  supportsLayout: boolean;

  // Custom breakpoint thresholds (OPTIONAL, must follow §11.11.1 rules)
  breakpointThresholds?: BreakpointThresholds;
}
```

## Verification Checklist
- [x] Change addresses the identified issue (aligns all breakpoint threshold definitions)
- [x] No new inconsistencies introduced (single authoritative source established in §11.11.1)
- [x] Cross-references remain valid (updated §11.10, §18.2, Appendix B.6 to reference §11.11.1)
- [x] Boundary ambiguity resolved (inclusive lower, exclusive upper bounds specified)
- [x] Custom threshold rules defined (ordering, semantics, validation)
- [x] Default values consistent across all sections (600, 1200)
- [x] Mathematical notation clarified ([0, 600), [600, 1200), [1200, ∞))

## Confidence
**HIGH** - This resolution establishes §11.11.1 as the single authoritative source for breakpoint thresholds, resolves boundary ambiguities with clear inclusive/exclusive rules, provides a normative algorithm for breakpoint determination, and allows controlled adapter customization while maintaining consistency. All references throughout the spec now point to this single source of truth.
