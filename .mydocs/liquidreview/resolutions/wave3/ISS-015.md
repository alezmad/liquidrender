# Resolution: ISS-015

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Discovery Engine - Pre-Generation Strategy
**Severity:** minor
**Target:** SPEC
**Section:** §14.3 (Cache Warming Strategy)

## Resolution

### Original Content

Section §14.3 provides only high-level cache warming description:

```markdown
### 14.3 Cache Warming Strategy

```
On data source connection:
  1. Fingerprint schema
  2. Detect archetypes
  3. Predict top 20 intents
  4. Pre-generate fragments for each
  5. Store in cache with high TTL

On first user query:
  6. Cache hit expected 85%+ of time
```
```

No algorithms for intent prediction, fragment prioritization, or pre-generation execution strategy.

### Replacement Content

**Replace §14.3 with comprehensive pre-generation specification:**

```markdown
### 14.3 Cache Warming Strategy

#### 14.3.1 Pre-Generation Overview

The cache warming system proactively generates interface fragments before user requests to achieve zero-latency response for common queries.

**Goals:**
- 85%+ first-query cache hit rate
- <10ms response time for cached queries
- Efficient resource usage (don't pre-generate everything)

**Strategy:**
- Predict high-probability user intents from data schema
- Generate fragments in priority order
- Warm cache in background (non-blocking)
- Continuous learning from actual usage

#### 14.3.2 Warming Pipeline

```
Data Source Connected
    ↓
Schema Fingerprinting (§12.3)
    ↓ (primitives: date, currency, category, etc.)
Archetype Detection (§12.4)
    ↓ (overview, time_series, comparison, etc.)
Intent Prediction
    ↓ (ranked list of likely user questions)
Fragment Prioritization
    ↓ (top N intents by predicted probability)
Progressive Generation
    ↓ (generate in priority order)
Cache Population
    ↓
Ready for Queries
```

#### 14.3.3 Intent Prediction Algorithm

```typescript
interface PredictedIntent {
  intent: string;                // Natural language intent
  probability: number;           // 0-1 likelihood
  archetype: string;             // Predicted archetype
  bindings: BindingSuggestion[]; // Predicted field mappings
  signals?: string[];            // Predicted signals
  priority: number;              // Generation priority (1-5)
}

function predictIntents(
  fingerprint: DataFingerprint,
  archetypes: string[]
): PredictedIntent[] {
  const intents: PredictedIntent[] = [];

  // Rule-based intent generation
  for (const archetype of archetypes) {
    const archetypeIntents = generateArchetypeIntents(fingerprint, archetype);
    intents.push(...archetypeIntents);
  }

  // Cross-product intents (combining primitives)
  const crossIntents = generateCrossProductIntents(fingerprint);
  intents.push(...crossIntents);

  // Historical learning (if available)
  const historicalIntents = getHistoricalIntents(fingerprint);
  intents.push(...historicalIntents);

  // Score and rank
  return intents
    .map(i => ({ ...i, probability: scoreIntent(i, fingerprint) }))
    .sort((a, b) => b.probability - a.probability)
    .slice(0, 50);  // Top 50 intents
}
```

#### 14.3.4 Archetype-Based Intent Generation

```typescript
function generateArchetypeIntents(
  fingerprint: DataFingerprint,
  archetype: string
): PredictedIntent[] {
  switch (archetype) {
    case 'overview':
      return generateOverviewIntents(fingerprint);
    case 'time_series':
      return generateTimeSeriesIntents(fingerprint);
    case 'comparison':
      return generateComparisonIntents(fingerprint);
    case 'distribution':
      return generateDistributionIntents(fingerprint);
    case 'funnel':
      return generateFunnelIntents(fingerprint);
    default:
      return [];
  }
}

function generateOverviewIntents(fp: DataFingerprint): PredictedIntent[] {
  const intents: PredictedIntent[] = [];
  const currencies = fp.fields.filter(f => f.primitive === 'currency');
  const dates = fp.fields.filter(f => f.primitive === 'date');
  const categories = fp.fields.filter(f => f.primitive === 'category');

  // Intent 1: Key metrics overview
  if (currencies.length >= 2) {
    intents.push({
      intent: `Show overview of ${currencies.map(c => c.name).join(', ')}`,
      probability: 0.9,
      archetype: 'overview',
      bindings: currencies.map(c => ({ field: c.name, target: 'value', score: 0.9 })),
      priority: 1,
    });
  }

  // Intent 2: Metrics with trend
  if (currencies.length >= 1 && dates.length >= 1) {
    const metric = currencies[0];
    const dateField = dates[0];
    intents.push({
      intent: `Show ${metric.name} trend over time`,
      probability: 0.85,
      archetype: 'overview',
      bindings: [
        { field: metric.name, target: 'value', score: 0.9 },
        { field: dateField.name, target: 'x', score: 0.9 },
      ],
      signals: ['dateRange'],
      priority: 1,
    });
  }

  // Intent 3: Breakdown by category
  if (currencies.length >= 1 && categories.length >= 1) {
    const metric = currencies[0];
    const category = categories[0];
    intents.push({
      intent: `Show ${metric.name} by ${category.name}`,
      probability: 0.8,
      archetype: 'overview',
      bindings: [
        { field: metric.name, target: 'value', score: 0.9 },
        { field: category.name, target: 'category', score: 0.9 },
      ],
      priority: 2,
    });
  }

  return intents;
}

function generateTimeSeriesIntents(fp: DataFingerprint): PredictedIntent[] {
  const intents: PredictedIntent[] = [];
  const dates = fp.fields.filter(f => f.primitive === 'date');
  const measures = fp.fields.filter(f => f.primitive === 'currency' || f.primitive === 'count');

  if (dates.length === 0 || measures.length === 0) return [];

  const dateField = dates[0];

  // Single metric trend
  for (const measure of measures.slice(0, 3)) {
    intents.push({
      intent: `Show ${measure.name} over time`,
      probability: 0.85,
      archetype: 'time_series',
      bindings: [
        { field: dateField.name, target: 'x', score: 0.95 },
        { field: measure.name, target: 'y', score: 0.9 },
      ],
      signals: ['dateRange'],
      priority: 1,
    });
  }

  // Multi-metric comparison
  if (measures.length >= 2) {
    intents.push({
      intent: `Compare ${measures[0].name} vs ${measures[1].name} over time`,
      probability: 0.75,
      archetype: 'time_series',
      bindings: [
        { field: dateField.name, target: 'x', score: 0.95 },
        { field: measures[0].name, target: 'series', score: 0.85 },
        { field: measures[1].name, target: 'series', score: 0.85 },
      ],
      signals: ['dateRange'],
      priority: 2,
    });
  }

  return intents;
}

function generateComparisonIntents(fp: DataFingerprint): PredictedIntent[] {
  const intents: PredictedIntent[] = [];
  const measures = fp.fields.filter(f => f.primitive === 'currency' || f.primitive === 'count');

  // Two measures side-by-side
  for (let i = 0; i < measures.length; i++) {
    for (let j = i + 1; j < measures.length; j++) {
      const m1 = measures[i];
      const m2 = measures[j];

      // Check if they look like current vs previous (naming pattern)
      const isComparison = (
        (m1.name.includes('current') && m2.name.includes('previous')) ||
        (m1.name.includes('actual') && m2.name.includes('budget')) ||
        (m1.name.includes('this') && m2.name.includes('last'))
      );

      intents.push({
        intent: `Compare ${m1.name} vs ${m2.name}`,
        probability: isComparison ? 0.9 : 0.6,
        archetype: 'comparison',
        bindings: [
          { field: m1.name, target: 'current', score: 0.9 },
          { field: m2.name, target: 'previous', score: 0.9 },
        ],
        priority: isComparison ? 1 : 3,
      });
    }
  }

  return intents;
}

function generateDistributionIntents(fp: DataFingerprint): PredictedIntent[] {
  const intents: PredictedIntent[] = [];
  const categories = fp.fields.filter(f => f.primitive === 'category');
  const measures = fp.fields.filter(f => f.primitive === 'currency' || f.primitive === 'count');

  // Category breakdown
  for (const category of categories.slice(0, 2)) {
    for (const measure of measures.slice(0, 2)) {
      intents.push({
        intent: `Show ${measure.name} distribution by ${category.name}`,
        probability: 0.75,
        archetype: 'distribution',
        bindings: [
          { field: category.name, target: 'label', score: 0.9 },
          { field: measure.name, target: 'value', score: 0.9 },
        ],
        priority: 2,
      });
    }
  }

  return intents;
}

function generateFunnelIntents(fp: DataFingerprint): PredictedIntent[] {
  const intents: PredictedIntent[] = [];
  const stageFields = fp.fields.filter(f =>
    f.name.toLowerCase().includes('stage') ||
    f.name.toLowerCase().includes('step') ||
    f.name.toLowerCase().includes('funnel')
  );

  if (stageFields.length === 0) return [];

  const measures = fp.fields.filter(f => f.primitive === 'count' || f.primitive === 'currency');

  for (const measure of measures.slice(0, 2)) {
    intents.push({
      intent: `Show ${measure.name} funnel`,
      probability: 0.8,
      archetype: 'funnel',
      bindings: [
        { field: stageFields[0].name, target: 'stage', score: 0.9 },
        { field: measure.name, target: 'value', score: 0.9 },
      ],
      priority: 2,
    });
  }

  return intents;
}
```

#### 14.3.5 Cross-Product Intent Generation

Generate intents by combining primitives:

```typescript
function generateCrossProductIntents(fp: DataFingerprint): PredictedIntent[] {
  const intents: PredictedIntent[] = [];

  // Date × Currency → Time series
  const dates = fp.fields.filter(f => f.primitive === 'date');
  const currencies = fp.fields.filter(f => f.primitive === 'currency');

  for (const date of dates.slice(0, 1)) {
    for (const currency of currencies.slice(0, 3)) {
      intents.push({
        intent: `Show ${currency.name} over ${date.name}`,
        probability: 0.8,
        archetype: 'time_series',
        bindings: [
          { field: date.name, target: 'x', score: 0.9 },
          { field: currency.name, target: 'y', score: 0.9 },
        ],
        signals: ['dateRange'],
        priority: 1,
      });
    }
  }

  // Category × Currency → Distribution
  const categories = fp.fields.filter(f => f.primitive === 'category');

  for (const category of categories.slice(0, 2)) {
    for (const currency of currencies.slice(0, 2)) {
      intents.push({
        intent: `Show ${currency.name} by ${category.name}`,
        probability: 0.75,
        archetype: 'distribution',
        bindings: [
          { field: category.name, target: 'category', score: 0.9 },
          { field: currency.name, target: 'value', score: 0.9 },
        ],
        signals: ['filter'],
        priority: 2,
      });
    }
  }

  // Category × Date × Currency → Filtered time series
  for (const category of categories.slice(0, 1)) {
    for (const date of dates.slice(0, 1)) {
      for (const currency of currencies.slice(0, 2)) {
        intents.push({
          intent: `Show ${currency.name} trend by ${category.name}`,
          probability: 0.7,
          archetype: 'time_series',
          bindings: [
            { field: date.name, target: 'x', score: 0.9 },
            { field: currency.name, target: 'y', score: 0.9 },
            { field: category.name, target: 'series', score: 0.8 },
          ],
          signals: ['dateRange', 'categoryFilter'],
          priority: 3,
        });
      }
    }
  }

  return intents;
}
```

#### 14.3.6 Intent Scoring

```typescript
function scoreIntent(intent: PredictedIntent, fp: DataFingerprint): number {
  let score = intent.probability;  // Base probability

  // Boost by field name semantic match
  const semanticBoost = intent.bindings.reduce((sum, b) => {
    const field = fp.fields.find(f => f.name === b.field);
    return sum + (field?.semanticScore ?? 0);
  }, 0) / intent.bindings.length;
  score *= (1 + semanticBoost * 0.2);

  // Boost by field position (first fields more important)
  const positionBoost = intent.bindings.reduce((sum, b) => {
    const field = fp.fields.find(f => f.name === b.field);
    const position = fp.fields.indexOf(field!);
    return sum + (1 - position / fp.fields.length);
  }, 0) / intent.bindings.length;
  score *= (1 + positionBoost * 0.1);

  // Boost by archetype frequency (if historical data available)
  const archetypeFreq = getArchetypeFrequency(intent.archetype);
  score *= (1 + archetypeFreq * 0.15);

  // Penalize complex intents (too many bindings)
  if (intent.bindings.length > 4) {
    score *= 0.8;
  }

  return Math.min(score, 1.0);
}

function getArchetypeFrequency(archetype: string): number {
  // Historical data: what % of queries use this archetype
  const frequencies: Record<string, number> = {
    'overview': 0.35,
    'time_series': 0.25,
    'distribution': 0.15,
    'comparison': 0.10,
    'funnel': 0.05,
  };
  return frequencies[archetype] ?? 0.05;
}
```

#### 14.3.7 Fragment Prioritization

```typescript
interface GenerationTask {
  intent: PredictedIntent;
  priority: number;           // 1-5 (1 = highest)
  estimatedTokens: number;    // LLM token cost
  estimatedTime: number;      // Generation time (ms)
}

function prioritizeTasks(intents: PredictedIntent[]): GenerationTask[] {
  const tasks = intents.map(intent => ({
    intent,
    priority: calculatePriority(intent),
    estimatedTokens: estimateTokens(intent),
    estimatedTime: estimateTime(intent),
  }));

  // Sort by priority, then by cost (prefer cheap high-value)
  return tasks.sort((a, b) => {
    if (a.priority !== b.priority) {
      return a.priority - b.priority;  // Lower number = higher priority
    }
    return a.estimatedTokens - b.estimatedTokens;  // Prefer cheaper
  });
}

function calculatePriority(intent: PredictedIntent): number {
  // Priority 1: probability > 0.85
  if (intent.probability > 0.85) return 1;

  // Priority 2: probability > 0.7
  if (intent.probability > 0.7) return 2;

  // Priority 3: probability > 0.5
  if (intent.probability > 0.5) return 3;

  // Priority 4: probability > 0.3
  if (intent.probability > 0.3) return 4;

  // Priority 5: everything else
  return 5;
}

function estimateTokens(intent: PredictedIntent): number {
  // Estimate LLM tokens needed for generation
  const baseTokens = 35;  // Typical LiquidCode generation
  const bindingTokens = intent.bindings.length * 3;
  const signalTokens = (intent.signals?.length ?? 0) * 5;
  return baseTokens + bindingTokens + signalTokens;
}

function estimateTime(intent: PredictedIntent): number {
  // Estimate generation time
  const tokens = estimateTokens(intent);
  const msPerToken = 2;  // Typical LLM latency
  return tokens * msPerToken + 50;  // +50ms overhead
}
```

#### 14.3.8 Progressive Generation

```typescript
interface WarmingConfig {
  maxConcurrent: number;        // Max parallel generations
  maxTotalTime: number;         // Total warming budget (ms)
  maxCacheSize: number;         // Max fragments to cache
  priorityThreshold: number;    // Only generate priority ≤ N
}

const DEFAULT_CONFIG: WarmingConfig = {
  maxConcurrent: 5,
  maxTotalTime: 10000,          // 10 seconds
  maxCacheSize: 100,
  priorityThreshold: 3,         // Only priority 1-3
};

async function warmCache(
  fingerprint: DataFingerprint,
  config: WarmingConfig = DEFAULT_CONFIG
): Promise<WarmingResult> {
  const startTime = Date.now();
  const generated: CachedFragment[] = [];
  const skipped: PredictedIntent[] = [];

  // 1. Predict intents
  const archetypes = detectArchetypes(fingerprint);
  const intents = predictIntents(fingerprint, archetypes);

  // 2. Prioritize
  const tasks = prioritizeTasks(intents)
    .filter(t => t.priority <= config.priorityThreshold)
    .slice(0, config.maxCacheSize);

  // 3. Generate in waves
  const queue = [...tasks];
  const inFlight = new Set<Promise<CachedFragment>>();

  while (queue.length > 0 || inFlight.size > 0) {
    // Check time budget
    if (Date.now() - startTime > config.maxTotalTime) {
      skipped.push(...queue.map(t => t.intent));
      break;
    }

    // Fill up to maxConcurrent
    while (queue.length > 0 && inFlight.size < config.maxConcurrent) {
      const task = queue.shift()!;
      const promise = generateFragment(task.intent, fingerprint)
        .then(fragment => {
          generated.push(fragment);
          return fragment;
        })
        .finally(() => {
          inFlight.delete(promise);
        });
      inFlight.add(promise);
    }

    // Wait for at least one to complete
    if (inFlight.size > 0) {
      await Promise.race(inFlight);
    }
  }

  // 4. Populate cache
  for (const fragment of generated) {
    await fragmentCache.set(fragment.key, fragment, {
      ttl: 3600 * 24 * 7,  // 7 days for pre-generated
    });
  }

  return {
    generated: generated.length,
    skipped: skipped.length,
    totalTime: Date.now() - startTime,
    cacheSize: generated.length,
  };
}

interface WarmingResult {
  generated: number;
  skipped: number;
  totalTime: number;
  cacheSize: number;
}
```

#### 14.3.9 Fragment Generation

```typescript
async function generateFragment(
  intent: PredictedIntent,
  fingerprint: DataFingerprint
): Promise<CachedFragment> {
  // Use LLM to generate LiquidCode for this intent
  const prompt = buildGenerationPrompt(intent, fingerprint);
  const liquidCode = await llm.generate(prompt, {
    maxTokens: 100,
    temperature: 0.3,  // Low temp for cache warming (consistent)
  });

  // Compile to schema
  const schema = await compiler.compile(liquidCode);

  // Validate
  await validator.validate(schema);

  // Create cache fragment
  const fragment: CachedFragment = {
    key: createCacheKey(intent, fingerprint),
    intent: intent.intent,
    liquidCode,
    schema,
    metadata: {
      archetype: intent.archetype,
      probability: intent.probability,
      generatedAt: new Date().toISOString(),
      source: 'pre-generation',
    },
  };

  return fragment;
}

function buildGenerationPrompt(
  intent: PredictedIntent,
  fingerprint: DataFingerprint
): string {
  return `
Generate LiquidCode for: "${intent.intent}"

Data schema:
${fingerprint.fields.map(f => `  ${f.name}: ${f.primitive} (${f.type})`).join('\n')}

Suggested archetype: ${intent.archetype}
Suggested bindings:
${intent.bindings.map(b => `  ${b.field} → ${b.target}`).join('\n')}

Output LiquidCode only (ASCII format, no explanation):
  `.trim();
}

function createCacheKey(
  intent: PredictedIntent,
  fingerprint: DataFingerprint
): CacheKey {
  return {
    intentHash: hashIntent(intent.intent),
    dataFingerprint: fingerprint.signature,
    archetypeHint: intent.archetype,
    scope: 'interface',
  };
}

function hashIntent(intent: string): string {
  // Normalize and hash intent
  const normalized = intent.toLowerCase().trim().replace(/\s+/g, ' ');
  return createHash('sha256').update(normalized).digest('hex').substring(0, 16);
}
```

#### 14.3.10 Continuous Learning

Update predictions based on actual usage:

```typescript
interface UsageEvent {
  timestamp: string;
  intent: string;
  dataFingerprint: string;
  cacheHit: boolean;
  latency: number;
}

class UsageLearning {
  private events: UsageEvent[] = [];

  record(event: UsageEvent): void {
    this.events.push(event);
    if (this.events.length > 10000) {
      this.events = this.events.slice(-10000);  // Keep recent
    }
  }

  getTopIntents(fingerprint: string, limit: number = 20): string[] {
    const filtered = this.events.filter(e => e.dataFingerprint === fingerprint);
    const counts = new Map<string, number>();

    for (const event of filtered) {
      counts.set(event.intent, (counts.get(event.intent) ?? 0) + 1);
    }

    return Array.from(counts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, limit)
      .map(([intent]) => intent);
  }

  getCacheHitRate(fingerprint: string): number {
    const filtered = this.events.filter(e => e.dataFingerprint === fingerprint);
    if (filtered.length === 0) return 0;

    const hits = filtered.filter(e => e.cacheHit).length;
    return hits / filtered.length;
  }

  // Use historical data to boost intent probabilities
  boostIntentProbabilities(
    intents: PredictedIntent[],
    fingerprint: DataFingerprint
  ): PredictedIntent[] {
    const topIntents = this.getTopIntents(fingerprint.signature, 50);

    return intents.map(intent => {
      const rank = topIntents.indexOf(intent.intent);
      if (rank !== -1) {
        // Boost probability based on actual usage rank
        const boost = Math.max(0, 1 - rank / topIntents.length) * 0.3;
        return {
          ...intent,
          probability: Math.min(1, intent.probability + boost),
        };
      }
      return intent;
    });
  }
}
```

#### 14.3.11 Warming Triggers

```typescript
enum WarmingTrigger {
  ON_CONNECT = 'on_connect',           // Data source connected
  ON_SCHEMA_CHANGE = 'on_schema_change', // Schema updated
  ON_IDLE = 'on_idle',                  // System idle
  PERIODIC = 'periodic',                // Scheduled refresh
}

interface WarmingScheduler {
  schedule(
    trigger: WarmingTrigger,
    fingerprint: DataFingerprint,
    config?: Partial<WarmingConfig>
  ): Promise<void>;
}

// Example: warm on connect
dataSource.on('connect', async (source) => {
  const fingerprint = await fingerprinter.analyze(source.schema);

  await warmingScheduler.schedule(
    WarmingTrigger.ON_CONNECT,
    fingerprint,
    {
      maxTotalTime: 5000,  // Fast initial warm
      priorityThreshold: 2,  // Only top priorities
    }
  );
});

// Example: periodic refresh
setInterval(async () => {
  const fingerprint = await fingerprinter.analyze(dataSource.schema);
  const hitRate = usageLearning.getCacheHitRate(fingerprint.signature);

  if (hitRate < 0.80) {  // Below target
    await warmingScheduler.schedule(
      WarmingTrigger.PERIODIC,
      fingerprint,
      {
        maxTotalTime: 30000,  // Longer budget for refresh
        priorityThreshold: 4,  // Broader coverage
      }
    );
  }
}, 3600000);  // Every hour
```
```

## Verification Checklist
- [x] Issue addressed - Complete pre-generation strategy with algorithms for intent prediction, prioritization, and progressive generation
- [x] No inconsistencies introduced - Aligns with Discovery Engine (§12), Tiered Resolution (§13), Fragment Cache (§14.1-14.2)
- [x] Cross-references valid - References §12.3 (fingerprinting), §12.4 (archetypes), §13 (resolution), §14.1-14.2 (cache)
- [x] Examples provided - Intent generation for 5 archetypes, scoring algorithm, progressive generation with concurrency control
- [x] Implementation guidance - Complete TypeScript implementation with prioritization, scheduling, and continuous learning

## Confidence
HIGH - This resolution provides production-ready cache warming:
1. Intent prediction based on archetype detection and field primitives
2. Cross-product generation combining primitives (date × currency, category × measure)
3. Probabilistic scoring with semantic boosting and historical learning
4. Priority-based task queue with concurrent generation
5. Time and resource budgets to prevent over-generation
6. Continuous learning from actual usage to improve predictions
7. Multiple warming triggers (on-connect, periodic, schema-change)
8. Target: 85%+ cache hit rate with <10s warming time
9. Integrates with existing Discovery Engine (§12) and Fragment Cache (§14) specifications
