# Resolution: ISS-093

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Signal Type Mismatch
**Severity:** significant
**Category:** edge-cases
**Target:** SPEC
**Section:** §10 Signal System

## Problem Statement

Handling when signal payload doesn't match declared type is undefined. The specification defines signal types (§10.3) and signal connections (§10.3) but does not specify what happens when:

1. An emitter sends a value incompatible with the signal's declared type
2. A receiver expects one type but gets another
3. A transform produces a value incompatible with the target type
4. A signal's default value doesn't match its declared type
5. Type coercion is possible vs. impossible

Without defined behavior, implementations may:
- Crash on type mismatches
- Silently accept invalid values
- Have inconsistent coercion rules
- Produce unpredictable results

## Resolution

### Specification Addition

Add the following subsection to §10 Signal System, after §10.8 Signal Lifecycle and Orphaned Signals:

#### §10.9 Signal Type Validation and Coercion

All signal values MUST be validated against their declared type. Invalid values are coerced if possible, otherwise rejected with fallback to default.

**Validation Phase:**

Signal values are validated at three points:

1. **Declaration validation** - Default value must match declared type
2. **Emission validation** - Emitted value must match or be coercible to declared type
3. **Reception validation** - After transform, value must match target expectations

**Type Compatibility Matrix:**

| Signal Type | Valid Value Shape | Coercible From | Examples |
|-------------|------------------|----------------|----------|
| `dateRange` | `{start: Date\|string, end: Date\|string}` | String dates, timestamps | `{start: '2024-01-01', end: '2024-12-31'}` |
| `selection` | `string \| string[]` | Single string → array, CSV string → array | `"item1"` → `["item1"]` |
| `filter` | `Record<string, any>` | Any object | `{category: 'A', status: 'active'}` |
| `search` | `string` | Any via toString() | `123` → `"123"` |
| `pagination` | `{page: number, size: number}` | Partial object (fill defaults) | `{page: 1}` → `{page: 1, size: 20}` |
| `sort` | `{field: string, dir: 'asc'\|'desc'}` | String → parse to object | `"name:asc"` → `{field: 'name', dir: 'asc'}` |
| `toggle` | `boolean` | Truthy/falsy values | `"true"`, `1`, `"yes"` → `true` |
| `custom` | `any` | No validation | Any value accepted |

**Validation Implementation:**

```typescript
interface TypeValidator {
  validate(value: any, type: SignalType): ValidationResult;
  coerce(value: any, type: SignalType): any;
}

interface ValidationResult {
  valid: boolean;
  coerced?: any;
  error?: string;
}

class SignalTypeValidator implements TypeValidator {
  validate(value: any, type: SignalType): ValidationResult {
    try {
      const coerced = this.coerce(value, type);
      return { valid: true, coerced };
    } catch (error) {
      return {
        valid: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  coerce(value: any, type: SignalType): any {
    switch (type) {
      case 'dateRange':
        return this.coerceDateRange(value);
      case 'selection':
        return this.coerceSelection(value);
      case 'filter':
        return this.coerceFilter(value);
      case 'search':
        return this.coerceSearch(value);
      case 'pagination':
        return this.coercePagination(value);
      case 'sort':
        return this.coerceSort(value);
      case 'toggle':
        return this.coerceToggle(value);
      case 'custom':
        return value; // No coercion
      default:
        throw new Error(`Unknown signal type: ${type}`);
    }
  }

  private coerceDateRange(value: any): {start: Date, end: Date} {
    if (!value || typeof value !== 'object') {
      throw new Error('dateRange must be an object with start and end');
    }

    const start = value.start instanceof Date ? value.start : new Date(value.start);
    const end = value.end instanceof Date ? value.end : new Date(value.end);

    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      throw new Error('dateRange contains invalid dates');
    }

    if (start > end) {
      throw new Error('dateRange start must be before end');
    }

    return { start, end };
  }

  private coerceSelection(value: any): string | string[] {
    if (Array.isArray(value)) {
      return value.map(v => String(v));
    }

    if (typeof value === 'string') {
      // Check if CSV
      if (value.includes(',')) {
        return value.split(',').map(v => v.trim());
      }
      return value;
    }

    // Single value
    return String(value);
  }

  private coerceFilter(value: any): Record<string, any> {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      return value;
    }
    throw new Error('filter must be an object');
  }

  private coerceSearch(value: any): string {
    return String(value);
  }

  private coercePagination(value: any): {page: number, size: number} {
    if (!value || typeof value !== 'object') {
      throw new Error('pagination must be an object');
    }

    const page = Number(value.page ?? 1);
    const size = Number(value.size ?? 20);

    if (isNaN(page) || isNaN(size) || page < 1 || size < 1) {
      throw new Error('pagination page and size must be positive numbers');
    }

    return { page, size };
  }

  private coerceSort(value: any): {field: string, dir: 'asc' | 'desc'} {
    // Object form
    if (value && typeof value === 'object') {
      const dir = value.dir === 'desc' ? 'desc' : 'asc';
      return { field: String(value.field), dir };
    }

    // String form: "field:dir"
    if (typeof value === 'string') {
      const [field, dirStr] = value.split(':');
      const dir = dirStr === 'desc' ? 'desc' : 'asc';
      return { field, dir };
    }

    throw new Error('sort must be object or string "field:dir"');
  }

  private coerceToggle(value: any): boolean {
    // Boolean
    if (typeof value === 'boolean') return value;

    // String boolean
    if (typeof value === 'string') {
      const lower = value.toLowerCase();
      if (lower === 'true' || lower === 'yes' || lower === '1') return true;
      if (lower === 'false' || lower === 'no' || lower === '0') return false;
    }

    // Number
    if (typeof value === 'number') return value !== 0;

    // Truthy/falsy
    return Boolean(value);
  }
}
```

**Validation at Declaration:**

```typescript
function validateSignalDeclaration(
  name: string,
  signal: SignalDefinition
): ValidationResult {
  const validator = new SignalTypeValidator();

  // Validate default value matches type
  if (signal.default !== undefined) {
    const result = validator.validate(signal.default, signal.type);
    if (!result.valid) {
      return {
        valid: false,
        error: `Signal '${name}' default value invalid: ${result.error}`,
      };
    }
  }

  return { valid: true };
}

// Example error:
{
  valid: false,
  error: "Signal 'dateRange' default value invalid: dateRange must be an object with start and end"
}
```

**Validation at Emission:**

```typescript
class SignalRuntime {
  private validator = new SignalTypeValidator();

  set(signalName: string, value: any): void {
    const signal = this.registry.get(signalName);
    if (!signal) {
      console.warn(`Signal '${signalName}' not in registry`);
      return;
    }

    // Validate and coerce value
    const result = this.validator.validate(value, signal.type);

    if (!result.valid) {
      console.error(
        `Signal '${signalName}' type validation failed: ${result.error}. ` +
        `Using default value instead.`
      );

      // Fall back to default
      const defaultValue = signal.default;
      this.values.set(signalName, defaultValue);
      this.notifySubscribers(signalName, defaultValue);
      return;
    }

    // Use coerced value
    const coercedValue = result.coerced ?? value;
    this.values.set(signalName, coercedValue);
    this.notifySubscribers(signalName, coercedValue);

    // Persist if needed
    if (signal.persist !== 'none') {
      this.persist(signalName, coercedValue);
    }
  }
}
```

**Validation After Transform:**

Transforms (LiquidExpr, §B.4) can produce values that don't match the signal type:

```typescript
interface SignalEmission {
  signal: string;
  trigger: string;
  transform?: string;  // May produce incompatible type
}

function applyEmissionTransform(
  value: any,
  emission: SignalEmission,
  signal: SignalDefinition
): any {
  if (!emission.transform) {
    return value;
  }

  // Apply LiquidExpr transform
  const transformed = evalLiquidExpr(emission.transform, { value });

  // Validate transformed value
  const validator = new SignalTypeValidator();
  const result = validator.validate(transformed, signal.type);

  if (!result.valid) {
    console.error(
      `Transform for signal '${emission.signal}' produced invalid type: ${result.error}. ` +
      `Using untransformed value.`
    );
    return value; // Fall back to untransformed
  }

  return result.coerced ?? transformed;
}
```

**Custom Validation Expressions:**

Signals can include custom validation using LiquidExpr (§B.4):

```typescript
interface SignalDefinition {
  type: SignalType;
  default?: unknown;
  persist?: 'none' | 'url' | 'session' | 'local';
  validation?: string;  // LiquidExpr returning boolean
}

// Example with custom validation
{
  name: 'percentage',
  type: 'custom',
  default: 0.5,
  validation: '$value >= 0 && $value <= 1'  // Must be 0-1
}

function validateCustomExpression(
  value: any,
  validation: string
): boolean {
  try {
    return evalLiquidExpr(validation, { value }) === true;
  } catch (error) {
    console.error(`Validation expression failed: ${error}`);
    return false;
  }
}
```

**Error Handling Strategy:**

| Validation Failure | Action | User Experience |
|-------------------|--------|-----------------|
| Invalid default value | Compilation error | Schema rejected, clear error message |
| Invalid emitted value | Use default, log error | UI continues with default, console error |
| Invalid transform output | Use untransformed, log error | UI uses original value, console error |
| Invalid persisted value | Use default, log warning | UI loads with default, warning logged |
| Custom validation fails | Use previous value, log error | UI retains previous state, error logged |

**Type Safety in Schema:**

Add validation to LiquidSchema validation (§B.6.3):

```typescript
const SignalDefinitionSchema = z.object({
  type: z.enum(['dateRange', 'selection', 'filter', 'search',
                'pagination', 'sort', 'toggle', 'custom']),
  default: z.any().optional(),
  persist: z.enum(['none', 'url', 'session', 'local']).optional(),
  validation: z.string().optional(),
}).refine(signal => {
  // Validate default matches type
  if (signal.default !== undefined) {
    const validator = new SignalTypeValidator();
    const result = validator.validate(signal.default, signal.type);
    return result.valid;
  }
  return true;
}, {
  message: 'Signal default value does not match declared type',
});
```

### Integration Points

1. **Signal System (§10)** - Type validation integrated into signal flow
2. **LiquidExpr (§B.4)** - Transform outputs validated for type compatibility
3. **Compilation Pipeline (§17)** - Signal declarations validated at compile time
4. **Adapter Contract (§18)** - Signal runtime implements type validation
5. **Error Handling (§19)** - Type errors are Level 2 degradation (use defaults)

### Examples

**Example 1: Valid Coercion**

```liquidcode
# Signal declared as dateRange
§dateRange:dr={start:'2024-01-01',end:'2024-12-31'},url

# Emitter sends string dates (coercible)
DF>@dateRange:onChange  # Emits {start: "2024-06-01", end: "2024-06-30"}

# Runtime:
# - Receives string dates
# - Coerces to Date objects: {start: Date('2024-06-01'), end: Date('2024-06-30')}
# - Validates start < end: ✓
# - Emits coerced value to receivers
# - No error
```

**Example 2: Invalid Type (Fallback to Default)**

```liquidcode
# Signal declared as pagination
§page:pag={page:1,size:20},session

# Emitter accidentally sends string
SI>@page:onChange  # Emits "invalid"

# Runtime:
# - Receives "invalid"
# - Attempts coercion: pagination must be an object
# - Coercion fails
# - Logs error: "Signal 'page' type validation failed: pagination must be an object. Using default value instead."
# - Falls back to default: {page:1, size:20}
# - Emits default to receivers
# - UI continues with default pagination
```

**Example 3: Transform Output Invalid**

```liquidcode
# Signal declared as toggle
§showDetails:tog=false,local

# Emitter with transform that produces invalid type
K>@showDetails:onClick  # Transform: "return $value.label"  (produces string, not boolean)

# Runtime:
# - User clicks KPI
# - Transform executes: $value.label → "Revenue"
# - Attempts to coerce "Revenue" to boolean → true (truthy string)
# - Coercion succeeds (toggle coerces strings)
# - Emits: true
# - Receivers toggle on
# - No error (but likely unintended - should warn about string→boolean)
```

**Example 4: Custom Validation**

```liquidcode
# Signal with custom validation
§discount:custom=0.1,session,validation:"$value >= 0 && $value <= 1"

# Emitter sends value outside range
SF>@discount:onChange  # Emits 1.5

# Runtime:
# - Receives 1.5
# - Type is 'custom' (no built-in validation)
# - Runs custom validation: 1.5 >= 0 && 1.5 <= 1 → false
# - Validation fails
# - Logs error: "Signal 'discount' custom validation failed. Using previous value."
# - Retains previous value (0.1)
# - Receivers not updated
```

**Example 5: Invalid Default (Compilation Error)**

```liquidcode
# Signal with mismatched default
§dateRange:dr="invalid",url  # String, not {start, end}

# Compilation:
# - Validates signal declarations
# - Detects default value "invalid" does not match type dateRange
# - Emits error: "Signal 'dateRange' default value invalid: dateRange must be an object with start and end"
# - Compilation fails
# - Schema not generated
```

## Verification Checklist

- [x] **Complete type coverage**
  - All signal types have validation rules
  - Coercion rules defined for each type
  - Edge cases handled (null, undefined, wrong shape)
- [x] **Validation at all phases**
  - Declaration (compile time)
  - Emission (runtime)
  - Transform output (runtime)
  - Persistence (load time)
- [x] **Graceful degradation**
  - Invalid values fall back to defaults
  - Never crash on type mismatch
  - Clear error messages logged
- [x] **Type safety**
  - Zod schema validation for declarations
  - Runtime validation for dynamic values
  - Custom validation support
- [x] **Integration defined**
  - Signal runtime implementation
  - Compilation validation
  - Error handling strategy

## Confidence

**HIGH** - This resolution:

1. **Addresses root cause** - Defines complete type validation and coercion for all signal types
2. **Follows spec patterns** - Uses LiquidExpr for custom validation (§B.4), follows error handling (§19)
3. **Comprehensive coercion** - Sensible coercion rules for common type mismatches
4. **Never-broken guarantee** - Invalid types fall back to defaults, never crash
5. **Testable** - Deterministic coercion rules and validation behavior
6. **User-friendly** - Clear error messages explain what went wrong and what value is being used
7. **Type-safe** - Zod validation at compile time prevents most errors before runtime
