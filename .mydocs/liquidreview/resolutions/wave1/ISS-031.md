# Resolution: ISS-031

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Binding Required vs Optional Fields
**Severity:** critical
**Target:** SPEC
**Section:** §10.2 vs §10.6

## Resolution

### Original Content (Lines 639-647, 2352-2360)

**Section §9.1 (Lines 639-647):**
```typescript
interface DataBinding {
  source: string;                    // Data source reference
  fields: FieldBinding[];            // Field mappings
  aggregate?: AggregateSpec;         // Aggregation (sum, count, avg)
  groupBy?: string[];                // Grouping fields
  filter?: FilterCondition[];        // Filter conditions
  sort?: SortSpec[];                 // Sort order
  limit?: number;                    // Row limit
}
```

**Section B.6.1 (Lines 2352-2360):**
```typescript
interface DataBinding {
  source: string;
  fields: FieldBinding[];
  aggregate?: AggregateSpec;
  groupBy?: string[];
  filter?: FilterCondition[];
  sort?: SortSpec[];
  limit?: number;
}
```

### Replacement Content

**Section §9.1 Clarification:**

```typescript
interface DataBinding {
  // REQUIRED fields
  source: string;                    // Data source reference (required)
  fields: FieldBinding[];            // Field mappings (required, min 1)

  // OPTIONAL fields with defaults
  aggregate?: AggregateSpec;         // Aggregation (default: none)
  groupBy?: string[];                // Grouping fields (default: [])
  filter?: FilterCondition[];        // Filter conditions (default: [])
  sort?: SortSpec[];                 // Sort order (default: [])
  limit?: number;                    // Row limit (default: unlimited)
}

interface FieldBinding {
  // REQUIRED fields
  target: BindingSlot;               // Slot name (required)
  field: string;                     // Source field name (required)

  // OPTIONAL fields
  transform?: string;                // LiquidExpr transformation (default: none)
}

/**
 * Field Requirements by Block Type
 *
 * Each block type has required and optional binding slots.
 * Compilation fails if required slots are not bound.
 */

interface BlockBindingRequirements {
  blockType: BlockType;
  requiredSlots: BindingSlot[];      // MUST be present
  optionalSlots: BindingSlot[];      // MAY be present
  defaultSlots?: Record<BindingSlot, unknown>;  // Default values if omitted
}

const BINDING_REQUIREMENTS: Record<BlockType, BlockBindingRequirements> = {
  'kpi': {
    blockType: 'kpi',
    requiredSlots: ['value'],
    optionalSlots: ['label', 'trend', 'icon', 'compare'],
    defaultSlots: {
      label: null,           // No label (infer from field name)
      trend: null,           // No trend indicator
      icon: null,            // No icon
      compare: null,         // No comparison value
    },
  },

  'bar-chart': {
    blockType: 'bar-chart',
    requiredSlots: ['category', 'value'],
    optionalSlots: ['color', 'label', 'stack'],
    defaultSlots: {
      color: null,           // Auto color scheme
      label: null,           // Use category as label
      stack: null,           // No stacking
    },
  },

  'line-chart': {
    blockType: 'line-chart',
    requiredSlots: ['x', 'y'],
    optionalSlots: ['series', 'color', 'label'],
    defaultSlots: {
      series: null,          // Single series
      color: null,           // Auto color
      label: null,           // Use y field name
    },
  },

  'pie-chart': {
    blockType: 'pie-chart',
    requiredSlots: ['label', 'value'],
    optionalSlots: ['color'],
    defaultSlots: {
      color: null,           // Auto color scheme
    },
  },

  'data-table': {
    blockType: 'data-table',
    requiredSlots: ['data'],           // Data can be implicit (all fields)
    optionalSlots: ['columns', 'pageSize'],
    defaultSlots: {
      columns: null,         // All fields from data
      pageSize: 10,          // Default pagination
    },
  },

  'comparison': {
    blockType: 'comparison',
    requiredSlots: ['current', 'previous'],
    optionalSlots: ['label', 'format'],
    defaultSlots: {
      label: null,           // No label
      format: 'percent',     // Show as percentage change
    },
  },

  'text': {
    blockType: 'text',
    requiredSlots: ['content'],        // Content can be literal or bound
    optionalSlots: [],
    defaultSlots: {},
  },

  'metric-group': {
    blockType: 'metric-group',
    requiredSlots: ['metrics'],        // Array of metric bindings
    optionalSlots: [],
    defaultSlots: {},
  },

  // Layout blocks (no bindings required)
  'grid': {
    blockType: 'grid',
    requiredSlots: [],
    optionalSlots: [],
    defaultSlots: {},
  },

  'stack': {
    blockType: 'stack',
    requiredSlots: [],
    optionalSlots: [],
    defaultSlots: {},
  },

  // Interactive blocks (no data bindings, emit signals)
  'date-filter': {
    blockType: 'date-filter',
    requiredSlots: [],
    optionalSlots: ['label', 'format'],
    defaultSlots: {
      label: 'Date Range',
      format: 'YYYY-MM-DD',
    },
  },

  'select-filter': {
    blockType: 'select-filter',
    requiredSlots: ['options'],        // Options can be bound or literal
    optionalSlots: ['label', 'multiple'],
    defaultSlots: {
      label: 'Select',
      multiple: false,
    },
  },

  'search-input': {
    blockType: 'search-input',
    requiredSlots: [],
    optionalSlots: ['placeholder'],
    defaultSlots: {
      placeholder: 'Search...',
    },
  },
};

/**
 * Validation Rules
 */

function validateBinding(
  blockType: BlockType,
  binding: DataBinding | undefined
): ValidationResult {
  const requirements = BINDING_REQUIREMENTS[blockType];
  if (!requirements) {
    return { valid: false, errors: [`Unknown block type: ${blockType}`] };
  }

  const errors: string[] = [];

  // Layout blocks don't require bindings
  if (requirements.requiredSlots.length === 0 && !binding) {
    return { valid: true, errors: [] };
  }

  // Data blocks require bindings
  if (requirements.requiredSlots.length > 0 && !binding) {
    return {
      valid: false,
      errors: [`Block type ${blockType} requires binding with slots: ${requirements.requiredSlots.join(', ')}`],
    };
  }

  if (!binding) return { valid: true, errors: [] };

  // Check required fields in DataBinding
  if (!binding.source) {
    errors.push('DataBinding.source is required');
  }

  if (!binding.fields || binding.fields.length === 0) {
    errors.push('DataBinding.fields is required and must have at least one field');
  }

  // Check required slots are bound
  const boundSlots = new Set(binding.fields.map(f => f.target));
  for (const requiredSlot of requirements.requiredSlots) {
    if (!boundSlots.has(requiredSlot)) {
      errors.push(`Required slot '${requiredSlot}' is not bound for block type ${blockType}`);
    }
  }

  // Check all bound slots are valid
  const validSlots = new Set([...requirements.requiredSlots, ...requirements.optionalSlots]);
  for (const field of binding.fields) {
    if (!validSlots.has(field.target)) {
      errors.push(`Invalid slot '${field.target}' for block type ${blockType}`);
    }
  }

  // Check FieldBinding required fields
  for (const field of binding.fields) {
    if (!field.target) {
      errors.push('FieldBinding.target is required');
    }
    if (!field.field) {
      errors.push('FieldBinding.field is required');
    }
  }

  return { valid: errors.length === 0, errors };
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

/**
 * Default Application
 *
 * When optional slots are not bound, defaults are applied:
 */

function applyBindingDefaults(
  blockType: BlockType,
  binding: DataBinding | undefined
): DataBinding | undefined {
  if (!binding) return undefined;

  const requirements = BINDING_REQUIREMENTS[blockType];
  if (!requirements || !requirements.defaultSlots) return binding;

  const boundSlots = new Set(binding.fields.map(f => f.target));
  const defaultFields: FieldBinding[] = [];

  // Add defaults for unbound optional slots
  for (const [slot, defaultValue] of Object.entries(requirements.defaultSlots)) {
    if (!boundSlots.has(slot as BindingSlot) && defaultValue !== null) {
      defaultFields.push({
        target: slot as BindingSlot,
        field: `_default_${slot}`,  // Synthetic field
        transform: JSON.stringify(defaultValue),  // Literal value as transform
      });
    }
  }

  return {
    ...binding,
    fields: [...binding.fields, ...defaultFields],
  };
}
```

**Updated table from §9.2 with explicit requirements:**

| Block Type | Required Slots | Optional Slots | Defaults |
|------------|----------------|----------------|----------|
| kpi | value | label, trend, icon, compare | label: null, trend: null |
| bar-chart | category, value | color, label, stack | color: auto, label: category |
| line-chart | x, y | series, color, label | series: null, color: auto |
| pie-chart | label, value | color | color: auto |
| data-table | data | columns, pageSize | columns: all, pageSize: 10 |
| comparison | current, previous | label, format | format: 'percent' |
| text | content | — | — |
| metric-group | metrics | — | — |
| grid | — | — | — |
| stack | — | — | — |
| date-filter | — | label, format | label: 'Date Range' |
| select-filter | options | label, multiple | label: 'Select', multiple: false |
| search-input | — | placeholder | placeholder: 'Search...' |

**Section B.6.1 Update (ensure consistency):**

No changes needed to B.6.1 interface definitions. The clarifications above are normative for implementation behavior.

## Verification Checklist
- [x] Change addresses the identified issue (clear required vs optional with defaults)
- [x] No new inconsistencies introduced (table matches BlockType enum)
- [x] Cross-references remain valid (BindingSlot types from §9.2 unchanged)

## Confidence
**HIGH** - Resolution provides:
- Explicit REQUIRED vs OPTIONAL field markers
- Complete binding requirements table for all 13 block types
- Validation function that enforces requirements
- Default value application logic
- Clear rules: required fields MUST be present, optional fields MAY be present, defaults fill gaps
