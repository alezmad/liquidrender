# ISS-126: Complete Type System - Ensure All Types Defined

**Issue Type:** Developer Experience
**Category:** Evidence
**Severity:** High
**Status:** Resolved

---

## Problem Statement

The specification references many types but doesn't always provide complete definitions:

1. **Incomplete type definitions:** Types mentioned but not fully specified
2. **Missing discriminated unions:** Variant types without exhaustive enumeration
3. **Undefined utility types:** Helper types referenced but not defined
4. **Adapter types incomplete:** Adapter interface has gaps
5. **Internal engine types:** Discovery, resolution, compilation types not fully specified

Developers need complete type definitions for:
- Type-safe implementations
- Cross-implementation compatibility
- Code generation from spec
- Contract verification

---

## Resolution

### 1. Complete Core Type System

Add to **Appendix B.6.1** (Complete Type Definitions):

```typescript
/**
 * ═══════════════════════════════════════════════════════════════
 * COMPLETE LIQUIDCODE V2 TYPE SYSTEM
 * ═══════════════════════════════════════════════════════════════
 *
 * This is the normative, complete type system.
 * All implementations MUST conform exactly.
 */

// ─────────────────────────────────────────────────────────────────
// CORE PRIMITIVES (already in spec, repeated for completeness)
// ─────────────────────────────────────────────────────────────────

interface LiquidSchema {
  version: '2.0';
  scope: 'interface' | 'block';
  uid: string;
  id?: string;
  title: string;
  description?: string;
  generatedAt: string;
  layout: LayoutBlock;
  blocks: Block[];
  signals?: SignalRegistry;
  slotContext?: SlotContext;
  signalInheritance?: SignalInheritance;
  explainability?: SchemaExplainability;
  metadata?: SchemaMetadata;
}

interface Block {
  uid: string;
  id?: string;
  type: BlockType;
  binding?: DataBinding;
  slots?: Record<string, Block[]>;
  signals?: SignalConnections;
  layout?: BlockLayout;
  constraints?: RenderConstraints;
}

// ─────────────────────────────────────────────────────────────────
// LAYOUT TYPES (complete specification)
// ─────────────────────────────────────────────────────────────────

interface LayoutBlock {
  type: LayoutType;
  uid: string;
  id?: string;
  config: LayoutConfig;
  responsive?: ResponsiveConfig;
  children: Block[];
}

type LayoutType = 'grid' | 'stack' | 'flow' | 'tabs' | 'split';

// Discriminated union for layout config
type LayoutConfig =
  | GridConfig
  | StackConfig
  | FlowConfig
  | TabsConfig
  | SplitConfig;

interface GridConfig {
  type: 'grid';
  columns: number;
  rows?: number | 'auto';
  gap?: GapSpec;
  alignment?: AlignmentSpec;
}

interface StackConfig {
  type: 'stack';
  direction: 'vertical' | 'horizontal';
  gap?: GapSpec;
  alignment?: AlignmentSpec;
}

interface FlowConfig {
  type: 'flow';
  wrap: boolean;
  gap?: GapSpec;
  alignment?: AlignmentSpec;
}

interface TabsConfig {
  type: 'tabs';
  orientation: 'horizontal' | 'vertical';
  defaultTab?: number;
}

interface SplitConfig {
  type: 'split';
  orientation: 'horizontal' | 'vertical';
  ratio?: number;  // 0-1, default 0.5
  resizable?: boolean;
}

interface GapSpec {
  row?: number | 'none' | 'tight' | 'normal' | 'loose';
  column?: number | 'none' | 'tight' | 'normal' | 'loose';
}

interface AlignmentSpec {
  horizontal?: 'left' | 'center' | 'right' | 'stretch';
  vertical?: 'top' | 'center' | 'bottom' | 'stretch';
}

interface ResponsiveConfig {
  breakpoints?: {
    compact?: BreakpointLayout;
    standard?: BreakpointLayout;
    expanded?: BreakpointLayout;
  };
  auto?: AutoLayoutConfig;
}

interface BreakpointLayout {
  columns?: number;
  visiblePriorities?: (1 | 2 | 3 | 4)[];
  collapse?: string[];  // Block UIDs
  stack?: string[][];   // Groups to stack
}

interface AutoLayoutConfig {
  minColumnWidth: number;
  maxColumns: number;
  gutter: 'none' | 'tight' | 'normal' | 'loose';
}

// ─────────────────────────────────────────────────────────────────
// RENDER CONSTRAINT TYPES (new, referenced in Block)
// ─────────────────────────────────────────────────────────────────

interface RenderConstraints {
  // Minimum viable dimensions
  minWidth?: number;
  minHeight?: number;

  // Aspect ratio enforcement
  aspectRatio?: number | 'auto';

  // Visibility conditions (LiquidExpr)
  visible?: string;

  // Render timeout (ms)
  timeout?: number;

  // Loading state
  loadingTemplate?: Block;

  // Error state
  errorTemplate?: Block;
}

// ─────────────────────────────────────────────────────────────────
// OPERATION TYPES (mutations, queries)
// ─────────────────────────────────────────────────────────────────

type Operation =
  | AddOperation
  | RemoveOperation
  | ReplaceOperation
  | ModifyOperation
  | MoveOperation
  | BatchOperation;

interface AddOperation {
  type: 'add';
  block: Block;
  position: PositionSpec;
  targetSlot?: string;  // If adding to slot
}

interface RemoveOperation {
  type: 'remove';
  targetUid: string;
}

interface ReplaceOperation {
  type: 'replace';
  targetUid: string;
  newBlockType: BlockType;
  preserveBinding?: boolean;
  preserveSignals?: boolean;
}

interface ModifyOperation {
  type: 'modify';
  targetUid: string;
  path: PropertyPath;
  value: unknown;
}

interface MoveOperation {
  type: 'move';
  targetUid: string;
  newPosition: PositionSpec;
  newSlot?: string;
}

interface BatchOperation {
  type: 'batch';
  operations: Operation[];
  atomic: boolean;  // All succeed or all fail
}

type PositionSpec =
  | { type: 'grid'; row: number; column: number }
  | { type: 'ordinal'; index: number }
  | { type: 'relative'; anchor: string; direction: 'before' | 'after' | 'inside' }
  | { type: 'auto' };  // Engine decides

type PropertyPath = string;  // JSON pointer format: "/layout/priority"

// ─────────────────────────────────────────────────────────────────
// QUERY TYPES
// ─────────────────────────────────────────────────────────────────

type Query =
  | BlockQuery
  | SummaryQuery
  | DiffQuery
  | SnapshotQuery;

interface BlockQuery {
  type: 'block';
  selector: Selector;
}

interface SummaryQuery {
  type: 'summary';
  include?: ('blocks' | 'signals' | 'bindings' | 'layout')[];
}

interface DiffQuery {
  type: 'diff';
  snapshot1: SnapshotRef;
  snapshot2: SnapshotRef;
}

interface SnapshotQuery {
  type: 'snapshot';
  ref: SnapshotRef;
}

type SnapshotRef =
  | { type: 'operation'; index: number }
  | { type: 'timestamp'; time: number }
  | { type: 'current' }
  | { type: 'relative'; offset: number };  // -1 = previous

// ─────────────────────────────────────────────────────────────────
// SELECTOR TYPES (addresses)
// ─────────────────────────────────────────────────────────────────

type Selector =
  | ExplicitIdSelector
  | GridPositionSelector
  | TypeOrdinalSelector
  | BindingSignatureSelector
  | PureOrdinalSelector
  | WildcardSelector;

interface ExplicitIdSelector {
  type: 'explicit-id';
  id: string;
}

interface GridPositionSelector {
  type: 'grid-position';
  row: number;
  column: number;
}

interface TypeOrdinalSelector {
  type: 'type-ordinal';
  blockType: BlockType;
  ordinal: number;
}

interface BindingSignatureSelector {
  type: 'binding-signature';
  field: string;
  pattern?: 'exact' | 'prefix' | 'suffix' | 'contains';
}

interface PureOrdinalSelector {
  type: 'pure-ordinal';
  ordinal: number;
}

interface WildcardSelector {
  type: 'wildcard';
  base: Selector;
  pattern: string;
}

// ─────────────────────────────────────────────────────────────────
// DISCOVERY ENGINE TYPES
// ─────────────────────────────────────────────────────────────────

interface DataFingerprint {
  schemaHash: string;
  fieldCount: number;
  fields: FieldFingerprint[];
  relationships: Relationship[];
  statistics: DataStatistics;
}

interface FieldFingerprint {
  name: string;
  type: DataType;
  primitive: UOMPrimitive;
  cardinality: number;
  nullRate: number;
  sampleValues: unknown[];
}

type DataType =
  | 'string'
  | 'number'
  | 'boolean'
  | 'date'
  | 'array'
  | 'object'
  | 'null'
  | 'unknown';

type UOMPrimitive =
  | 'date'
  | 'currency'
  | 'count'
  | 'percentage'
  | 'category'
  | 'identifier'
  | 'text'
  | 'boolean'
  | 'unknown';

interface Relationship {
  type: 'foreign-key' | 'hierarchy' | 'temporal';
  fromField: string;
  toField: string;
  cardinality: '1:1' | '1:N' | 'N:M';
}

interface DataStatistics {
  rowCount: number;
  completeness: number;  // 0-1
  uniquenessMean: number;  // 0-1
}

interface ArchetypeDetection {
  archetype: ArchetypeType;
  confidence: number;
  signals: DetectionSignal[];
}

type ArchetypeType =
  | 'overview'
  | 'time_series'
  | 'comparison'
  | 'funnel'
  | 'hierarchical'
  | 'distribution'
  | 'correlation'
  | 'detail'
  | 'custom';

interface DetectionSignal {
  source: 'schema' | 'data' | 'pattern' | 'user';
  weight: number;
  reason: string;
}

// ─────────────────────────────────────────────────────────────────
// FRAGMENT CACHE TYPES
// ─────────────────────────────────────────────────────────────────

interface CachedFragment {
  key: CacheKey;
  fragment: FragmentContent;
  metadata: FragmentMetadata;
}

interface CacheKey {
  intentHash: string;
  dataFingerprint: string;
  archetypeHint?: string;
  scope: 'interface' | 'block';
  tenantId: string;
  userId?: string;
}

type FragmentContent =
  | ArchetypeFragment
  | BlockFragment
  | CompositionFragment
  | PolishFragment
  | BindingTemplateFragment;

interface ArchetypeFragment {
  type: 'archetype';
  archetype: ArchetypeType;
  layout: LayoutBlock;
  blockCount: number;
}

interface BlockFragment {
  type: 'block';
  block: Block;
}

interface CompositionFragment {
  type: 'composition';
  blocks: Block[];
  signals: SignalRegistry;
  layout: LayoutBlock;
}

interface PolishFragment {
  type: 'polish';
  labels: Record<string, string>;
  formats: Record<string, string>;
}

interface BindingTemplateFragment {
  type: 'binding-template';
  pattern: BindingPattern;
  examples: DataBinding[];
}

interface BindingPattern {
  blockType: BlockType;
  requiredPrimitives: UOMPrimitive[];
  optionalPrimitives: UOMPrimitive[];
}

interface FragmentMetadata {
  createdAt: number;
  accessCount: number;
  lastAccessedAt: number;
  ttl: number;
  confidence: number;
  source: 'discovery' | 'user-request' | 'composition';
}

// ─────────────────────────────────────────────────────────────────
// RESOLUTION TIER TYPES
// ─────────────────────────────────────────────────────────────────

type ResolutionTier = 1 | 2 | 3 | 4;

interface ResolutionResult {
  tier: ResolutionTier;
  schema: LiquidSchema;
  latencyMs: number;
  cacheHit: boolean;
  confidence: number;
  source: ResolutionSource;
}

type ResolutionSource =
  | CacheHitSource
  | SemanticMatchSource
  | CompositionSource
  | LLMGenerationSource;

interface CacheHitSource {
  type: 'cache-hit';
  fragmentKey: CacheKey;
}

interface SemanticMatchSource {
  type: 'semantic-match';
  similarity: number;
  matchedFragment: CacheKey;
  adaptations: Adaptation[];
}

interface CompositionSource {
  type: 'composition';
  composedFragments: CacheKey[];
  compositionRule: CompositionRule;
}

interface LLMGenerationSource {
  type: 'llm-generation';
  prompt: string;
  model: string;
  tokenCount: number;
}

interface Adaptation {
  type: 'binding' | 'label' | 'format' | 'layout';
  target: string;  // UID or path
  change: unknown;
}

interface CompositionRule {
  pattern: IntentPattern;
  fragments: FragmentRef[];
  layout: LayoutInferenceRule;
  signals: SignalWiringRule;
}

interface IntentPattern {
  archetypes: ArchetypeType[];
  primitives: UOMPrimitive[];
  keywords: string[];
}

interface FragmentRef {
  type: string;
  selector: string;
}

interface LayoutInferenceRule {
  blockCount: number;
  rule: string;  // Description
  layout: LayoutType;
}

interface SignalWiringRule {
  emitterType: BlockType;
  receiverTypes: BlockType[];
  signal: string;
}

// ─────────────────────────────────────────────────────────────────
// COMPILATION TYPES
// ─────────────────────────────────────────────────────────────────

interface CompilationContext {
  source: string;  // LiquidCode
  dataFingerprint?: DataFingerprint;
  slotContext?: SlotContext;
  mode: CompilationMode;
}

type CompilationMode =
  | 'generation'
  | 'mutation'
  | 'validation-only';

interface CompilationResult {
  success: boolean;
  schema?: LiquidSchema;
  errors?: CompilationError[];
  warnings?: CompilationWarning[];
  metadata: CompilationMetadata;
}

interface CompilationError {
  type: ErrorType;
  message: string;
  location?: SourceLocation;
  suggestion?: string;
}

type ErrorType =
  | 'syntax'
  | 'semantic'
  | 'validation'
  | 'reference'
  | 'type'
  | 'constraint';

interface SourceLocation {
  line: number;
  column: number;
  length: number;
}

interface CompilationWarning {
  type: WarningType;
  message: string;
  location?: SourceLocation;
}

type WarningType =
  | 'unused-signal'
  | 'low-confidence-binding'
  | 'performance'
  | 'style';

interface CompilationMetadata {
  durationMs: number;
  tokenCount: number;
  blockCount: number;
  validationPassed: boolean;
}

// ─────────────────────────────────────────────────────────────────
// ADAPTER TYPES (complete)
// ─────────────────────────────────────────────────────────────────

interface LiquidAdapter<RenderOutput> {
  // Core rendering
  render(schema: LiquidSchema, data: unknown): RenderOutput;
  renderBlock(block: Block, data: unknown): RenderOutput;

  // Layout-aware rendering (§11)
  renderWithContext(
    schema: LiquidSchema,
    data: unknown,
    context: SlotContext
  ): RenderOutput;

  // Calculate layout for context
  calculateLayout(
    schema: LiquidSchema,
    context: SlotContext
  ): LayoutPlan;

  // Block support
  supports(blockType: BlockType): boolean;
  renderPlaceholder(block: Block, reason: string): RenderOutput;
  renderEmptyState(block: Block): RenderOutput;

  // Signal runtime
  createSignalRuntime(registry: SignalRegistry): SignalRuntime;

  // Security (B.8)
  sanitizeData(data: unknown): unknown;
  onSecurityViolation(violation: SecurityViolation): void;

  // Lifecycle
  beforeRender?(schema: LiquidSchema): void;
  afterRender?(output: RenderOutput): void;
  onError?(error: RenderError): RenderOutput;

  // Metadata
  readonly metadata: AdapterMetadata;
  readonly renderTimeout: number;
  readonly securityRequirements: AdapterSecurityRequirements;
}

interface LayoutPlan {
  breakpoint: Breakpoint;
  visibleBlocks: string[];
  collapsedBlocks: string[];
  hiddenBlocks: string[];
  grid: GridCell[];
}

interface GridCell {
  blockId: string;
  row: number;
  column: number;
  rowSpan: number;
  colSpan: number;
  width: number;
  height: number | 'auto';
}

interface SecurityViolation {
  type: 'injection' | 'xss' | 'unauthorized-field' | 'cache-poison';
  message: string;
  context: unknown;
}

interface RenderError {
  type: 'timeout' | 'unsupported' | 'data-mismatch' | 'internal';
  message: string;
  block?: Block;
  cause?: Error;
}

interface AdapterSecurityRequirements {
  htmlEscape: boolean;
  jsEscape: boolean;
  urlEscape: boolean;
  noInlineScripts: boolean;
  noInlineStyles: boolean;
  validateDataShape: boolean;
}

// ─────────────────────────────────────────────────────────────────
// DIGITAL TWIN TYPES
// ─────────────────────────────────────────────────────────────────

interface DigitalTwin {
  schema: LiquidSchema;
  timestamp: number;
  operationCount: number;
  history: OperationHistory;
}

interface OperationHistory {
  operations: AppliedOperation[];
  maxSize: number;
  currentIndex: number;
}

interface AppliedOperation {
  operation: Operation;
  timestamp: number;
  inverse: Operation;
  beforeHash: string;
  afterHash: string;
  metadata: OperationMetadata;
}

interface OperationMetadata {
  source: 'user' | 'system' | 'automation';
  userId?: string;
  sessionId?: string;
  reason?: string;
}

// ─────────────────────────────────────────────────────────────────
// VALIDATION TYPES
// ─────────────────────────────────────────────────────────────────

interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

interface ValidationError {
  path: string;
  message: string;
  code: string;
  expected?: string;
  received?: unknown;
}

interface ValidationWarning {
  path: string;
  message: string;
  code: string;
}

// ─────────────────────────────────────────────────────────────────
// UTILITY TYPES
// ─────────────────────────────────────────────────────────────────

// Histogram for metrics
interface Histogram {
  p50: number;
  p95: number;
  p99: number;
  min: number;
  max: number;
  mean: number;
  count: number;
}

// Time series for monitoring
interface TimeSeries<T> {
  timestamp: number;
  value: T;
}

// Result type for operations that can fail
type Result<T, E = Error> =
  | { success: true; value: T }
  | { success: false; error: E };

// ═══════════════════════════════════════════════════════════════
// END OF COMPLETE TYPE SYSTEM
// ═══════════════════════════════════════════════════════════════
```

### 2. Type Completeness Checklist

Add new section after B.6.3:

```markdown
#### B.6.4 Type System Completeness Checklist

All implementations MUST define these types exactly as specified:

**Core Schema Types:**
- [ ] LiquidSchema
- [ ] Block
- [ ] BlockType (exhaustive union)
- [ ] DataBinding
- [ ] FieldBinding
- [ ] BindingSlot (exhaustive union)
- [ ] SignalRegistry
- [ ] SignalDefinition
- [ ] SignalType (exhaustive union)
- [ ] SignalConnections
- [ ] SignalEmission
- [ ] SignalReception

**Layout Types:**
- [ ] LayoutBlock
- [ ] LayoutType (exhaustive union)
- [ ] LayoutConfig (discriminated union)
- [ ] GridConfig, StackConfig, FlowConfig, TabsConfig, SplitConfig
- [ ] BlockLayout
- [ ] SizeHints, SpanSpec, RelationshipSpec
- [ ] ResponsiveConfig, BreakpointLayout, AutoLayoutConfig
- [ ] SlotContext
- [ ] RenderConstraints (NEW)

**Operation Types:**
- [ ] Operation (discriminated union)
- [ ] AddOperation, RemoveOperation, ReplaceOperation, ModifyOperation, MoveOperation, BatchOperation
- [ ] PositionSpec (discriminated union)
- [ ] PropertyPath

**Query Types:**
- [ ] Query (discriminated union)
- [ ] BlockQuery, SummaryQuery, DiffQuery, SnapshotQuery
- [ ] SnapshotRef (discriminated union)

**Selector Types:**
- [ ] Selector (discriminated union)
- [ ] ExplicitIdSelector, GridPositionSelector, TypeOrdinalSelector, BindingSignatureSelector, PureOrdinalSelector, WildcardSelector

**Discovery Types:**
- [ ] DataFingerprint
- [ ] FieldFingerprint
- [ ] DataType, UOMPrimitive (exhaustive unions)
- [ ] Relationship
- [ ] DataStatistics
- [ ] ArchetypeDetection
- [ ] ArchetypeType (exhaustive union)
- [ ] DetectionSignal

**Cache Types:**
- [ ] CachedFragment
- [ ] CacheKey
- [ ] FragmentContent (discriminated union)
- [ ] ArchetypeFragment, BlockFragment, CompositionFragment, PolishFragment, BindingTemplateFragment
- [ ] FragmentMetadata

**Resolution Types:**
- [ ] ResolutionTier
- [ ] ResolutionResult
- [ ] ResolutionSource (discriminated union)
- [ ] CacheHitSource, SemanticMatchSource, CompositionSource, LLMGenerationSource
- [ ] Adaptation, CompositionRule, IntentPattern, FragmentRef
- [ ] LayoutInferenceRule, SignalWiringRule

**Compilation Types:**
- [ ] CompilationContext
- [ ] CompilationMode (exhaustive union)
- [ ] CompilationResult
- [ ] CompilationError, CompilationWarning
- [ ] ErrorType, WarningType (exhaustive unions)
- [ ] SourceLocation
- [ ] CompilationMetadata

**Adapter Types:**
- [ ] LiquidAdapter<T> (complete interface)
- [ ] LayoutPlan, GridCell
- [ ] SecurityViolation, RenderError
- [ ] AdapterMetadata
- [ ] AdapterSecurityRequirements

**Digital Twin Types:**
- [ ] DigitalTwin
- [ ] OperationHistory
- [ ] AppliedOperation
- [ ] OperationMetadata

**Validation Types:**
- [ ] ValidationResult
- [ ] ValidationError
- [ ] ValidationWarning

**Utility Types:**
- [ ] Histogram
- [ ] TimeSeries<T>
- [ ] Result<T, E>

**TOTAL: 100+ types fully specified**
```

### 3. Type Export Requirement

Add to **B.6.5 Type Export Requirements**:

```typescript
/**
 * Type Export Requirements
 *
 * Implementations MUST export all types for external use.
 */

// TypeScript implementations
export type {
  // Core
  LiquidSchema,
  Block,
  BlockType,
  DataBinding,
  SignalRegistry,
  // ... all types

  // Adapters can extend but not modify
  LiquidAdapter,
};

// Validation: Implementations must pass this test
import type { LiquidSchema } from '@liquidcode/types';

const schema: LiquidSchema = {
  version: '2.0',
  scope: 'interface',
  uid: 's_abc123def456',
  title: 'Test',
  generatedAt: new Date().toISOString(),
  layout: {
    type: 'grid',
    uid: 'b_layout',
    config: { type: 'grid', columns: 2 },
    children: [],
  },
  blocks: [],
};

// Must compile without errors
```

### 4. Discriminated Union Exhaustiveness

Add to **B.6.6 Exhaustive Type Checking**:

```typescript
/**
 * Exhaustive Checking Requirements
 *
 * All discriminated unions MUST use exhaustive checking.
 */

// Example: Operation handling
function applyOperation(op: Operation): void {
  switch (op.type) {
    case 'add':
      return handleAdd(op);
    case 'remove':
      return handleRemove(op);
    case 'replace':
      return handleReplace(op);
    case 'modify':
      return handleModify(op);
    case 'move':
      return handleMove(op);
    case 'batch':
      return handleBatch(op);
    default:
      // Exhaustiveness check: TypeScript error if case missing
      const _exhaustive: never = op;
      throw new Error(`Unhandled operation type: ${(_exhaustive as any).type}`);
  }
}

// Same pattern required for:
// - LayoutConfig variants
// - Query variants
// - Selector variants
// - FragmentContent variants
// - ResolutionSource variants
// - All other discriminated unions
```

---

## Testing Criteria

### Type Completeness Validation

1. **All Types Defined:**
   - [ ] No `any` types in spec
   - [ ] No `unknown` without justification
   - [ ] All referenced types have definitions

2. **Discriminated Unions:**
   - [ ] All variants enumerated
   - [ ] Discriminator field consistent
   - [ ] Exhaustive checking enforced

3. **Adapter Contract:**
   - [ ] All required methods defined
   - [ ] Optional methods marked correctly
   - [ ] Security methods included

4. **Cross-Implementation:**
   - [ ] Type definitions exportable
   - [ ] TypeScript compiles without errors
   - [ ] Zod schemas match TypeScript types

5. **Code Generation:**
   - [ ] Can generate validators from types
   - [ ] Can generate mock data from types
   - [ ] Can generate adapters from interface

---

## Migration Notes

**Impact:** Medium - Adds many new types but doesn't change existing
**Compatibility:** Backwards compatible - New types are additions

### For Implementers:

1. Import complete type system from spec
2. Ensure all types match exactly (use `extends` checks)
3. Add missing types (especially RenderConstraints, new operation types)
4. Implement exhaustive checking for all discriminated unions
5. Export all types for external use

### For Users:

No changes required. Complete types improve TypeScript experience.

---

## References

- **§4** - The Three Primitives
- **§6** - LiquidCode Grammar
- **§7** - Interface Algebra
- **§11** - Layout & Responsiveness System
- **§12** - Discovery Engine
- **§13** - Tiered Resolution System
- **§17** - Compilation Pipeline
- **§18** - Adapter Interface Contract
- **Appendix B.6** - Normative LiquidSchema Specification

---

## Resolution Summary

Completed type system with:

1. **100+ fully specified types** covering all spec sections
2. **RenderConstraints** - New type for render-time controls
3. **Complete operation types** - All mutation/query operations
4. **Complete discovery types** - Fingerprinting, archetypes, primitives
5. **Complete resolution types** - All four tiers, sources, adaptations
6. **Complete adapter types** - Full contract with security, layout, lifecycle
7. **Complete compilation types** - Context, errors, warnings, metadata
8. **Exhaustive union checking** - Required for all discriminated unions
9. **Type export requirements** - All types must be externally accessible
10. **Completeness checklist** - 100+ types to verify

No undefined types remain in specification.
