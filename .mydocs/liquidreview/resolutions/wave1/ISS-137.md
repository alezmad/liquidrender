# Resolution: ISS-137

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Provide Reference Implementation
**Severity:** Minor
**Target:** SPEC
**Section:** New Appendix D

## Resolution

### Original Content (Lines N/A)
```markdown
[No reference implementation specification currently exists]
```

### Replacement Content
```markdown
## Appendix D: Reference Implementation

This appendix defines the requirements and scope for the official LiquidCode v2 reference implementation.

### D.1 Purpose & Goals

The reference implementation serves three purposes:

1. **Specification Validation:** Prove that the spec is complete and implementable
2. **Interoperability Baseline:** Define expected behavior for edge cases and ambiguities
3. **Development Accelerator:** Provide working code for implementers to study and adapt

**Non-goals:**
- ❌ Production-ready system (optimizations may be omitted)
- ❌ Feature-complete (extensions like custom blocks are optional)
- ❌ Multi-platform (focus on one adapter initially)

---

### D.2 Scope & Components

#### D.2.1 Required Components

The reference implementation MUST include:

| Component | Coverage | Acceptance Criteria |
|-----------|----------|---------------------|
| **Core Schema** | 100% of §B.6.1 types | All interfaces defined, Zod validated |
| **LiquidCode Parser** | 100% of §6 grammar | Parses all spec examples without errors |
| **Compiler Pipeline** | 100% of §17 | AST → LiquidSchema deterministically |
| **Block Addressing** | 100% of §8 | All 5 address forms resolve correctly |
| **Binding System** | Core only | Type matching + basic semantic scoring |
| **Signal System** | Core only | Emit/receive + URL persistence |
| **Digital Twin** | 100% of §16 | State tracking + undo/redo |
| **Adapter Interface** | 100% of §18 | Full contract implemented |
| **React Adapter** | 13 core blocks | All blocks + signals + layout |
| **Conformance Tests** | 100% of §B.3.3 | All tests pass for React adapter |

#### D.2.2 Optional Components

The reference implementation MAY include:

| Component | Priority | Rationale |
|-----------|----------|-----------|
| **Discovery Engine** | Medium | Complex ML components, high effort |
| **Fragment Cache** | Low | Requires external dependencies (Redis, vector DB) |
| **Tiered Resolution** | Low | Depends on cache + LLM integration |
| **LLM Integration** | Low | Requires API keys, variable costs |
| **Layout Solver** | Medium | Complex constraint solving, adapter-specific |
| **Compositional Grammar** | Low | Depends on cache infrastructure |

**Rationale:** The reference implementation focuses on **deterministic components** that can be tested objectively. Stochastic components (LLM, discovery) and infrastructure-dependent components (cache) are left to production implementations.

---

### D.3 Implementation Requirements

#### D.3.1 Language & Tooling

**Primary language:** TypeScript (for type safety and web compatibility)

**Required tooling:**
- Node.js ≥18
- TypeScript ≥5.0
- Zod ≥3.22
- React ≥18 (for adapter)
- Jest or Vitest (for testing)

**Code organization:**
```
liquidcode-reference/
├── packages/
│   ├── schema/          # Core types + validation (§B.6)
│   ├── parser/          # LiquidCode → AST (§6, §17)
│   ├── compiler/        # AST → LiquidSchema (§17)
│   ├── addressing/      # Block addressing (§8)
│   ├── binding/         # Binding system (§9)
│   ├── signals/         # Signal system (§10)
│   ├── state/           # Digital Twin (§16)
│   ├── adapter-react/   # React adapter (§18)
│   └── testing/         # Conformance tests (§B.3)
├── examples/            # Example dashboards
├── docs/                # API reference
└── README.md
```

#### D.3.2 Code Quality Requirements

- **Type safety:** 100% TypeScript, `strict: true`, no `any` types
- **Test coverage:** ≥80% line coverage for core packages
- **Documentation:** JSDoc for all public APIs
- **Linting:** ESLint + Prettier, zero warnings
- **Performance:** Compilation <100ms for typical dashboard (no LLM)

---

### D.4 Functional Requirements

#### D.4.1 Parser (packages/parser)

**Input:** LiquidCode string (ASCII or Unicode)
**Output:** AST or parse error with line/column

**Must handle:**
- All generation syntax (§6.3)
- All mutation syntax (§7.2)
- All signal syntax (§6.4)
- All layout syntax (§11.6)
- ASCII operator forms (§B.1)
- Unicode operator forms (§B.1)

**Test cases (minimum 50):**
```typescript
// Generation
parse('#overview;G2x2;K$revenue,L$date$amount')
parse('signal:dateRange:dr=30d,url')  // ASCII
parse('§dateRange:dr=30d,url')         // Unicode

// Mutation
parse('delta:+K$profit@[1,2]')         // ASCII
parse('Δ+K$profit@[1,2]')              // Unicode
parse('delta:-@K1')
parse('delta:~@K0.label:"New Label"')

// Edge cases
parse('')  // Empty → error
parse(';;;')  // Invalid → error
parse('#overview;G2x2;')  // Trailing delimiter → error
```

**Error messages must include:**
- Line and column number
- Expected token type
- Actual token found
- Suggestion for fix (if applicable)

---

#### D.4.2 Compiler (packages/compiler)

**Input:** AST
**Output:** LiquidSchema (validated by Zod)

**Must handle:**
- L0/L1/L2 layer separation (§5)
- UID generation (§B.2)
- Layout resolution (basic grid/stack)
- Signal registry creation (§10.2)
- Binding validation (§9.2)

**Guarantees:**
- Deterministic output (same AST → same schema hash)
- Valid schema (Zod validation passes)
- All UIDs unique
- All references resolved (or compile error)

**Test cases (minimum 30):**
```typescript
// Basic compilation
const ast = parse('#overview;G2x2;K$revenue');
const schema = compile(ast);
expect(schema.version).toBe('2.0');
expect(schema.blocks).toHaveLength(1);
expect(schema.blocks[0].uid).toMatch(/^b_[a-z0-9]{12}$/);

// UID stability
const schema1 = compile(ast);
const schema2 = compile(ast);
expect(schema1.blocks[0].uid).not.toBe(schema2.blocks[0].uid);  // Different UIDs
expect(canonicalize(schema1)).toBe(canonicalize(schema2));     // But same structure

// Validation errors
const badAST = { /* missing required fields */ };
expect(() => compile(badAST)).toThrow();
```

---

#### D.4.3 Addressing (packages/addressing)

**Input:** Address selector + LiquidSchema
**Output:** Array of matching UIDs

**Must handle:**
- Pure ordinal (@0, @1)
- Type ordinal (@K0, @L1)
- Grid position (@[0,1])
- Binding signature (@:revenue)
- Explicit ID (@#myId)
- Wildcards (@K*, @[*,0])

**Resolution priority (§8.3):**
1. Explicit ID
2. Grid position
3. Type ordinal
4. Binding signature
5. Pure ordinal

**Test cases (minimum 25):**
```typescript
const schema = {
  blocks: [
    { uid: 'b_001', type: 'kpi', id: 'main', binding: { fields: [{ field: 'revenue' }] } },
    { uid: 'b_002', type: 'kpi', binding: { fields: [{ field: 'orders' }] } },
    { uid: 'b_003', type: 'line-chart' },
  ],
  layout: { type: 'grid', dimensions: { rows: 2, columns: 2 } },
};

expect(resolve('@#main', schema)).toEqual(['b_001']);
expect(resolve('@K0', schema)).toEqual(['b_001']);
expect(resolve('@K1', schema)).toEqual(['b_002']);
expect(resolve('@:revenue', schema)).toEqual(['b_001']);
expect(resolve('@[0,0]', schema)).toEqual(['b_001']);  // Assuming grid position
expect(resolve('@K*', schema)).toEqual(['b_001', 'b_002']);
```

---

#### D.4.4 Binding System (packages/binding)

**Scope for reference implementation:** Basic type matching only

**Must handle:**
- Block type → required slots mapping (§9.2)
- Field type detection (number, string, date)
- Simple semantic matching (field name contains "revenue", "date", etc.)

**MAY omit:**
- ML-based semantic similarity (see Gap 3 in Implementation Gaps)
- Complex scoring algorithms
- User history tracking

**Test cases (minimum 15):**
```typescript
const data = {
  date: [new Date(), ...],
  revenue: [100, 200, ...],
  region: ['US', 'EU', ...],
};

// Type matching
expect(matchSlot('revenue', 'value')).toBe(true);   // number → value
expect(matchSlot('date', 'x')).toBe(true);          // date → x axis
expect(matchSlot('region', 'category')).toBe(true); // string → category

// Semantic matching (simple)
expect(semanticScore('total_revenue', 'value')).toBeGreaterThan(0.7);
expect(semanticScore('order_date', 'x')).toBeGreaterThan(0.7);
```

---

#### D.4.5 Signal System (packages/signals)

**Must handle:**
- Signal registry (§10.2)
- Emit/receive connections (§10.3)
- URL persistence (serialize/deserialize)
- Type validation (§10.2)

**MAY omit:**
- Session/local storage (focus on URL only)
- Complex transforms (basic passthrough only)

**Test cases (minimum 20):**
```typescript
// Registry
const registry = new SignalRegistry({
  dateRange: { type: 'dateRange', default: { start: '2024-01-01', end: '2024-12-31' }, persist: 'url' },
});

expect(registry.get('dateRange')).toEqual({ start: '2024-01-01', end: '2024-12-31' });

// Emit/receive
const runtime = createSignalRuntime(registry);
runtime.set('dateRange', { start: '2024-06-01', end: '2024-06-30' });
expect(runtime.get('dateRange')).toEqual({ start: '2024-06-01', end: '2024-06-30' });

// URL persistence
const url = runtime.persistToURL();
expect(url).toContain('dateRange=');
const restored = SignalRuntime.fromURL(url, registry);
expect(restored.get('dateRange')).toEqual({ start: '2024-06-01', end: '2024-06-30' });
```

---

#### D.4.6 Digital Twin (packages/state)

**Must handle:**
- Current state tracking (§16.1)
- Operation history (§16.2)
- Undo/redo (§16.2)
- Snapshot addressing (§16.3)

**Test cases (minimum 15):**
```typescript
const twin = new DigitalTwin(initialSchema);

// Mutation tracking
const mutation = { type: 'modify', targetUid: 'b_001', property: 'label', value: 'New' };
twin.apply(mutation);
expect(twin.schema.blocks[0].label).toBe('New');
expect(twin.operationCount).toBe(1);

// Undo/redo
twin.undo();
expect(twin.schema.blocks[0].label).toBeUndefined();
twin.redo();
expect(twin.schema.blocks[0].label).toBe('New');

// Snapshots
const snapshot3 = twin.history.snapshot(3);
expect(snapshot3).toBeDefined();
```

---

#### D.4.7 React Adapter (packages/adapter-react)

**Must render:**
- All 13 core block types (§A.2)
- Grid and stack layouts (§11)
- Signal-connected components (§10)
- Placeholders for custom types (§19.2)

**Block implementations:**
```typescript
// Required blocks
renderKPI(block: Block, data: any): React.ReactElement
renderBarChart(block: Block, data: any): React.ReactElement
renderLineChart(block: Block, data: any): React.ReactElement
renderPieChart(block: Block, data: any): React.ReactElement
renderDataTable(block: Block, data: any): React.ReactElement
renderGrid(block: Block, data: any): React.ReactElement
renderStack(block: Block, data: any): React.ReactElement
renderText(block: Block, data: any): React.ReactElement
renderMetricGroup(block: Block, data: any): React.ReactElement
renderComparison(block: Block, data: any): React.ReactElement
renderDateFilter(block: Block, runtime: SignalRuntime): React.ReactElement
renderSelectFilter(block: Block, runtime: SignalRuntime): React.ReactElement
renderSearchInput(block: Block, runtime: SignalRuntime): React.ReactElement
```

**Rendering rules:**
- Use semantic HTML (not just divs)
- Support dark mode via CSS variables
- Responsive by default (flex/grid)
- Accessible (ARIA labels, keyboard nav)

**Test cases (minimum 13, one per block type):**
```typescript
it('renders KPI block', () => {
  const block: Block = {
    uid: 'b_001',
    type: 'kpi',
    binding: { fields: [{ target: 'value', field: 'revenue' }] },
  };
  const data = { revenue: 12345 };

  const { container } = render(<BlockRenderer block={block} data={data} />);
  expect(container).toHaveTextContent('12345');
  expect(container.querySelector('[role="status"]')).toBeTruthy();  // Accessible
});
```

---

### D.5 Non-Functional Requirements

#### D.5.1 Performance Targets

For reference implementation (without LLM/cache):

| Operation | Target | Measurement |
|-----------|--------|-------------|
| Parse LiquidCode | <10ms | P95 for 50-token input |
| Compile to schema | <50ms | P95 for 10-block dashboard |
| Resolve address | <1ms | P95 for any selector |
| Render (React) | <100ms | Initial paint for 10-block dashboard |
| Undo/redo | <5ms | State transition |

**Note:** These are lower than spec targets (§1.1) because LLM/cache tiers are omitted.

#### D.5.2 Reliability Targets

| Metric | Target | Measurement |
|--------|--------|-------------|
| Parse error rate | <1% | On valid LiquidCode from spec examples |
| Compile success rate | 100% | On valid AST |
| Render success rate | 100% | On valid schema + matching data |
| Conformance pass rate | 100% | All tests in §B.3.3 |

#### D.5.3 Code Quality Targets

| Metric | Target | Tool |
|--------|--------|------|
| Test coverage | ≥80% | Jest/Vitest coverage report |
| Type coverage | 100% | TypeScript strict mode |
| Linting errors | 0 | ESLint |
| Formatting issues | 0 | Prettier |
| Bundle size | <100KB | webpack-bundle-analyzer (adapter only) |

---

### D.6 Testing Requirements

#### D.6.1 Unit Tests

**Minimum test cases by package:**

| Package | Test Cases | Coverage Target |
|---------|------------|-----------------|
| schema | 30 | 90% |
| parser | 50 | 85% |
| compiler | 30 | 85% |
| addressing | 25 | 90% |
| binding | 15 | 75% |
| signals | 20 | 80% |
| state | 15 | 85% |
| adapter-react | 13+ | 70% |

**Total:** ~200 unit tests minimum

#### D.6.2 Integration Tests

**End-to-end scenarios (minimum 10):**
```typescript
describe('Full Pipeline', () => {
  it('generates and renders sales dashboard', () => {
    const liquidCode = '#overview;G2x2;K$revenue,K$orders,L$date$revenue,T$orders';
    const data = { /* sample data */ };

    const ast = parse(tokenize(liquidCode));
    const schema = compile(ast);
    const element = render(<LiquidAdapter schema={schema} data={data} />);

    expect(element).toBeTruthy();
    expect(element.find('KPI')).toHaveLength(2);
    expect(element.find('LineChart')).toHaveLength(1);
    expect(element.find('DataTable')).toHaveLength(1);
  });

  it('applies mutation and re-renders', () => {
    const twin = new DigitalTwin(initialSchema);
    const mutation = 'Δ~@K0.label:"Updated"';

    const ast = parse(tokenize(mutation));
    twin.apply(ast);

    const element = render(<LiquidAdapter schema={twin.schema} data={data} />);
    expect(element).toHaveTextContent('Updated');
  });
});
```

#### D.6.3 Conformance Tests

**From §B.3.3, all tests must pass:**

```typescript
const conformanceTests = [
  'renders all 13 core block types',
  'renders placeholder for unknown block type',
  'renders empty state for null data',
  'renders empty state for mismatched data shape',
  'does not throw on malformed binding',
  'does not throw on invalid signal reference',
  'completes within timeout for large data',
  'recovers from partial data fetch failure',
  'shows placeholder with reason for unsupported features',
  'maintains layout when some blocks fail',
  'provides fallback for entire schema failure',
  'handles signal with no subscribers',
  'handles signal emit during render',
  'does not deadlock on circular signal reference',
];

// All must pass
conformanceTests.forEach(test => {
  expect(runConformanceTest(adapter, test)).toBe('PASS');
});
```

---

### D.7 Documentation Requirements

#### D.7.1 Code Documentation

- **README.md:** Project overview, installation, quick start
- **API.md:** Full API reference (generated from JSDoc)
- **ARCHITECTURE.md:** System architecture, package relationships
- **CONTRIBUTING.md:** How to contribute, code style, PR process

#### D.7.2 Example Dashboards

Provide working examples for each archetype (§12.3):

```
examples/
├── overview-dashboard.ts        # KPIs + charts + table
├── time-series-dashboard.ts     # Line/area charts with date filter
├── comparison-dashboard.ts      # Comparison blocks + deltas
├── funnel-dashboard.ts          # Funnel visualization
├── hierarchical-dashboard.ts    # Nested metrics
├── distribution-dashboard.ts    # Pie + bar charts
└── correlation-dashboard.ts     # Scatter + heatmap
```

Each example includes:
- LiquidCode source
- Sample data
- Compiled schema (JSON)
- Rendered screenshot

#### D.7.3 Tutorial

Step-by-step tutorial covering:
1. Parse simple LiquidCode
2. Compile to schema
3. Render with React adapter
4. Add signals for interactivity
5. Apply mutations
6. Extend with custom block type

---

### D.8 Deliverables

#### D.8.1 Code Repository

**GitHub repository:** `liquidcode/liquidcode-reference`

**Structure:**
```
liquidcode-reference/
├── packages/               # Monorepo (pnpm workspaces)
├── examples/               # Example dashboards
├── docs/                   # Documentation
├── .github/
│   └── workflows/
│       ├── test.yml        # CI: run tests
│       ├── lint.yml        # CI: linting
│       └── publish.yml     # CI: npm publish
├── package.json
├── tsconfig.json
├── README.md
└── LICENSE
```

**Published to npm:**
- `@liquidcode/schema`
- `@liquidcode/parser`
- `@liquidcode/compiler`
- `@liquidcode/addressing`
- `@liquidcode/binding`
- `@liquidcode/signals`
- `@liquidcode/state`
- `@liquidcode/adapter-react`

#### D.8.2 Documentation Site

**Hosted at:** `https://liquidcode.dev/reference`

**Sections:**
- Getting Started
- API Reference (auto-generated)
- Examples
- Architecture
- Conformance Tests

**Technology:** Docusaurus or similar

#### D.8.3 Release Artifacts

**For each release (semver):**
- Source code (GitHub release)
- npm packages (all 8 packages)
- Documentation site update
- Release notes (changelog)

---

### D.9 Timeline & Milestones

#### D.9.1 Phase 1: Core (Weeks 1-6)

**Deliverables:**
- [ ] Schema package with Zod validation
- [ ] Parser package with full grammar
- [ ] Compiler package (AST → schema)
- [ ] Addressing package
- [ ] Unit tests (≥80% coverage)

**Acceptance:** All unit tests pass, schemas validate correctly

---

#### D.9.2 Phase 2: Systems (Weeks 7-10)

**Deliverables:**
- [ ] Binding package (basic type matching)
- [ ] Signals package (with URL persistence)
- [ ] State package (Digital Twin + history)
- [ ] Integration tests

**Acceptance:** Full pipeline works (parse → compile → mutate)

---

#### D.9.3 Phase 3: Adapter (Weeks 11-14)

**Deliverables:**
- [ ] React adapter with all 13 block types
- [ ] Layout system (grid/stack)
- [ ] Signal runtime integration
- [ ] Conformance tests

**Acceptance:** All conformance tests pass

---

#### D.9.4 Phase 4: Polish (Weeks 15-16)

**Deliverables:**
- [ ] Documentation site
- [ ] Example dashboards
- [ ] Tutorial
- [ ] npm packages published
- [ ] Performance benchmarks

**Acceptance:** All deliverables complete, documentation reviewed

---

### D.10 Maintenance & Evolution

#### D.10.1 Versioning

**Use semantic versioning (semver):**
- **Major:** Breaking changes to API or schema format
- **Minor:** New features, backward compatible
- **Patch:** Bug fixes only

**Version alignment:**
- Reference implementation v2.x implements LiquidCode Spec v2.0
- v3.x will implement Spec v3.0 (when available)

#### D.10.2 Deprecation Policy

**For breaking changes:**
1. Announce in release notes
2. Provide migration guide
3. Maintain old version for 6 months
4. Publish deprecated warning in code
5. Remove in next major version

#### D.10.3 Community Contributions

**Accept contributions for:**
- Bug fixes
- Performance improvements
- Additional test cases
- Documentation improvements
- Example dashboards

**Do NOT accept contributions for:**
- Spec changes (those go to spec repo)
- Architectural changes (discuss first in issues)
- Optional components (Discovery, Cache, LLM) - these should be separate packages

---

### D.11 Relationship to Spec

The reference implementation is **normative for implementation details** where the spec is ambiguous or incomplete.

**Decision hierarchy:**
1. LiquidCode Spec v2 (normative)
2. Reference implementation (normative for gaps)
3. Other implementations (informative)

**Example:**
- Spec says: "Parse LiquidCode to AST" (high-level)
- Spec gap: Exact tokenization rules undefined
- Reference impl: Defines specific tokenization state machine
- Other impls: SHOULD match reference impl tokenization (or document differences)

**Update process:**
- If reference impl finds spec ambiguity → file issue on spec repo
- If spec is updated → update reference impl to match
- Reference impl should never diverge from spec intentionally

---

### D.12 Known Limitations

The reference implementation explicitly does NOT include:

#### D.12.1 Discovery Engine (§12)

**Reason:** Requires ML models, embedding infrastructure, significant complexity

**Alternative:** Implementers should manually specify archetypes or use production Discovery Engine implementations (when available)

#### D.12.2 Fragment Cache (§14)

**Reason:** Requires Redis/vector DB, external dependencies, production infrastructure

**Alternative:** All schemas generated fresh (no caching)

#### D.12.3 Tiered Resolution (§13)

**Reason:** Depends on cache + LLM integration

**Alternative:** Direct compilation only (no resolution tiers)

#### D.12.4 LLM Integration (§13.4, Appendix C)

**Reason:** Requires LLM API keys, variable costs, prompt engineering (see Gap 1)

**Alternative:** Manually write LiquidCode, use examples from spec

#### D.12.5 Layout Constraint Solver (§11.11)

**Reason:** Complex constraint solving, adapter-specific optimizations

**Alternative:** Basic grid/stack layout only, simple responsive rules

**Impact:** Reference implementation is a **compiler/runtime**, not a full **generation system**. It demonstrates LiquidCode → Rendered UI, but not Intent → LiquidCode.

---

### D.13 Success Criteria

The reference implementation is successful if:

1. **Validates spec:** Proves the spec is implementable and complete (for deterministic components)
2. **Enables interop:** Other implementations can compare behavior against reference
3. **Accelerates development:** Implementers can study and adapt reference code
4. **Passes all tests:** Unit, integration, and conformance tests all pass
5. **Meets quality bar:** Type-safe, well-documented, <100KB bundle, ≥80% coverage

**Final acceptance test:**
```typescript
// Given valid LiquidCode
const liquidCode = '#overview;G2x2;K$revenue,L$date$revenue';

// And matching data
const data = { revenue: 12345, date: [...], /* etc */ };

// When compiled and rendered
const schema = compile(parse(tokenize(liquidCode)));
const element = render(<LiquidAdapter schema={schema} data={data} />);

// Then output is valid and complete
expect(schema).toMatchSchema(LiquidSchemaSchema);
expect(element).toBeTruthy();
expect(element).toMatchSnapshot();
```

If this test passes for all spec examples, the reference implementation is complete.
```

## Verification Checklist
- [x] Change addresses the identified issue
- [x] No new inconsistencies introduced
- [x] Cross-references remain valid
- [x] Interface signatures unchanged (or documented)
- [x] Normative language (MUST/SHOULD/MAY) consistent

## Side Effects
- [ ] None
- [x] New appendix references should be added to Table of Contents (§TOC)
- [x] Cross-reference from Appendix C (Implementation Guide) to Appendix D
- [x] Cross-reference from §17 (Compilation Pipeline) to Appendix D as example implementation

## Dependencies
- [ ] No dependencies on other issues
- [x] References Implementation Guide (Appendix C / ISS-136)
- [x] References conformance tests (§B.3.3 / will be expanded in ISS-139)
- [x] References all core spec sections (§5-§18, Appendix B)
- [ ] Blocks: None

## Confidence
**HIGH** - This reference implementation specification clearly defines scope, requirements, deliverables, and limitations. It focuses on deterministic components that can be objectively tested, explicitly excludes stochastic/infrastructure-dependent components, and provides concrete acceptance criteria. The phased timeline (16 weeks) aligns with Appendix C implementation guide estimates.
