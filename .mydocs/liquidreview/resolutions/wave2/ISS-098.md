# Resolution: ISS-098

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Binding to Non-Existent Field After Schema Change
**Severity:** significant
**Target:** SPEC
**Section:** §9 Binding System, §20 Versioning & Migration, §16.2 Operation History

## Resolution

### Original Content

From §9.1:
```typescript
interface DataBinding {
  source: string;
  fields: FieldBinding[];
  aggregate?: AggregateSpec;
  groupBy?: string[];
  filter?: FilterCondition[];
  sort?: SortSpec[];
  limit?: number;
}
```

From §19.1:
```
| Binding error | Field not in data | Placeholder + warning |
```

**No specification for:**
- Detecting stale bindings after schema evolution
- Validating bindings on schema change
- Migration strategies for field renames/removals
- Distinguishing between temporary missing data vs structural schema change

### Replacement Content

**Add new section §9.5 Binding Validation and Schema Evolution**

#### 9.5 Binding Validation and Schema Evolution

When data schemas evolve, existing bindings may reference fields that no longer exist or have changed type. The engine MUST detect and handle these cases.

**9.5.1 Schema Change Events**

Trigger binding validation when:
```typescript
enum SchemaChangeEvent {
  INITIAL_LOAD = 'initial_load',           // First time connecting to data
  SCHEMA_REFRESH = 'schema_refresh',       // Explicit schema refresh request
  FIELD_ERROR = 'field_error',             // Runtime binding error detected
  DATA_SOURCE_CHANGE = 'data_source_change', // Different data source connected
}
```

**9.5.2 Binding Validation Algorithm**

```typescript
interface BindingValidationResult {
  valid: boolean;
  issues: BindingIssue[];
  autoRepairs: BindingRepair[];
  confidence: number;           // 0-1 for auto-repairs
}

interface BindingIssue {
  blockUid: string;
  fieldBinding: FieldBinding;
  issueType: 'missing_field' | 'type_mismatch' | 'invalid_transform';
  severity: 'error' | 'warning';
  message: string;
  suggestions?: FieldSuggestion[];
}

interface FieldSuggestion {
  field: string;
  confidence: number;           // 0-1
  reason: 'name_similarity' | 'type_match' | 'semantic_match' | 'position_match';
}

interface BindingRepair {
  blockUid: string;
  oldFieldBinding: FieldBinding;
  newFieldBinding: FieldBinding;
  confidence: number;
  reasoning: string;
}

function validateBindings(
  schema: LiquidSchema,
  dataFingerprint: DataFingerprint,
  event: SchemaChangeEvent
): BindingValidationResult {
  const issues: BindingIssue[] = [];
  const autoRepairs: BindingRepair[] = [];

  for (const block of schema.blocks) {
    if (!block.binding) continue;

    for (const fieldBinding of block.binding.fields) {
      const field = dataFingerprint.getField(fieldBinding.field);

      // Check field exists
      if (!field) {
        const suggestions = suggestAlternativeFields(
          fieldBinding.field,
          dataFingerprint,
          fieldBinding.target
        );

        issues.push({
          blockUid: block.uid,
          fieldBinding,
          issueType: 'missing_field',
          severity: 'error',
          message: `Field '${fieldBinding.field}' not found in data source`,
          suggestions,
        });

        // Auto-repair if high confidence suggestion exists
        if (suggestions.length > 0 && suggestions[0].confidence > 0.85) {
          autoRepairs.push({
            blockUid: block.uid,
            oldFieldBinding: fieldBinding,
            newFieldBinding: {
              ...fieldBinding,
              field: suggestions[0].field,
            },
            confidence: suggestions[0].confidence,
            reasoning: `High-confidence match: ${suggestions[0].reason}`,
          });
        }
      }
      // Check type compatibility
      else if (!isTypeCompatible(fieldBinding.target, field.type)) {
        issues.push({
          blockUid: block.uid,
          fieldBinding,
          issueType: 'type_mismatch',
          severity: 'warning',
          message: `Field '${fieldBinding.field}' type ${field.type} incompatible with slot ${fieldBinding.target}`,
        });
      }
    }
  }

  return {
    valid: issues.filter(i => i.severity === 'error').length === 0,
    issues,
    autoRepairs,
    confidence: calculateRepairConfidence(autoRepairs),
  };
}
```

**9.5.3 Field Suggestion Algorithm**

```typescript
function suggestAlternativeFields(
  missingField: string,
  dataFingerprint: DataFingerprint,
  targetSlot: BindingSlot
): FieldSuggestion[] {
  const suggestions: FieldSuggestion[] = [];

  for (const availableField of dataFingerprint.fields) {
    let score = 0;
    const reasons: string[] = [];

    // Name similarity (Levenshtein distance)
    const nameSimilarity = calculateSimilarity(missingField, availableField.name);
    if (nameSimilarity > 0.7) {
      score += 0.4 * nameSimilarity;
      reasons.push('name_similarity');
    }

    // Type compatibility with target slot
    if (isTypeCompatible(targetSlot, availableField.type)) {
      score += 0.3;
      reasons.push('type_match');
    }

    // Semantic similarity (word embeddings if available)
    const semanticSimilarity = calculateSemanticSimilarity(
      missingField,
      availableField.name
    );
    if (semanticSimilarity > 0.8) {
      score += 0.2 * semanticSimilarity;
      reasons.push('semantic_match');
    }

    // Position match (same column index in schema)
    const oldPosition = dataFingerprint.getHistoricalPosition(missingField);
    if (oldPosition && oldPosition === availableField.position) {
      score += 0.1;
      reasons.push('position_match');
    }

    if (score > 0.5) {
      suggestions.push({
        field: availableField.name,
        confidence: score,
        reason: reasons[0] as any,
      });
    }
  }

  return suggestions.sort((a, b) => b.confidence - a.confidence);
}
```

**9.5.4 Handling Strategies**

| Confidence | Strategy | User Experience |
|------------|----------|-----------------|
| ≥ 0.9 | Auto-repair silently | Log repair, user sees working interface |
| 0.7 - 0.9 | Auto-repair with notification | "Updated binding: revenue → total_revenue" |
| 0.5 - 0.7 | Prompt for confirmation | "Field 'revenue' missing. Use 'total_revenue'?" |
| < 0.5 | Show placeholder with manual fix UI | Block shows repair interface |

**9.5.5 Migration Metadata**

Track schema changes for better suggestions:

```typescript
interface DataSourceMetadata {
  schemaHistory: SchemaSnapshot[];
  fieldMappings?: FieldMapping[];        // Known renames
  lastValidated: string;                 // ISO 8601
}

interface SchemaSnapshot {
  timestamp: string;
  fingerprint: DataFingerprint;
  changes?: SchemaChange[];
}

interface SchemaChange {
  type: 'field_added' | 'field_removed' | 'field_renamed' | 'type_changed';
  field: string;
  newField?: string;                     // For renames
  timestamp: string;
}

interface FieldMapping {
  oldField: string;
  newField: string;
  confidence: number;
  source: 'auto' | 'user_confirmed';
}
```

**9.5.6 Validation Triggers**

```typescript
// On schema change
dataSource.on('schema_changed', (newFingerprint) => {
  const result = validateBindings(currentSchema, newFingerprint, 'SCHEMA_REFRESH');

  if (result.autoRepairs.length > 0 && result.confidence > 0.85) {
    // Apply high-confidence repairs automatically
    applyBindingRepairs(result.autoRepairs);
    notifyUser({ type: 'info', message: `Updated ${result.autoRepairs.length} bindings` });
  } else if (result.issues.length > 0) {
    // Show repair UI
    showBindingRepairDialog(result);
  }
});

// On initial load
engine.compile(liquidCode, {
  data: dataSource,
  validateBindings: true,               // Always validate on first render
});

// On render error
adapter.on('binding_error', (blockUid, field) => {
  // Trigger validation for specific block
  const result = validateBindings(schema, dataFingerprint, 'FIELD_ERROR');
  // ... handle
});
```

**9.5.7 Graceful Degradation**

When bindings cannot be repaired:

```typescript
interface BindingFallback {
  mode: 'placeholder' | 'empty_state' | 'remove_block';
  showRepairUI: boolean;
  message: string;
}

// Block renders with repair interface
function renderBlockWithBindingError(
  block: Block,
  issue: BindingIssue
): RenderOutput {
  return {
    type: 'placeholder',
    content: {
      icon: 'warning',
      title: 'Data Binding Issue',
      message: issue.message,
      actions: [
        { label: 'Fix Binding', onClick: () => showBindingEditor(block) },
        { label: 'Remove Block', onClick: () => removeBlock(block.uid) },
      ],
      suggestions: issue.suggestions?.map(s => ({
        label: `Use '${s.field}' instead? (${Math.round(s.confidence * 100)}% match)`,
        onClick: () => repairBinding(block, s.field),
      })),
    },
  };
}
```

**Add to §16.2 Operation History:**

```typescript
interface AppliedOperation {
  operation: Operation;
  timestamp: number;
  inverse: Operation;
  beforeHash: string;
  afterHash: string;
  bindingRepairs?: BindingRepair[];      // NEW: track auto-repairs
}
```

**Add to Appendix B Hardening Checklist:**
- [ ] Binding validation runs on schema change events
- [ ] High-confidence repairs (>0.85) auto-apply with notification
- [ ] Low-confidence issues show repair UI with suggestions
- [ ] Schema history tracked for better migration suggestions
- [ ] Blocks with unresolvable bindings render as actionable placeholders

## Verification Checklist
- [x] Edge case fully specified (stale bindings after schema change)
- [x] Behavior deterministic (validation algorithm + confidence thresholds)
- [x] Error handling defined (4-tier handling strategy + graceful degradation)
- [x] Examples provided where helpful (validation result structure, repair UI)

## Confidence
**HIGH** - This resolution:
1. Defines comprehensive validation triggers and algorithms
2. Provides multi-strategy handling based on confidence levels
3. Includes suggestion system with multiple signals (name, type, semantic, position)
4. Specifies graceful degradation with actionable user feedback
5. Adds schema history tracking for intelligent migrations
6. Integrates with existing error handling and operation history systems
