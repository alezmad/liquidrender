# ISS-120: Adapter Interface Expansion

**Issue Type:** Evolution Risk
**Category:** Extensibility and Evolution
**Priority:** Medium
**Affects:** Adapter Interface Contract (Section 18)

---

## Problem Statement

The current `LiquidAdapter` interface is minimal and focused on core rendering:

```typescript
interface LiquidAdapter<T> {
  render(schema: LiquidSchema, data: any): T;
  renderBlock(block: Block, data: any): T;
  supports(blockType: BlockType): boolean;
  renderPlaceholder(block: Block, reason: string): T;
  createSignalRuntime(registry: SignalRegistry): SignalRuntime;
  readonly metadata: AdapterMetadata;
}
```

Future requirements will demand additional capabilities:

| Capability | Why Needed | Example |
|-----------|-----------|---------|
| **Accessibility** | WCAG compliance, screen readers | ARIA attributes, keyboard nav |
| **Performance** | Large datasets, mobile devices | Virtual scrolling, lazy loading |
| **Advanced Layout** | Constraint-based layouts | iOS Auto Layout, Android ConstraintLayout |
| **Animation** | Smooth transitions | Block add/remove animations |
| **Theming** | Dark mode, custom themes | CSS variables, styled components |
| **Offline Support** | PWA requirements | Service workers, cache |

**Problem:** Adding these as **required methods breaks all existing adapters.**

### Example Breaking Change

```typescript
// V3.0 adds required method (BREAKING!)
interface LiquidAdapter<T> {
  // ... existing methods

  // NEW REQUIRED METHOD
  renderAccessible(schema: LiquidSchema, data: any, a11yOptions): T;
}

// Result: All v2.x adapters now broken!
const reactAdapter: LiquidAdapter<ReactElement> = {
  // ❌ Missing renderAccessible() - TypeScript error
};
```

---

## Resolution

### Strategy: Capability-Based Architecture

Use **optional capability interfaces** instead of expanding the core interface.

### Implementation

#### 1. Core Interface (Stable)

Keep core interface minimal and stable:

```typescript
interface LiquidAdapter<T> {
  // CORE METHODS (required, never change)
  render(schema: LiquidSchema, data: any): T;
  supports(blockType: BlockType): boolean;
  metadata: AdapterMetadata;

  // CAPABILITIES (optional, extensible)
  capabilities?: AdapterCapabilities<T>;
}
```

#### 2. Capability Interfaces

```typescript
interface AdapterCapabilities<T> {
  // Accessibility (optional)
  accessibility?: AccessibilityCapability<T>;

  // Performance (optional)
  performance?: PerformanceCapability<T>;

  // Layout (optional)
  layout?: LayoutCapability<T>;

  // Animation (optional)
  animation?: AnimationCapability<T>;

  // Theming (optional)
  theming?: ThemingCapability<T>;

  // Offline (optional)
  offline?: OfflineCapability<T>;

  // Future capabilities can be added without breaking changes
  [key: string]: any;
}
```

#### 3. Accessibility Capability

```typescript
interface AccessibilityCapability<T> {
  // Version of a11y support
  version: string;  // "1.0.0"

  // Render with accessibility enhancements
  renderAccessible(
    schema: LiquidSchema,
    data: any,
    options: A11yOptions
  ): T;

  // Validate accessibility
  validateA11y(schema: LiquidSchema): A11yValidation;

  // Supported features
  supports: {
    ariaAttributes: boolean;
    keyboardNav: boolean;
    screenReader: boolean;
    colorContrast: boolean;
    focusManagement: boolean;
  };
}

interface A11yOptions {
  level: 'A' | 'AA' | 'AAA';  // WCAG level
  enhanceContrast?: boolean;
  announceChanges?: boolean;
  customARIA?: Record<string, string>;
}

interface A11yValidation {
  compliant: boolean;
  level: 'A' | 'AA' | 'AAA' | 'none';
  issues: A11yIssue[];
}
```

#### 4. Performance Capability

```typescript
interface PerformanceCapability<T> {
  version: string;

  // Optimize for large datasets
  renderOptimized(
    schema: LiquidSchema,
    data: any,
    options: PerformanceOptions
  ): T;

  // Profiling
  profile(schema: LiquidSchema, data: any): PerformanceMetrics;

  // Supported optimizations
  supports: {
    virtualScrolling: boolean;
    lazyLoading: boolean;
    memoization: boolean;
    webWorkers: boolean;
    streaming: boolean;
  };
}

interface PerformanceOptions {
  virtualScrolling?: {
    enabled: boolean;
    itemHeight: number;
    overscan: number;
  };
  lazyLoading?: {
    enabled: boolean;
    threshold: number;  // Pixels before viewport
  };
  maxRenderTime?: number;  // Budget in ms
}

interface PerformanceMetrics {
  renderTime: number;      // ms
  memoryUsage: number;     // bytes
  domNodes: number;
  rerenders: number;
  bottlenecks: string[];
}
```

#### 5. Layout Capability

```typescript
interface LayoutCapability<T> {
  version: string;

  // Custom layout strategy
  resolveLayout(
    blocks: Block[],
    context: SlotContext,
    options?: LayoutOptions
  ): LayoutResolution;

  // Supported layout engines
  supports: {
    grid: boolean;
    flexbox: boolean;
    constraints: boolean;     // iOS Auto Layout style
    manual: boolean;
    responsive: boolean;
  };
}

interface LayoutOptions {
  strategy: 'grid' | 'flex' | 'constraints' | 'manual';
  responsive?: ResponsiveConfig;
  constraints?: ConstraintSpec[];
}

interface ConstraintSpec {
  type: 'equal-width' | 'equal-height' | 'aspect-ratio' | 'alignment';
  blocks: string[];  // UIDs
  value?: number;
}
```

#### 6. Example: React Adapter with Capabilities

```typescript
const reactAdapter: LiquidAdapter<ReactElement> = {
  // Core methods (required)
  render(schema, data) {
    return <LiquidInterface schema={schema} data={data} />;
  },

  supports(blockType) {
    return SUPPORTED_BLOCKS.includes(blockType);
  },

  metadata: {
    name: 'react',
    version: '2.0.0',
    platform: 'web',
    supportedSchemaVersions: ['2.x']
  },

  // Capabilities (optional)
  capabilities: {
    // Accessibility support
    accessibility: {
      version: '1.0.0',

      renderAccessible(schema, data, options) {
        return (
          <LiquidInterface
            schema={schema}
            data={data}
            a11y={options}
          />
        );
      },

      validateA11y(schema) {
        return validateWCAG(schema);
      },

      supports: {
        ariaAttributes: true,
        keyboardNav: true,
        screenReader: true,
        colorContrast: true,
        focusManagement: true
      }
    },

    // Performance support
    performance: {
      version: '1.0.0',

      renderOptimized(schema, data, options) {
        return (
          <LiquidInterface
            schema={schema}
            data={data}
            virtualScrolling={options.virtualScrolling}
            lazyLoading={options.lazyLoading}
          />
        );
      },

      profile(schema, data) {
        return performanceProfiler.measure(() =>
          this.render(schema, data)
        );
      },

      supports: {
        virtualScrolling: true,
        lazyLoading: true,
        memoization: true,
        webWorkers: false,
        streaming: true
      }
    },

    // No layout capability (use default)
    // No animation capability (not implemented)
  }
};
```

#### 7. Capability Detection

```typescript
// Engine checks capabilities before using them
class LiquidEngine {
  render(schema: LiquidSchema, data: any, options: RenderOptions = {}): any {
    const adapter = this.adapter;

    // Check for accessibility capability
    if (options.a11y && adapter.capabilities?.accessibility) {
      return adapter.capabilities.accessibility.renderAccessible(
        schema,
        data,
        options.a11y
      );
    }

    // Check for performance capability
    if (options.performance && adapter.capabilities?.performance) {
      return adapter.capabilities.performance.renderOptimized(
        schema,
        data,
        options.performance
      );
    }

    // Fallback to core render
    return adapter.render(schema, data);
  }

  // Capability inquiry
  hasCapability(name: string): boolean {
    return this.adapter.capabilities?.[name] !== undefined;
  }

  getCapability<T>(name: string): T | undefined {
    return this.adapter.capabilities?.[name] as T | undefined;
  }
}
```

#### 8. Capability Versioning

```typescript
interface CapabilityVersion {
  capability: string;
  version: string;
  breaking: boolean;
}

// Example: Accessibility v2.0 adds new features
interface AccessibilityCapabilityV2 extends AccessibilityCapability {
  // New in v2.0
  renderARIA(schema: LiquidSchema): ARIATree;
  exportA11yReport(schema: LiquidSchema): A11yReport;

  // Breaking: signature change
  renderAccessible(
    schema: LiquidSchema,
    data: any,
    options: A11yOptionsV2  // ← Changed
  ): T;
}

// Adapters declare capability versions
capabilities: {
  accessibility: {
    version: '2.0.0',  // Implements v2 spec
    // ...
  }
}
```

---

## Migration Path

### Phase 1: Capability Infrastructure (v2.1)
- Add `capabilities` field to `LiquidAdapter`
- Define initial capability interfaces
- Update React adapter to use capabilities
- Document capability system

### Phase 2: Migrate Existing Features (v2.2)
- Move `createSignalRuntime` to capability (backward compat wrapper)
- Move `renderBlock` to capability
- Keep wrappers in core interface for compatibility

### Phase 3: New Capabilities (v2.3+)
- Accessibility capability (v2.3)
- Performance capability (v2.4)
- Layout capability (v2.5)
- Animation capability (v2.6)

### Phase 4: v3.0 Cleanup
- Core interface is minimal (3 methods)
- All extensions are capabilities
- Full backward compatibility maintained

---

## Benefits

### Non-Breaking Evolution
Adding new capabilities doesn't break existing adapters.

### Adapter Flexibility
Adapters implement only capabilities they support.

### Gradual Adoption
Community adapters can add capabilities over time.

### Clear Feature Matrix
Users can query which capabilities are available.

### Version Independence
Capability versions evolve independently from adapter version.

---

## Testing Requirements

```typescript
describe('Adapter Capabilities', () => {
  it('uses accessibility capability if available', () => {
    const adapter = createAdapterWithA11y();
    const result = engine.render(schema, data, { a11y: { level: 'AA' } });

    expect(adapter.capabilities.accessibility.renderAccessible)
      .toHaveBeenCalled();
  });

  it('falls back to core render if capability missing', () => {
    const adapter = createBasicAdapter();  // No a11y capability
    const result = engine.render(schema, data, { a11y: { level: 'AA' } });

    expect(adapter.render).toHaveBeenCalled();  // Fallback
  });

  it('detects capability presence', () => {
    expect(engine.hasCapability('accessibility')).toBe(true);
    expect(engine.hasCapability('animation')).toBe(false);
  });

  it('validates capability versions', () => {
    const a11y = engine.getCapability<AccessibilityCapability>('accessibility');
    expect(a11y.version).toBe('1.0.0');
    expect(a11y.supports.screenReader).toBe(true);
  });
});
```

---

## Documentation Requirements

### Adapter Development Guide

**Title:** "Implementing Adapter Capabilities"

**Contents:**
1. Core vs capabilities architecture
2. When to implement capabilities
3. Capability interfaces reference
4. Versioning capabilities
5. Testing capabilities
6. Publishing capabilities

### Capability Reference

**Title:** "LiquidCode Adapter Capabilities"

**Contents:**
- Accessibility Capability (v1.0)
- Performance Capability (v1.0)
- Layout Capability (v1.0)
- Animation Capability (v1.0)
- Future capabilities roadmap

---

## Implementation Checklist

### Phase 1 (v2.1)
- [ ] Add `capabilities` field to `LiquidAdapter`
- [ ] Define `AdapterCapabilities` interface
- [ ] Define core capability interfaces
- [ ] Update engine capability detection
- [ ] Document capability system

### Phase 2 (v2.2-2.6)
- [ ] Implement accessibility capability
- [ ] Implement performance capability
- [ ] Implement layout capability
- [ ] Implement animation capability
- [ ] Migrate React adapter
- [ ] Community adapter examples

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** High (changes adapter architecture)
**Breaking Changes:** None (additive, backward compatible)
**Version Target:** v2.1

**Rationale Integration:** The adapter interface must evolve, but breaking existing adapters would fragment the ecosystem. Capability-based architecture enables unlimited extension while preserving compatibility. This is inspired by web standards (feature detection) and browser APIs (capability queries).

**Philosophy:** **Adapters are diverse.** Some target web (React), some mobile (React Native), some desktop (Qt). Not all platforms support all features. Capability-based design respects platform differences while enabling progressive enhancement.
