# ISS-116: Transform Function Extensibility

**Issue Type:** Extension Gap
**Category:** Extensibility and Evolution
**Priority:** Medium
**Affects:** Binding System (Section 9), LiquidExpr (Appendix B.4)

---

## Problem Statement

LiquidExpr defines a fixed set of built-in transform functions:
- **Math:** `round`, `floor`, `ceil`, `abs`, `min`, `max`
- **String:** `upper`, `lower`, `trim`, `len`, `substr`, `concat`
- **Date:** `year`, `month`, `day`, `format`, `diff`
- **Format:** `currency`, `percent`, `number`, `date`
- **Logic:** `if`, `coalesce`, `default`
- **Aggregate:** `sum`, `avg`, `count`, `first`, `last`

Domain-specific transforms cannot be expressed:

### Example Needs

**Medical:**
```typescript
// ICD-10 code lookup
transform: 'icd10Lookup($diagnosisCode)'  // ❌ Not available

// BMI calculation
transform: 'calculateBMI($weight, $height)'  // ❌ Not available

// Age from date of birth
transform: 'ageFromDOB($dob)'  // ❌ Not available
```

**Financial:**
```typescript
// Fiscal quarter
transform: 'fiscalQuarter($date)'  // ❌ Not available

// Internal rate of return
transform: 'irr($cashflows)'  // ❌ Not available

// Sharpe ratio
transform: 'sharpeRatio($returns, $riskFreeRate)'  // ❌ Not available
```

**Scientific:**
```typescript
// SI prefix formatting
transform: 'siPrefix($number)'  // 1000 → "1k", 1000000 → "1M"

// Gaussian smoothing
transform: 'gaussianSmooth($array, $sigma)'
```

### Current Workaround

Put this logic in adapter's data transformation layer. **Problems:**
- Not portable (tied to specific adapter)
- Not cacheable (outside schema)
- Not declarative (imperative code)
- Not inspectable (can't query transform logic)

---

## Resolution

### Extension Mechanism

Add a **Transform Function Registry** allowing domain-specific pure functions while maintaining LiquidExpr's security guarantees.

### Implementation

#### 1. Function Definition Interface

```typescript
interface LiquidExprFunction {
  // Identification
  name: string;                        // 'fiscalQuarter'
  version: string;                     // Semver

  // Type signature
  arity: number | 'variadic';          // Parameter count
  returnType: LiquidExprType;          // Return value type
  paramTypes: LiquidExprType[];        // Parameter types

  // Execution (MUST be pure)
  execute(...args: any[]): any;

  // Security constraints
  pure: boolean;                       // MUST be true
  deterministic: boolean;              // Same input → same output
  bounded: boolean;                    // Execution time bounded
  maxExecutionTime?: number;           // Max ms (default: 100)

  // Metadata
  description: string;
  category: 'math' | 'string' | 'date' | 'format' | 'logic' | 'domain' | 'custom';
  examples: FunctionExample[];
  documentation?: string;
}

type LiquidExprType =
  | 'string' | 'number' | 'boolean' | 'date' | 'null'
  | 'array' | 'object' | 'any';

interface FunctionExample {
  expression: string;
  input: Record<string, any>;
  output: any;
  description?: string;
}
```

#### 2. Function Registry

```typescript
interface TransformFunctionRegistry {
  register(fn: LiquidExprFunction): void;
  get(name: string): LiquidExprFunction | undefined;
  has(name: string): boolean;
  list(): string[];
  listByCategory(category: string): string[];
  unregister(name: string): void;
}

class TransformFunctionRegistry {
  private functions: Map<string, LiquidExprFunction> = new Map();

  register(fn: LiquidExprFunction): void {
    // Validate security constraints
    if (!fn.pure) {
      throw new SecurityError('Transform functions must be pure (no side effects)');
    }

    if (!fn.deterministic) {
      throw new SecurityError('Transform functions must be deterministic');
    }

    if (!fn.bounded) {
      throw new SecurityError('Transform functions must have bounded execution time');
    }

    // Validate type signature
    if (fn.arity !== 'variadic' && fn.paramTypes.length !== fn.arity) {
      throw new TypeError(`Parameter types (${fn.paramTypes.length}) don't match arity (${fn.arity})`);
    }

    this.functions.set(fn.name, fn);
  }

  execute(name: string, args: any[]): any {
    const fn = this.functions.get(name);
    if (!fn) {
      throw new EvaluationError(`Unknown function: ${name}`);
    }

    // Validate arity
    if (fn.arity !== 'variadic' && args.length !== fn.arity) {
      throw new EvaluationError(`${name} expects ${fn.arity} arguments, got ${args.length}`);
    }

    // Execute with timeout
    const maxTime = fn.maxExecutionTime || 100;
    const result = executeWithTimeout(() => fn.execute(...args), maxTime);

    return result;
  }
}
```

#### 3. Example: Fiscal Quarter Function

```typescript
engine.transforms.registerFunction({
  name: 'fiscalQuarter',
  version: '1.0.0',
  arity: 1,
  returnType: 'string',
  paramTypes: ['date'],

  execute(date: Date): string {
    const month = date.getMonth();  // 0-11
    const quarter = Math.floor(month / 3) + 1;
    return `Q${quarter}`;
  },

  pure: true,
  deterministic: true,
  bounded: true,
  maxExecutionTime: 10,  // Very fast

  description: 'Convert date to fiscal quarter (Q1-Q4)',
  category: 'date',
  examples: [
    {
      expression: 'fiscalQuarter($date)',
      input: { date: new Date('2025-01-15') },
      output: 'Q1',
      description: 'January is Q1'
    },
    {
      expression: 'fiscalQuarter($date)',
      input: { date: new Date('2025-07-15') },
      output: 'Q3',
      description: 'July is Q3'
    }
  ]
});
```

#### 4. Example: ICD-10 Lookup (with external data)

```typescript
// ICD-10 lookup requires external data - handle carefully
engine.transforms.registerFunction({
  name: 'icd10Lookup',
  version: '1.0.0',
  arity: 1,
  returnType: 'string',
  paramTypes: ['string'],

  execute(code: string): string {
    // Lookup in preloaded, immutable table
    // NOT making network requests (that would violate pure/bounded)
    const description = ICD10_TABLE[code];
    return description || code;  // Fallback to code if not found
  },

  pure: true,        // Yes - no side effects
  deterministic: true,  // Yes - same input → same output (table is immutable)
  bounded: true,     // Yes - O(1) hash lookup
  maxExecutionTime: 10,

  description: 'Look up ICD-10 diagnosis code description',
  category: 'domain',
  examples: [
    {
      expression: 'icd10Lookup($code)',
      input: { code: 'E11.9' },
      output: 'Type 2 diabetes mellitus without complications',
    }
  ]
});

// Table loaded at registration time (NOT at execution time)
const ICD10_TABLE: Record<string, string> = {
  'E11.9': 'Type 2 diabetes mellitus without complications',
  'I10': 'Essential (primary) hypertension',
  // ... thousands more
};
```

#### 5. Example: SI Prefix Formatting

```typescript
engine.transforms.registerFunction({
  name: 'siPrefix',
  version: '1.0.0',
  arity: 1,
  returnType: 'string',
  paramTypes: ['number'],

  execute(value: number): string {
    const abs = Math.abs(value);
    const sign = value < 0 ? '-' : '';

    if (abs >= 1e12) return `${sign}${(abs / 1e12).toFixed(1)}T`;
    if (abs >= 1e9) return `${sign}${(abs / 1e9).toFixed(1)}B`;
    if (abs >= 1e6) return `${sign}${(abs / 1e6).toFixed(1)}M`;
    if (abs >= 1e3) return `${sign}${(abs / 1e3).toFixed(1)}k`;

    return value.toString();
  },

  pure: true,
  deterministic: true,
  bounded: true,

  description: 'Format number with SI prefix (k, M, B, T)',
  category: 'format',
  examples: [
    { expression: 'siPrefix($value)', input: { value: 1500 }, output: '1.5k' },
    { expression: 'siPrefix($value)', input: { value: 2500000 }, output: '2.5M' },
    { expression: 'siPrefix($value)', input: { value: 1200000000 }, output: '1.2B' }
  ]
});
```

#### 6. Security Validation

```typescript
function executeWithTimeout<T>(fn: () => T, timeout: number): T {
  const start = Date.now();
  let result: T;

  // Execute in try-catch to enforce totality
  try {
    result = fn();

    const elapsed = Date.now() - start;
    if (elapsed > timeout) {
      throw new TimeoutError(`Function exceeded ${timeout}ms limit (took ${elapsed}ms)`);
    }

    return result;
  } catch (error) {
    // LiquidExpr never throws - return null on error
    console.warn(`Transform function error: ${error.message}`);
    return null as T;
  }
}

// Sandbox validation at registration
function validatePurity(fn: LiquidExprFunction): void {
  // Static analysis checks (if possible):
  // - No access to global variables
  // - No network calls
  // - No file system access
  // - No random numbers
  // - No Date.now() (non-deterministic)

  // Runtime checks:
  // - Execute with test inputs
  // - Verify same inputs produce same outputs
  // - Verify no side effects observable

  const testInputs = generateTestInputs(fn.paramTypes);
  const result1 = fn.execute(...testInputs);
  const result2 = fn.execute(...testInputs);

  if (!deepEqual(result1, result2)) {
    throw new SecurityError(`Function ${fn.name} is not deterministic`);
  }
}
```

---

## Migration Path

### Phase 1: Registry Infrastructure (v2.1)
- Implement function registry
- Register existing built-ins
- Add security validation
- No user-visible changes

### Phase 2: Public API (v2.2)
- Open registration API
- Document function authoring
- Security guidelines

### Phase 3: Domain Packages (v2.3+)
- Publish official domain packages:
  - `@liquidcode/medical-transforms` (ICD-10, SNOMED, FHIR)
  - `@liquidcode/financial-transforms` (fiscal periods, IRR, ratios)
  - `@liquidcode/scientific-transforms` (SI units, statistics)
- Community packages encouraged

---

## Security Constraints

### Required Properties

All custom functions MUST be:

1. **Pure** - No side effects
   - ❌ Cannot modify global state
   - ❌ Cannot make network requests
   - ❌ Cannot write to file system
   - ❌ Cannot access DOM/window

2. **Deterministic** - Same input → same output
   - ❌ Cannot use `Math.random()`
   - ❌ Cannot use `Date.now()`
   - ❌ Cannot access user-specific state
   - ✅ Can use preloaded immutable lookup tables

3. **Total** - Never throws exceptions
   - ✅ Returns `null` on error
   - ✅ Handles edge cases gracefully

4. **Bounded** - Execution time limited
   - ✅ Default 100ms timeout
   - ✅ Configurable per function
   - ❌ Cannot have infinite loops

### Validation Process

```typescript
// At registration
registry.register(fn);  // Validates constraints

// At runtime
const result = registry.execute('myFn', args);  // Enforces timeout, catches errors
```

---

## Benefits

### Domain Extensibility
Medical, financial, scientific domains get proper transform functions.

### Portability
Transform logic in schema, not adapter-specific code.

### Cacheability
Schemas with transforms are fully self-contained and cacheable.

### Type Safety
Function signatures enforce type checking at compile time.

### Security
Sandboxed execution prevents code injection attacks.

---

## Testing Requirements

```typescript
describe('Transform Function Registry', () => {
  it('registers custom functions', () => {
    registry.registerFunction({
      name: 'double',
      arity: 1,
      execute: (x) => x * 2,
      pure: true,
      deterministic: true,
      bounded: true
    });

    expect(registry.has('double')).toBe(true);
  });

  it('executes custom functions', () => {
    const result = registry.execute('fiscalQuarter', [new Date('2025-03-15')]);
    expect(result).toBe('Q1');
  });

  it('rejects impure functions', () => {
    expect(() => {
      registry.registerFunction({
        name: 'impure',
        execute: () => Date.now(),  // Non-deterministic!
        pure: true,  // Lying
        deterministic: false
      });
    }).toThrow(SecurityError);
  });

  it('enforces execution timeout', () => {
    registry.registerFunction({
      name: 'slow',
      execute: () => { while(true) {} },  // Infinite loop
      maxExecutionTime: 100
    });

    expect(() => {
      registry.execute('slow', []);
    }).toThrow(TimeoutError);
  });
});
```

---

## Documentation Requirements

### User Guide

**Contents:**
1. Available transform functions
2. Function signatures and examples
3. Domain-specific function packages
4. Installation and usage

### Developer Guide

**Contents:**
1. When to create custom functions
2. Security requirements (pure, deterministic, total, bounded)
3. Registration API
4. Testing custom functions
5. Publishing function packages
6. Preloading lookup tables

---

## Implementation Checklist

- [ ] Define `LiquidExprFunction` interface
- [ ] Implement `TransformFunctionRegistry`
- [ ] Add security validation (purity, determinism)
- [ ] Implement timeout enforcement
- [ ] Migrate built-ins to registry
- [ ] Public registration API
- [ ] Write security guidelines
- [ ] Create domain package examples
- [ ] Document function authoring
- [ ] Integration tests

---

## Resolution Status

**Status:** Resolved
**Specification Impact:** Medium (extends LiquidExpr)
**Breaking Changes:** None (additive)
**Version Target:** v2.1 (infrastructure), v2.2 (public API)

**Rationale Integration:** Domain-specific transforms are essential for domain-specific blocks. Without extensibility, users resort to adapter-specific workarounds, breaking LiquidCode's portability guarantee. Sandboxed function registration maintains security while enabling flexibility.
