# Resolution: ISS-011

## Status: ✅ RESOLVED

## Issue Summary
**Title:** LiquidExpr - Function Implementation
**Severity:** significant
**Target:** SPEC
**Section:** Appendix B.4 (Safe Transform DSL)

## Problem
Section B.4 defines LiquidExpr grammar and lists built-in functions (B.4.3) but lacks:
1. Precise function signatures (parameter types, return types)
2. Evaluation semantics for each function
3. Type coercion rules
4. Edge case behavior (null handling, type mismatches)
5. Evaluation algorithm for complex expressions

## Resolution

### Original Content (Lines 2137-2146)
```markdown
#### B.4.3 Built-in Functions

| Category | Functions |
|----------|-----------|
| Math | `round(n)`, `floor(n)`, `ceil(n)`, `abs(n)`, `min(a,b)`, `max(a,b)` |
| String | `upper(s)`, `lower(s)`, `trim(s)`, `len(s)`, `substr(s,i,n)`, `concat(a,b)` |
| Date | `year(d)`, `month(d)`, `day(d)`, `format(d,fmt)`, `diff(d1,d2,unit)` |
| Format | `currency(n,sym)`, `percent(n)`, `number(n,dec)`, `date(d,fmt)` |
| Logic | `if(cond,then,else)`, `coalesce(a,b)`, `default(v,def)` |
| Aggregate | `sum(arr)`, `avg(arr)`, `count(arr)`, `first(arr)`, `last(arr)` |
```

### Replacement Content

```markdown
#### B.4.3 Built-in Functions

LiquidExpr provides a minimal, total function library. All functions have well-defined behavior for all inputs (no exceptions).

**Function Signature Notation:**

```
functionName(param1: Type, param2: Type, ...): ReturnType
```

**Type System:**

```typescript
type LiquidValue =
  | number
  | string
  | boolean
  | Date
  | null
  | LiquidValue[];  // Arrays

type LiquidType = 'number' | 'string' | 'boolean' | 'date' | 'null' | 'array';
```

#### B.4.3.1 Math Functions

| Function | Signature | Behavior | Null Handling |
|----------|-----------|----------|---------------|
| `round(n)` | `(n: number): number` | Round to nearest integer | `round(null)` → `null` |
| `floor(n)` | `(n: number): number` | Round down to integer | `floor(null)` → `null` |
| `ceil(n)` | `(n: number): number` | Round up to integer | `ceil(null)` → `null` |
| `abs(n)` | `(n: number): number` | Absolute value | `abs(null)` → `null` |
| `min(a, b)` | `(a: number, b: number): number` | Minimum of two numbers | `min(null, 5)` → `5`, `min(null, null)` → `null` |
| `max(a, b)` | `(a: number, b: number): number` | Maximum of two numbers | `max(null, 5)` → `5`, `max(null, null)` → `null` |

**Implementation:**

```typescript
const MathFunctions = {
  round: (n: LiquidValue): LiquidValue => {
    if (n === null || typeof n !== 'number') return null;
    return Math.round(n);
  },

  floor: (n: LiquidValue): LiquidValue => {
    if (n === null || typeof n !== 'number') return null;
    return Math.floor(n);
  },

  ceil: (n: LiquidValue): LiquidValue => {
    if (n === null || typeof n !== 'number') return null;
    return Math.ceil(n);
  },

  abs: (n: LiquidValue): LiquidValue => {
    if (n === null || typeof n !== 'number') return null;
    return Math.abs(n);
  },

  min: (a: LiquidValue, b: LiquidValue): LiquidValue => {
    if (typeof a === 'number' && typeof b === 'number') return Math.min(a, b);
    if (typeof a === 'number' && b === null) return a;
    if (a === null && typeof b === 'number') return b;
    return null;
  },

  max: (a: LiquidValue, b: LiquidValue): LiquidValue => {
    if (typeof a === 'number' && typeof b === 'number') return Math.max(a, b);
    if (typeof a === 'number' && b === null) return a;
    if (a === null && typeof b === 'number') return b;
    return null;
  }
};
```

#### B.4.3.2 String Functions

| Function | Signature | Behavior | Null Handling |
|----------|-----------|----------|---------------|
| `upper(s)` | `(s: string): string` | Convert to uppercase | `upper(null)` → `null` |
| `lower(s)` | `(s: string): string` | Convert to lowercase | `lower(null)` → `null` |
| `trim(s)` | `(s: string): string` | Remove leading/trailing whitespace | `trim(null)` → `null` |
| `len(s)` | `(s: string): number` | String length | `len(null)` → `null` |
| `substr(s, i, n)` | `(s: string, i: number, n: number): string` | Substring from index i, length n | `substr(null, 0, 5)` → `null` |
| `concat(a, b)` | `(a: string, b: string): string` | Concatenate strings | `concat("a", null)` → `"a"`, `concat(null, null)` → `""` |

**Implementation:**

```typescript
const StringFunctions = {
  upper: (s: LiquidValue): LiquidValue => {
    if (s === null || typeof s !== 'string') return null;
    return s.toUpperCase();
  },

  lower: (s: LiquidValue): LiquidValue => {
    if (s === null || typeof s !== 'string') return null;
    return s.toLowerCase();
  },

  trim: (s: LiquidValue): LiquidValue => {
    if (s === null || typeof s !== 'string') return null;
    return s.trim();
  },

  len: (s: LiquidValue): LiquidValue => {
    if (s === null || typeof s !== 'string') return null;
    return s.length;
  },

  substr: (s: LiquidValue, i: LiquidValue, n: LiquidValue): LiquidValue => {
    if (typeof s !== 'string' || typeof i !== 'number' || typeof n !== 'number') return null;
    return s.substring(i, i + n);
  },

  concat: (a: LiquidValue, b: LiquidValue): LiquidValue => {
    const aStr = a === null ? '' : String(a);
    const bStr = b === null ? '' : String(b);
    return aStr + bStr;
  }
};
```

#### B.4.3.3 Date Functions

| Function | Signature | Behavior | Null Handling |
|----------|-----------|----------|---------------|
| `year(d)` | `(d: Date): number` | Extract year | `year(null)` → `null` |
| `month(d)` | `(d: Date): number` | Extract month (1-12) | `month(null)` → `null` |
| `day(d)` | `(d: Date): number` | Extract day of month (1-31) | `day(null)` → `null` |
| `format(d, fmt)` | `(d: Date, fmt: string): string` | Format date (ISO8601 or "YYYY-MM-DD") | `format(null, "YYYY")` → `null` |
| `diff(d1, d2, unit)` | `(d1: Date, d2: Date, unit: string): number` | Difference in units ("days", "hours", "minutes") | `diff(null, d2, "days")` → `null` |

**Implementation:**

```typescript
const DateFunctions = {
  year: (d: LiquidValue): LiquidValue => {
    if (!(d instanceof Date)) return null;
    return d.getFullYear();
  },

  month: (d: LiquidValue): LiquidValue => {
    if (!(d instanceof Date)) return null;
    return d.getMonth() + 1;  // 1-indexed
  },

  day: (d: LiquidValue): LiquidValue => {
    if (!(d instanceof Date)) return null;
    return d.getDate();
  },

  format: (d: LiquidValue, fmt: LiquidValue): LiquidValue => {
    if (!(d instanceof Date) || typeof fmt !== 'string') return null;

    // Simple format string support
    if (fmt === 'YYYY-MM-DD') {
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    // Default: ISO8601
    return d.toISOString();
  },

  diff: (d1: LiquidValue, d2: LiquidValue, unit: LiquidValue): LiquidValue => {
    if (!(d1 instanceof Date) || !(d2 instanceof Date) || typeof unit !== 'string') return null;

    const msPerUnit = {
      'days': 24 * 60 * 60 * 1000,
      'hours': 60 * 60 * 1000,
      'minutes': 60 * 1000,
      'seconds': 1000
    };

    const divisor = msPerUnit[unit as keyof typeof msPerUnit];
    if (!divisor) return null;

    return Math.floor((d1.getTime() - d2.getTime()) / divisor);
  }
};
```

#### B.4.3.4 Format Functions

| Function | Signature | Behavior | Null Handling |
|----------|-----------|----------|---------------|
| `currency(n, sym)` | `(n: number, sym: string): string` | Format as currency (e.g., "$1,234.56") | `currency(null, "$")` → `null` |
| `percent(n)` | `(n: number): string` | Format as percentage (e.g., "45.6%") | `percent(null)` → `null` |
| `number(n, dec)` | `(n: number, dec: number): string` | Format number with decimals | `number(null, 2)` → `null` |
| `date(d, fmt)` | `(d: Date, fmt: string): string` | Alias for `format(d, fmt)` | `date(null, "YYYY")` → `null` |

**Implementation:**

```typescript
const FormatFunctions = {
  currency: (n: LiquidValue, sym: LiquidValue): LiquidValue => {
    if (typeof n !== 'number' || typeof sym !== 'string') return null;

    const formatted = n.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });

    return `${sym}${formatted}`;
  },

  percent: (n: LiquidValue): LiquidValue => {
    if (typeof n !== 'number') return null;
    return `${(n * 100).toFixed(1)}%`;
  },

  number: (n: LiquidValue, dec: LiquidValue): LiquidValue => {
    if (typeof n !== 'number' || typeof dec !== 'number') return null;
    return n.toFixed(dec);
  },

  date: DateFunctions.format  // Alias
};
```

#### B.4.3.5 Logic Functions

| Function | Signature | Behavior | Null Handling |
|----------|-----------|----------|---------------|
| `if(cond, then, else)` | `(cond: boolean, then: T, else: T): T` | Conditional expression | `if(null, a, b)` → `b` (null is falsy) |
| `coalesce(a, b)` | `(a: T, b: T): T` | Return first non-null | `coalesce(null, 5)` → `5`, `coalesce(null, null)` → `null` |
| `default(v, def)` | `(v: T, def: T): T` | Alias for `coalesce` | Same as `coalesce` |

**Implementation:**

```typescript
const LogicFunctions = {
  if: (cond: LiquidValue, thenVal: LiquidValue, elseVal: LiquidValue): LiquidValue => {
    // Truthiness: null, false, 0, "" are falsy
    const isTruthy = cond !== null && cond !== false && cond !== 0 && cond !== '';
    return isTruthy ? thenVal : elseVal;
  },

  coalesce: (a: LiquidValue, b: LiquidValue): LiquidValue => {
    return a !== null ? a : b;
  },

  default: (v: LiquidValue, def: LiquidValue): LiquidValue => {
    return v !== null ? v : def;
  }
};
```

#### B.4.3.6 Aggregate Functions

| Function | Signature | Behavior | Null Handling |
|----------|-----------|----------|---------------|
| `sum(arr)` | `(arr: number[]): number` | Sum of array | `sum([1, null, 3])` → `4` (nulls ignored) |
| `avg(arr)` | `(arr: number[]): number` | Average of array | `avg([1, null, 3])` → `2` (nulls ignored) |
| `count(arr)` | `(arr: any[]): number` | Count non-null elements | `count([1, null, 3])` → `2` |
| `first(arr)` | `(arr: T[]): T` | First element | `first([])` → `null`, `first([1, 2])` → `1` |
| `last(arr)` | `(arr: T[]): T` | Last element | `last([])` → `null`, `last([1, 2])` → `2` |

**Implementation:**

```typescript
const AggregateFunctions = {
  sum: (arr: LiquidValue): LiquidValue => {
    if (!Array.isArray(arr)) return null;

    const numbers = arr.filter(v => typeof v === 'number') as number[];
    return numbers.length > 0 ? numbers.reduce((a, b) => a + b, 0) : null;
  },

  avg: (arr: LiquidValue): LiquidValue => {
    if (!Array.isArray(arr)) return null;

    const numbers = arr.filter(v => typeof v === 'number') as number[];
    return numbers.length > 0 ? numbers.reduce((a, b) => a + b, 0) / numbers.length : null;
  },

  count: (arr: LiquidValue): LiquidValue => {
    if (!Array.isArray(arr)) return null;
    return arr.filter(v => v !== null).length;
  },

  first: (arr: LiquidValue): LiquidValue => {
    if (!Array.isArray(arr) || arr.length === 0) return null;
    return arr[0];
  },

  last: (arr: LiquidValue): LiquidValue => {
    if (!Array.isArray(arr) || arr.length === 0) return null;
    return arr[arr.length - 1];
  }
};
```

#### B.4.3.7 Type Coercion Rules

LiquidExpr uses **explicit coercion** — functions expect specific types and return `null` for type mismatches.

| Operation | Inputs | Result |
|-----------|--------|--------|
| `round("123")` | String instead of number | `null` (no implicit coercion) |
| `upper(123)` | Number instead of string | `null` |
| `concat(123, 456)` | Numbers as strings | `"123456"` (concat coerces to string) |
| `if("text", a, b)` | String as boolean | `a` (non-empty string is truthy) |

**Explicit Coercion Functions (optional extension):**

```typescript
const CoercionFunctions = {
  toNumber: (v: LiquidValue): LiquidValue => {
    if (typeof v === 'number') return v;
    if (typeof v === 'string') {
      const n = parseFloat(v);
      return isNaN(n) ? null : n;
    }
    if (typeof v === 'boolean') return v ? 1 : 0;
    return null;
  },

  toString: (v: LiquidValue): LiquidValue => {
    if (v === null) return null;
    return String(v);
  },

  toBoolean: (v: LiquidValue): LiquidValue => {
    if (typeof v === 'boolean') return v;
    // Truthiness rules
    return v !== null && v !== false && v !== 0 && v !== '';
  }
};
```

#### B.4.3.8 Expression Evaluation Algorithm

```typescript
interface EvaluationContext {
  variables: Record<string, LiquidValue>;  // $fieldName → value
  functions: Record<string, Function>;     // Built-in + custom
  maxDepth: number;                        // Recursion limit (default: 50)
  maxOps: number;                          // Operation count limit (default: 1000)
}

let operationCount = 0;

function evaluate(
  expr: Expression,
  context: EvaluationContext,
  depth = 0
): LiquidValue {
  // Safety: depth limit
  if (depth > context.maxDepth) {
    throw new Error('Expression depth exceeded');
  }

  // Safety: operation limit
  if (++operationCount > context.maxOps) {
    throw new Error('Expression complexity exceeded');
  }

  switch (expr.type) {
    case 'literal':
      return expr.value;

    case 'identifier': {
      // Variable reference: $fieldName
      const varName = expr.name.substring(1);  // Remove $
      return context.variables[varName] ?? null;
    }

    case 'call': {
      // Function call: functionName(arg1, arg2, ...)
      const func = context.functions[expr.name];
      if (!func) return null;  // Unknown function

      const args = expr.arguments.map(arg => evaluate(arg, context, depth + 1));
      return func(...args);
    }

    case 'binary': {
      // Binary operation: a + b, a && b, etc.
      const left = evaluate(expr.left, context, depth + 1);
      const right = evaluate(expr.right, context, depth + 1);
      return evaluateBinaryOp(expr.operator, left, right);
    }

    case 'conditional': {
      // Ternary: cond ? then : else
      const cond = evaluate(expr.condition, context, depth + 1);
      const isTruthy = cond !== null && cond !== false && cond !== 0 && cond !== '';
      return isTruthy
        ? evaluate(expr.thenBranch, context, depth + 1)
        : evaluate(expr.elseBranch, context, depth + 1);
    }

    case 'access': {
      // Property access: obj.field
      const obj = evaluate(expr.object, context, depth + 1);
      if (obj === null || typeof obj !== 'object') return null;
      return (obj as any)[expr.property] ?? null;
    }

    default:
      return null;
  }
}

function evaluateBinaryOp(
  operator: string,
  left: LiquidValue,
  right: LiquidValue
): LiquidValue {
  // Null propagation: most ops return null if either operand is null
  if (left === null || right === null) {
    // Except logical ops (treat null as false)
    if (operator === '&&') return false;
    if (operator === '||') return left ?? right;
    return null;
  }

  switch (operator) {
    case '+':
      return typeof left === 'number' && typeof right === 'number' ? left + right : null;
    case '-':
      return typeof left === 'number' && typeof right === 'number' ? left - right : null;
    case '*':
      return typeof left === 'number' && typeof right === 'number' ? left * right : null;
    case '/':
      return typeof left === 'number' && typeof right === 'number'
        ? (right !== 0 ? left / right : null)  // Division by zero → null
        : null;
    case '%':
      return typeof left === 'number' && typeof right === 'number' ? left % right : null;
    case '==':
      return left === right;
    case '!=':
      return left !== right;
    case '<':
      return typeof left === 'number' && typeof right === 'number' ? left < right : null;
    case '>':
      return typeof left === 'number' && typeof right === 'number' ? left > right : null;
    case '<=':
      return typeof left === 'number' && typeof right === 'number' ? left <= right : null;
    case '>=':
      return typeof left === 'number' && typeof right === 'number' ? left >= right : null;
    case '&&':
      return left && right;
    case '||':
      return left || right;
    default:
      return null;
  }
}
```

#### B.4.3.9 Complete Function Registry

```typescript
const LIQUID_EXPR_FUNCTIONS: Record<string, Function> = {
  // Math
  ...MathFunctions,

  // String
  ...StringFunctions,

  // Date
  ...DateFunctions,

  // Format
  ...FormatFunctions,

  // Logic
  ...LogicFunctions,

  // Aggregate
  ...AggregateFunctions,

  // Coercion (optional)
  // ...CoercionFunctions
};

// Usage
function evaluateLiquidExpr(
  exprString: string,
  variables: Record<string, LiquidValue>
): LiquidValue {
  operationCount = 0;  // Reset counter

  const ast = parseLiquidExpr(exprString);  // Parse to AST (see B.4.2)
  const context: EvaluationContext = {
    variables,
    functions: LIQUID_EXPR_FUNCTIONS,
    maxDepth: 50,
    maxOps: 1000
  };

  try {
    return evaluate(ast, context);
  } catch (error) {
    // Totality: never throw to caller
    console.error('LiquidExpr evaluation error:', error);
    return null;
  }
}
```

#### B.4.3.10 Examples

**Example 1: Currency formatting**

```typescript
const expr = 'currency($revenue, "$")';
const result = evaluateLiquidExpr(expr, { revenue: 1234.56 });
// result === "$1,234.56"
```

**Example 2: Conditional with null handling**

```typescript
const expr = 'if($value >= 0, "positive", "negative")';
const result = evaluateLiquidExpr(expr, { value: null });
// result === "negative" (null is falsy)
```

**Example 3: Complex expression**

```typescript
const expr = 'currency(round($revenue * 1.1), "$")';
const result = evaluateLiquidExpr(expr, { revenue: 1234.56 });
// Step 1: $revenue * 1.1 = 1358.016
// Step 2: round(1358.016) = 1358
// Step 3: currency(1358, "$") = "$1,358.00"
// result === "$1,358.00"
```

**Example 4: Null coalescing**

```typescript
const expr = 'coalesce($primary, $fallback, "default")';
const result = evaluateLiquidExpr(expr, { primary: null, fallback: 42 });
// result === 42
```
```

## Verification Checklist
- [x] Change addresses the identified issue (complete function implementations)
- [x] No new inconsistencies introduced (extends existing grammar)
- [x] Cross-references remain valid (references B.4.1, B.4.2, B.4.4)
- [x] Interface signatures unchanged (adds implementations, not new interfaces)
- [x] Normative language consistent (defines totality and null handling)

## Confidence
**HIGH** - This resolution:
1. Provides complete, executable implementations for all functions
2. Defines precise type signatures and null handling semantics
3. Includes evaluation algorithm with safety limits
4. Maintains totality guarantee (no exceptions to caller)
5. Enables safe, deterministic transform evaluation across all platforms
