# ISS-111: Additional Minor Cases (Consolidated)

**Category:** Minor Edge Cases
**Priority:** Low
**Status:** Resolved

## Issue

Consolidate remaining minor edge cases that don't warrant individual issues but need resolution.

## Resolution

### 1. Empty Block Slots

**Issue:** What happens when a layout block (grid, stack) has empty slots?

**Resolution:**
```typescript
// Empty slots are valid and render as empty space
interface SlotMap {
  [slotName: string]: Block[];  // Can be empty array
}

// Adapter behavior
function renderSlot(slot: Block[]): RenderOutput {
  if (slot.length === 0) {
    return <div className="empty-slot" />;  // Preserve layout space
  }
  return slot.map(renderBlock);
}
```

**Specification:** No change needed. Empty slots are semantically valid.

---

### 2. Duplicate Block UIDs

**Issue:** What if the LLM or mutation generates duplicate UIDs?

**Resolution:**
```typescript
// Validation catches duplicates
function validateUniqueUIDs(schema: LiquidSchema): ValidationError[] {
  const uids = new Set<string>();
  const duplicates: string[] = [];

  for (const block of schema.blocks) {
    if (uids.has(block.uid)) {
      duplicates.push(block.uid);
    }
    uids.add(block.uid);
  }

  if (duplicates.length > 0) {
    throw new ValidationError(
      `Duplicate UIDs detected: ${duplicates.join(', ')}. ` +
      `UIDs must be unique within a schema.`
    );
  }

  return [];
}

// Auto-repair during compilation (permissive mode)
function repairDuplicateUIDs(schema: LiquidSchema): LiquidSchema {
  const uids = new Set<string>();
  return {
    ...schema,
    blocks: schema.blocks.map(block => {
      if (uids.has(block.uid)) {
        const newUid = generateUID();
        console.warn(`Repaired duplicate UID ${block.uid} → ${newUid}`);
        return { ...block, uid: newUid };
      }
      uids.add(block.uid);
      return block;
    })
  };
}
```

---

### 3. Signal Circular Dependencies

**Issue:** What if signals create cycles? (A emits to B, B emits to A)

**Resolution:**
```typescript
// Detect cycles during validation
function detectSignalCycles(schema: LiquidSchema): string[] {
  const graph = buildSignalGraph(schema);
  const cycles = findCycles(graph);

  if (cycles.length > 0) {
    return cycles.map(cycle =>
      `Signal cycle detected: ${cycle.join(' → ')}`
    );
  }
  return [];
}

// Runtime: break cycles with emission guards
class SignalRuntime {
  private emissionStack: string[] = [];

  emit(signal: string, value: any): void {
    if (this.emissionStack.includes(signal)) {
      console.error(`Signal cycle prevented: ${signal} already emitting`);
      return;  // Break cycle
    }

    this.emissionStack.push(signal);
    try {
      this.propagate(signal, value);
    } finally {
      this.emissionStack.pop();
    }
  }
}
```

**Specification impact:** Add to §10.7 (Signal Inheritance) or new §10.8 (Signal Validation).

---

### 4. Missing Data Source

**Issue:** Schema binds to data source that doesn't exist in provided data.

**Resolution:**
```typescript
// Validation before render
function validateDataSources(
  schema: LiquidSchema,
  data: Record<string, any>
): ValidationError[] {
  const errors: ValidationError[] = [];
  const sources = new Set(Object.keys(data));

  for (const block of schema.blocks) {
    if (block.binding && !sources.has(block.binding.source)) {
      errors.push({
        blockUid: block.uid,
        message: `Data source "${block.binding.source}" not found`,
        availableSources: [...sources]
      });
    }
  }

  return errors;
}

// Render behavior: show empty state
function renderWithMissingData(block: Block): RenderOutput {
  return (
    <div className="missing-data-state">
      <Icon name="database-x" />
      <p>Data source not available: {block.binding?.source}</p>
    </div>
  );
}
```

---

### 5. Grid Position Out of Bounds

**Issue:** Grid layout is 2x2 but block specifies position `@[3,3]`.

**Resolution:**
```typescript
// Validation during compilation
function validateGridPositions(layout: GridLayout, blocks: Block[]): void {
  const { columns, rows } = layout;

  for (const block of blocks) {
    const position = extractGridPosition(block);  // From address or layout
    if (!position) continue;

    if (position.row >= rows || position.column >= columns) {
      throw new ValidationError(
        `Block ${block.uid} position [${position.row},${position.column}] ` +
        `exceeds grid bounds [${rows},${columns}]`
      );
    }
  }
}

// Auto-repair: expand grid or wrap position
function repairGridPosition(
  position: [number, number],
  gridSize: [number, number]
): [number, number] {
  const [row, col] = position;
  const [rows, cols] = gridSize;

  return [
    Math.min(row, rows - 1),
    Math.min(col, cols - 1)
  ];
}
```

---

### 6. Null or Undefined in Required Fields

**Issue:** Block has `null` for required field like `type`.

**Resolution:**
```typescript
// Zod schema prevents this at validation
const BlockSchema = z.object({
  uid: z.string().min(1),
  type: z.string().min(1),  // Cannot be null/undefined
  // ... other fields
}).strict();

// If somehow null passes through, fail fast
function ensureBlockType(block: Block): BlockType {
  if (!block.type) {
    throw new Error(`Block ${block.uid} missing required field: type`);
  }
  return block.type;
}
```

---

### 7. LiquidExpr Execution Timeout

**Issue:** What if a transform expression takes too long to execute?

**Resolution:**
```typescript
const LIQUIDEXPR_TIMEOUT_MS = 100;  // Max 100ms per expression

function evaluateLiquidExpr(
  expr: string,
  context: Record<string, any>
): any {
  const start = Date.now();
  let operations = 0;

  const result = evaluate(expr, context, () => {
    operations++;
    if (operations > 1000) {
      throw new Error('Expression exceeded operation limit');
    }
    if (Date.now() - start > LIQUIDEXPR_TIMEOUT_MS) {
      throw new Error('Expression exceeded timeout');
    }
  });

  return result;
}

// On timeout, return null (safe fallback per B.4.4)
function safeEvaluate(expr: string, context: any): any {
  try {
    return evaluateLiquidExpr(expr, context);
  } catch (error) {
    console.error(`LiquidExpr error: ${error.message}`);
    return null;  // Fallback value
  }
}
```

**Specification impact:** Add to §B.4.6 (Security Properties).

---

### 8. Adapter Render Timeout

**Issue:** Adapter hangs during rendering.

**Resolution:**
```typescript
// Enforce timeout at engine level
async function renderWithTimeout<T>(
  adapter: LiquidAdapter<T>,
  schema: LiquidSchema,
  data: any,
  timeout: number = 5000  // 5s default
): Promise<T> {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error('Render timeout')), timeout);
  });

  const renderPromise = Promise.resolve(adapter.render(schema, data));

  return Promise.race([renderPromise, timeoutPromise]);
}
```

**Specification impact:** Add to §18.1 (Adapter Interface) as requirement.

---

## Specification Impact

**New section §19.5 (Edge Case Handling):**

Document consolidated edge cases and their resolution strategies.

**Updates to existing sections:**
- §10.7: Signal cycle detection
- §18.1: Adapter timeout requirements
- §B.4.6: LiquidExpr timeout and operation limits
- §B.6.3: UID uniqueness validation

## Related Sections

- §17.1: Compilation Pipeline
- §18.1: Adapter Interface
- §19.1: Error Categories
- §B.4: Safe Transform DSL
- §B.6: Normative LiquidSchema Specification
