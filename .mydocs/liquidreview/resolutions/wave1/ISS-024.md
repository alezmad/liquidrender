# Resolution: ISS-024

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Fragment Type Definition Missing
**Severity:** critical
**Target:** SPEC
**Section:** B.6.1

## Resolution

### Original Content
The specification references `CachedFragment` and `FragmentRef` types in multiple locations (§13.3, §14.2, §15.2, §B.5) but these interfaces are never formally defined in the normative type definitions section B.6.1.

**Referenced but undefined:**
- Line 1372: `fragment: CachedFragment;` in SemanticMatch interface
- Line 1411-1412: `get(key: CacheKey): Promise<CachedFragment | null>; set(key: CacheKey, fragment: CachedFragment, ttl?: number): Promise<void>;`
- Line 1455: `fragments: FragmentRef[];` in CompositionRule interface
- Lines 2215, 2246, 2282: Multiple coherence checking functions using `CachedFragment`

**Usage analysis:**
- From §14.1, fragments have five types: archetype, block, composition, polish, binding-template
- From B.5.2 and B.5.3: `fragment.blocks`, `fragment.signals` properties are accessed
- From §14.2: Fragments are stored/retrieved via cache keys with TTL
- From §13.3: Fragments can be adapted and have similarity scores
- From §15.2: Fragments can be referenced and combined

### Replacement Content

Add the following interfaces to section B.6.1, after the `SchemaMetadata` interface definition (around line 2480):

```typescript
/**
 * Fragment Cache Types
 * Fragments are reusable pieces of interface specifications stored for performance.
 */

type FragmentType = 'archetype' | 'block' | 'composition' | 'polish' | 'binding-template';

interface CachedFragment {
  // REQUIRED fields
  uid: string;                           // Fragment unique identifier (f_<random12>)
  type: FragmentType;                    // What kind of fragment
  createdAt: string;                     // ISO 8601 timestamp

  // OPTIONAL fields (based on fragment type)
  blocks?: Block[];                      // For block, composition, archetype types
  signals?: SignalRegistry;              // For fragments with signal definitions
  layout?: LayoutBlock;                  // For archetype and composition types
  bindingTemplate?: BindingTemplate;     // For binding-template type
  polish?: PolishSpec;                   // For polish type

  // Cache metadata
  cacheKey: CacheKey;                    // Key used for storage/retrieval
  ttl?: number;                          // Time-to-live in seconds
  hits?: number;                         // Usage count
  lastUsed?: string;                     // ISO 8601 timestamp

  // Provenance
  source: 'discovery' | 'llm' | 'user' | 'composition';
  confidence?: number;                   // 0-1 confidence score
  embedding?: number[];                  // Semantic embedding for search

  // Adaptation tracking
  adaptable?: boolean;                   // Whether fragment can be adapted
  adaptations?: AdaptationRecord[];      // History of adaptations applied
}

interface FragmentRef {
  fragmentId: string;                    // UID of referenced fragment
  position?: FragmentPosition;           // Where fragment should be placed
  adaptations?: Adaptation[];            // Transformations to apply
}

interface FragmentPosition {
  slot?: string;                         // Slot name in parent
  index?: number;                        // Position within slot
  gridCell?: [number, number];           // [row, col] for grid layouts
}

interface BindingTemplate {
  pattern: string;                       // Field name pattern (e.g., "*revenue*")
  slots: BindingSlotMapping[];           // Slot assignments
  aggregateDefault?: AggregateSpec;      // Default aggregation
  transformDefault?: string;             // Default LiquidExpr transform
}

interface BindingSlotMapping {
  slot: BindingSlot;
  fieldPattern: string;                  // Pattern to match source field
  required: boolean;
}

interface PolishSpec {
  blockType?: BlockType;                 // If specific to block type
  labels?: Record<string, string>;       // Label templates
  formatting?: Record<string, string>;   // Format strings
  icons?: Record<string, string>;        // Icon mappings
  colors?: Record<string, string>;       // Color schemes
}

interface Adaptation {
  type: 'binding' | 'layout' | 'signal' | 'label' | 'type';
  target: string;                        // What to adapt (path or selector)
  operation: 'replace' | 'modify' | 'add' | 'remove';
  value?: unknown;                       // New value (for replace/modify/add)
  reason?: string;                       // Why adaptation was needed
}

interface AdaptationRecord {
  appliedAt: string;                     // ISO 8601 timestamp
  adaptations: Adaptation[];
  resultingCoherence: number;            // Coherence score after adaptation
}

interface CacheKey {
  intentHash: string;                    // Normalized intent signature
  dataFingerprint: string;               // Schema signature
  archetypeHint?: string;                // If provided
  scope: 'interface' | 'block';
}

interface DataFingerprint {
  fields: FieldSignature[];
  rowCount?: number;
  schemaHash: string;                    // Hash of field types/names

  // Helper methods (implementation-dependent)
  hasField(fieldName: string): boolean;
  getField(fieldName: string): FieldSignature | undefined;
}

interface FieldSignature {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'date' | 'unknown';
  cardinality?: 'low' | 'medium' | 'high';  // Uniqueness estimate
  nullable?: boolean;
  primitive?: 'date' | 'currency' | 'count' | 'percentage' | 'category' | 'identifier';
}

// Supporting types for composition (§15.2)
interface IntentPattern {
  archetypeMatch?: string;               // Archetype name or pattern
  blockTypes?: BlockType[];              // Required block types
  signalTypes?: SignalType[];            // Required signal types
  minBlocks?: number;
  maxBlocks?: number;
}

interface LayoutRule {
  type: 'grid' | 'stack' | 'flow';
  columns?: number;
  rows?: number;
  inference?: 'auto' | 'explicit';
}

interface SignalWiring {
  auto?: boolean;                        // Enable auto-wiring
  explicit?: SignalConnection[];         // Explicit connections
}

interface SignalConnection {
  fromBlock: string;                     // Block UID or selector
  toBlock: string;                       // Block UID or selector
  signal: string;                        // Signal name
}

// Supporting types for coherence checking (§B.5)
interface CoherenceCheck {
  binding: BindingCoherence;
  signal: SignalCoherence;
  layout: LayoutCoherence;
  data: DataCoherence;
}

interface BindingCoherence {
  pass: boolean;
  missingFields: string[];
  typeMismatches: Array<{field: string, expected: string, actual: string}>;
}

interface SignalCoherence {
  pass: boolean;
  orphanSignals: string[];               // Received but not declared/emitted
  unmatchedEmissions: string[];          // Emitted but no receivers
}

interface LayoutCoherence {
  pass: boolean;
  overflowBlocks: string[];              // Blocks that don't fit layout
  conflictingRelationships: string[];    // Incompatible relationship specs
}

interface DataCoherence {
  pass: boolean;
  insufficientRows: boolean;             // Not enough data for visualization
  incompatibleAggregations: Array<{field: string, issue: string}>;
}

interface CoherenceResult {
  pass: boolean;
  confidence: number;                    // 0-1
  repairs: RepairSuggestion[];
  reason?: string;
}

interface RepairSuggestion {
  type: 'micro-llm' | 'add-signal' | 'rebind' | 'relayout';
  scope?: 'binding' | 'signal' | 'layout';
  issue?: string;
  signal?: string;                       // For add-signal repairs
  automated?: boolean;                   // Whether repair can be automated
}

interface CoherenceIssue {
  category: 'binding' | 'signal' | 'layout' | 'data';
  severity: 'error' | 'warning';
  description: string;
  blockId?: string;                      // Affected block UID
  fieldPath?: string;                    // JSON path to issue
}
```

## Verification Checklist
- [x] Interface covers all Fragment use cases from §14, §15, §B.5
- [x] Types are consistent with existing spec (Block, Signal, Layout, etc.)
- [x] CachedFragment supports all five fragment types from §14.1
- [x] FragmentRef enables composition as described in §15.2
- [x] Coherence checking types match usage in B.5.2 and B.5.3
- [x] DataFingerprint supports binding validation patterns
- [x] Supporting types (IntentPattern, LayoutRule, etc.) are defined
- [x] UID format specified consistently (f_<random12> for fragments)
- [x] All referenced but undefined types now have formal definitions

## Confidence
**HIGH** - This resolution is based on comprehensive analysis of:

1. **Direct usage patterns** - Examined all 8 locations where Fragment types are used
2. **Inferred properties** - Analyzed code examples in B.5.2/B.5.3 showing `fragment.blocks`, `fragment.signals` access
3. **Architectural constraints** - Fragment types align with §14.1 taxonomy and cache architecture
4. **Coherence requirements** - Supporting types match the coherence gate validation needs
5. **Composition semantics** - FragmentRef structure supports the composition engine described in §15

The definition is complete and internally consistent with the specification's architecture.
