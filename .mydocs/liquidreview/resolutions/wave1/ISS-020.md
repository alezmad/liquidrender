# ISS-020: Block Type Code Conflicts

**Issue Type:** Inconsistency
**Severity:** Medium
**Status:** Resolved
**Date:** 2025-12-21

---

## Problem Statement

Block type codes are inconsistent between two locations in the specification:

- **Location A (§6.2):** Defines single/double character codes for LiquidCode syntax
- **Location B (B.6.1):** Defines normative TypeScript type definitions

**Conflict:** The representation differs between the compact LiquidCode syntax codes and the full block type names in the schema definition.

---

## Analysis

### Location A: §6.2 Block Type Codes

**Purpose:** Compact codes for token-efficient LLM output

| Code | Block Type | Category |
|------|------------|----------|
| `K` | kpi | Atomic Data |
| `B` | bar-chart | Atomic Data |
| `L` | line-chart | Atomic Data |
| `P` | pie-chart | Atomic Data |
| `T` | data-table | Atomic Data |
| `G` | grid | Layout |
| `S` | stack | Layout |
| `X` | text | Atomic Data |
| `M` | metric-group | Composite |
| `C` | comparison | Atomic Data |
| `DF` | date-filter | Interactive |
| `SF` | select-filter | Interactive |
| `SI` | search-input | Interactive |

### Location B: B.6.1 Complete Type Definitions

**Purpose:** Normative schema definition for runtime validation

```typescript
type BlockType =
  | 'kpi' | 'bar-chart' | 'line-chart' | 'pie-chart' | 'data-table'
  | 'grid' | 'stack' | 'text' | 'metric-group' | 'comparison'
  | 'date-filter' | 'select-filter' | 'search-input'
  | `custom:${string}`;
```

### Root Cause

This is **not actually a conflict** but rather a **representation gap**. The issue is that:

1. **§6.2** defines the LiquidCode grammar (compact syntax) used by LLMs
2. **B.6.1** defines the LiquidSchema format (compiled output) used at runtime

These are two different layers:
- LiquidCode → uses compact codes (`K`, `B`, `L`, etc.)
- LiquidSchema → uses full names (`kpi`, `bar-chart`, `line-chart`, etc.)

The compiler translates between them.

---

## Resolution

### Authoritative Source

**B.6.1 is authoritative** for the following reason:

> Appendix B is explicitly titled "Hardening Specification" and states: "These are **normative requirements** for production-grade implementations."

The B.6.1 section provides the complete, normative schema that all implementations MUST conform to.

### Required Changes

**No changes to B.6.1** (already normative and complete).

**Clarification needed in §6.2** to make the relationship explicit.

#### Update §6.2

Add explanatory text to clarify the compilation relationship:

**Location:** After the table in §6.2, before §6.3

**Add the following paragraph:**

```markdown
**Note:** These single/double character codes are LiquidCode syntax shortcuts for token efficiency. The compiler translates them to full block type names in LiquidSchema. For example:

- LiquidCode: `K$revenue` → LiquidSchema: `{ type: 'kpi', binding: { fields: [{ target: 'value', field: 'revenue' }] } }`
- LiquidCode: `DF` → LiquidSchema: `{ type: 'date-filter' }`

The normative block type names are defined in B.6.1. These codes are purely for LLM output optimization.
```

---

## Validation

### Mapping Verification

All codes in §6.2 map correctly to types in B.6.1:

| Code (§6.2) | Type (B.6.1) | ✓ |
|-------------|--------------|---|
| K | kpi | ✓ |
| B | bar-chart | ✓ |
| L | line-chart | ✓ |
| P | pie-chart | ✓ |
| T | data-table | ✓ |
| G | grid | ✓ |
| S | stack | ✓ |
| X | text | ✓ |
| M | metric-group | ✓ |
| C | comparison | ✓ |
| DF | date-filter | ✓ |
| SF | select-filter | ✓ |
| SI | search-input | ✓ |

**All mappings valid.** No missing or extra types.

---

## Implementation Impact

### Compiler Requirements

The LiquidCode parser MUST maintain a bidirectional mapping:

```typescript
const BLOCK_TYPE_CODES: Record<string, BlockType> = {
  'K': 'kpi',
  'B': 'bar-chart',
  'L': 'line-chart',
  'P': 'pie-chart',
  'T': 'data-table',
  'G': 'grid',
  'S': 'stack',
  'X': 'text',
  'M': 'metric-group',
  'C': 'comparison',
  'DF': 'date-filter',
  'SF': 'select-filter',
  'SI': 'search-input',
};

const CODE_FROM_TYPE: Record<BlockType, string> = {
  'kpi': 'K',
  'bar-chart': 'B',
  'line-chart': 'L',
  'pie-chart': 'P',
  'data-table': 'T',
  'grid': 'G',
  'stack': 'S',
  'text': 'X',
  'metric-group': 'M',
  'comparison': 'C',
  'date-filter': 'DF',
  'select-filter': 'SF',
  'search-input': 'SI',
};
```

### Testing Requirements

Add conformance test:

```typescript
test('Block type codes compile to correct schema types', () => {
  const liquidCode = 'K$revenue';
  const schema = compile(liquidCode);
  expect(schema.blocks[0].type).toBe('kpi');
});

test('All §6.2 codes map to valid B.6.1 types', () => {
  for (const [code, type] of Object.entries(BLOCK_TYPE_CODES)) {
    expect(BlockTypeSchema.safeParse(type).success).toBe(true);
  }
});
```

---

## Documentation Updates

### File: LIQUIDCODE-SPEC-v2.md

**Section:** §6.2 Block Type Codes

**Change Type:** Clarification (non-breaking)

**Before:**
```markdown
### 6.2 Block Type Codes

Single/double character codes for common block types:

| Code | Block Type | Category |
|------|------------|----------|
[table continues...]
```

**After:**
```markdown
### 6.2 Block Type Codes

Single/double character codes for common block types:

| Code | Block Type | Category |
|------|------------|----------|
[table continues...]

**Note:** These single/double character codes are LiquidCode syntax shortcuts for token efficiency. The compiler translates them to full block type names in LiquidSchema. For example:

- LiquidCode: `K$revenue` → LiquidSchema: `{ type: 'kpi', binding: { fields: [{ target: 'value', field: 'revenue' }] } }`
- LiquidCode: `DF` → LiquidSchema: `{ type: 'date-filter' }`

The normative block type names are defined in B.6.1. These codes are purely for LLM output optimization.
```

---

## Checklist

- [x] Identified authoritative source (B.6.1)
- [x] Verified mapping completeness
- [x] Defined required clarification
- [x] Specified compiler requirements
- [x] Created conformance tests
- [x] Documented update location

---

## Related Issues

- None (first wave resolution)

---

## Conclusion

**Resolution:** This is not a true conflict but a representation gap between syntax layer (§6.2) and schema layer (B.6.1). The normative source is B.6.1. §6.2 requires a clarification note to make the compilation relationship explicit. No functional changes needed—only documentation enhancement.
