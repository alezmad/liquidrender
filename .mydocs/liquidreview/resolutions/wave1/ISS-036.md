# Resolution: ISS-036

## Status: ✅ RESOLVED

## Issue Summary
**Title:** Migration Interface Incomplete
**Severity:** critical
**Target:** SPEC
**Section:** §9.3, B.5.4

## Resolution

### Original Content (Lines 1760-1767)

**Section §20.3 (Lines 1760-1767):**
```typescript
interface Migration {
  from: string;    // "1.0"
  to: string;      // "2.0"
  migrate(schema: OldSchema): NewSchema;
}
```

**Section B.5.4 mentions migration but doesn't provide interface details.**

### Replacement Content

**Section §20.3 Complete Migration Specification:**

```typescript
/**
 * Migration Interface
 *
 * Provides transformation between LiquidSchema versions.
 * All migrations MUST be:
 * - Deterministic (same input → same output)
 * - Total (never throw for valid input schema)
 * - Documented (provide change log)
 */

interface Migration {
  // Version identification
  from: string;                      // Source version (e.g., "1.0")
  to: string;                        // Target version (e.g., "2.0")

  // Metadata
  id: string;                        // Unique migration ID
  description: string;               // Human-readable description
  breaking: boolean;                 // Whether migration is breaking

  // Core transformation
  migrate(schema: unknown): MigrationResult;

  // Validation
  canMigrate(schema: unknown): boolean;

  // Utilities
  getChangelog(): ChangelogEntry[];
  estimateComplexity(schema: unknown): MigrationComplexity;
}

interface MigrationResult {
  success: boolean;
  schema?: LiquidSchema;             // Migrated schema (if success)
  errors?: MigrationError[];         // Errors (if failure)
  warnings?: MigrationWarning[];     // Non-fatal issues
  metadata: MigrationMetadata;
}

interface MigrationError {
  path: string;                      // JSON path to problematic field
  code: string;                      // Error code
  message: string;                   // Human-readable message
  suggestion?: string;               // How to fix
}

interface MigrationWarning {
  path: string;
  message: string;
  impact: 'low' | 'medium' | 'high';
}

interface MigrationMetadata {
  migratedAt: string;                // ISO 8601 timestamp
  migrationId: string;
  fromVersion: string;
  toVersion: string;
  transformations: TransformationLog[];
}

interface TransformationLog {
  path: string;                      // What was changed
  type: 'added' | 'removed' | 'modified' | 'renamed';
  before?: unknown;
  after?: unknown;
  reason: string;
}

type MigrationComplexity = 'trivial' | 'simple' | 'moderate' | 'complex';

interface ChangelogEntry {
  field: string;
  change: 'added' | 'removed' | 'modified' | 'renamed' | 'deprecated';
  description: string;
  breaking: boolean;
}

/**
 * Migration Registry
 *
 * Manages all available migrations and finds migration paths.
 */

interface MigrationRegistry {
  // Register a migration
  register(migration: Migration): void;

  // Get migration between versions
  getMigration(from: string, to: string): Migration | null;

  // Find migration path (may require multiple steps)
  findMigrationPath(from: string, to: string): Migration[] | null;

  // Execute migration chain
  migrate(schema: unknown, targetVersion: string): MigrationResult;

  // Check if migration possible
  canMigrate(schema: unknown, targetVersion: string): boolean;

  // List all registered migrations
  listMigrations(): MigrationInfo[];
}

interface MigrationInfo {
  id: string;
  from: string;
  to: string;
  description: string;
  breaking: boolean;
}

/**
 * Example Implementation: v1.0 → v2.0
 */

class Migration_v1_to_v2 implements Migration {
  readonly from = '1.0';
  readonly to = '2.0';
  readonly id = 'migration_v1_to_v2';
  readonly description = 'Migrate LiquidSchema from v1.0 to v2.0';
  readonly breaking = true;

  canMigrate(schema: unknown): boolean {
    if (!schema || typeof schema !== 'object') return false;
    const s = schema as any;
    return s.version === '1.0';
  }

  migrate(schema: unknown): MigrationResult {
    const errors: MigrationError[] = [];
    const warnings: MigrationWarning[] = [];
    const transformations: TransformationLog[] = [];

    try {
      const v1 = schema as any;

      // 1. Add required UID fields
      const migrated: any = {
        ...v1,
        version: '2.0',
        uid: this.generateUID('s'),  // Schema-level UID
      };

      transformations.push({
        path: 'uid',
        type: 'added',
        after: migrated.uid,
        reason: 'Schema-level UID required in v2.0',
      });

      // 2. Add UIDs to all blocks
      if (v1.blocks && Array.isArray(v1.blocks)) {
        migrated.blocks = v1.blocks.map((block: any, index: number) => {
          const uid = this.generateUID('b');
          transformations.push({
            path: `blocks[${index}].uid`,
            type: 'added',
            after: uid,
            reason: 'Block UID required in v2.0 (see B.2)',
          });

          return {
            ...block,
            uid,
          };
        });
      }

      // 3. Migrate signal persistence enum
      if (migrated.signals) {
        for (const [name, def] of Object.entries(migrated.signals)) {
          const signal = def as any;
          if (signal.persist === 'memory') {
            signal.persist = 'none';
            transformations.push({
              path: `signals.${name}.persist`,
              type: 'modified',
              before: 'memory',
              after: 'none',
              reason: 'persist: "memory" renamed to "none" in v2.0',
            });
            warnings.push({
              path: `signals.${name}.persist`,
              message: 'persist: "memory" is now "none"',
              impact: 'low',
            });
          }
        }
      }

      // 4. Add generatedAt if missing
      if (!migrated.generatedAt) {
        migrated.generatedAt = new Date().toISOString();
        transformations.push({
          path: 'generatedAt',
          type: 'added',
          after: migrated.generatedAt,
          reason: 'generatedAt required in v2.0',
        });
      }

      // 5. Migrate layout blocks
      if (v1.layout?.type === 'flex') {
        migrated.layout.type = 'stack';
        transformations.push({
          path: 'layout.type',
          type: 'modified',
          before: 'flex',
          after: 'stack',
          reason: 'layout type "flex" renamed to "stack" in v2.0',
        });
      }

      // 6. Remove deprecated fields
      if (migrated.deprecated_field) {
        delete migrated.deprecated_field;
        transformations.push({
          path: 'deprecated_field',
          type: 'removed',
          before: migrated.deprecated_field,
          reason: 'Field removed in v2.0',
        });
        warnings.push({
          path: 'deprecated_field',
          message: 'Deprecated field removed during migration',
          impact: 'medium',
        });
      }

      return {
        success: true,
        schema: migrated as LiquidSchema,
        warnings: warnings.length > 0 ? warnings : undefined,
        metadata: {
          migratedAt: new Date().toISOString(),
          migrationId: this.id,
          fromVersion: this.from,
          toVersion: this.to,
          transformations,
        },
      };
    } catch (error) {
      return {
        success: false,
        errors: [
          {
            path: '$',
            code: 'MIGRATION_FAILED',
            message: `Migration failed: ${error}`,
            suggestion: 'Check schema structure and try again',
          },
        ],
        metadata: {
          migratedAt: new Date().toISOString(),
          migrationId: this.id,
          fromVersion: this.from,
          toVersion: this.to,
          transformations,
        },
      };
    }
  }

  getChangelog(): ChangelogEntry[] {
    return [
      {
        field: 'uid',
        change: 'added',
        description: 'Schema-level UID field added (required)',
        breaking: true,
      },
      {
        field: 'blocks[].uid',
        change: 'added',
        description: 'Block-level UID field added (required)',
        breaking: true,
      },
      {
        field: 'generatedAt',
        change: 'added',
        description: 'Timestamp field for schema generation',
        breaking: false,
      },
      {
        field: 'signals[].persist',
        change: 'modified',
        description: '"memory" renamed to "none"',
        breaking: false,
      },
      {
        field: 'layout.type',
        change: 'modified',
        description: '"flex" renamed to "stack"',
        breaking: false,
      },
    ];
  }

  estimateComplexity(schema: unknown): MigrationComplexity {
    const s = schema as any;
    const blockCount = s.blocks?.length || 0;
    const signalCount = Object.keys(s.signals || {}).length;

    if (blockCount > 50 || signalCount > 20) return 'complex';
    if (blockCount > 20 || signalCount > 10) return 'moderate';
    if (blockCount > 5) return 'simple';
    return 'trivial';
  }

  private generateUID(prefix: 's' | 'b'): string {
    const random = Math.random().toString(36).substring(2, 14);
    return `${prefix}_${random}`;
  }
}

/**
 * Migration Registry Implementation
 */

class DefaultMigrationRegistry implements MigrationRegistry {
  private migrations = new Map<string, Migration>();
  private graph = new Map<string, string[]>();  // Version adjacency list

  register(migration: Migration): void {
    const key = `${migration.from}->${migration.to}`;
    this.migrations.set(key, migration);

    // Update graph
    if (!this.graph.has(migration.from)) {
      this.graph.set(migration.from, []);
    }
    this.graph.get(migration.from)!.push(migration.to);
  }

  getMigration(from: string, to: string): Migration | null {
    const key = `${from}->${to}`;
    return this.migrations.get(key) || null;
  }

  findMigrationPath(from: string, to: string): Migration[] | null {
    // BFS to find shortest path
    const queue: Array<{ version: string; path: Migration[] }> = [
      { version: from, path: [] },
    ];
    const visited = new Set<string>([from]);

    while (queue.length > 0) {
      const { version, path } = queue.shift()!;

      if (version === to) {
        return path;
      }

      const neighbors = this.graph.get(version) || [];
      for (const next of neighbors) {
        if (visited.has(next)) continue;
        visited.add(next);

        const migration = this.getMigration(version, next);
        if (migration) {
          queue.push({
            version: next,
            path: [...path, migration],
          });
        }
      }
    }

    return null;  // No path found
  }

  migrate(schema: unknown, targetVersion: string): MigrationResult {
    const currentVersion = (schema as any)?.version;
    if (!currentVersion) {
      return {
        success: false,
        errors: [
          {
            path: 'version',
            code: 'MISSING_VERSION',
            message: 'Schema missing version field',
          },
        ],
        metadata: {
          migratedAt: new Date().toISOString(),
          migrationId: 'none',
          fromVersion: 'unknown',
          toVersion: targetVersion,
          transformations: [],
        },
      };
    }

    if (currentVersion === targetVersion) {
      return {
        success: true,
        schema: schema as LiquidSchema,
        metadata: {
          migratedAt: new Date().toISOString(),
          migrationId: 'none',
          fromVersion: currentVersion,
          toVersion: targetVersion,
          transformations: [],
        },
      };
    }

    const path = this.findMigrationPath(currentVersion, targetVersion);
    if (!path) {
      return {
        success: false,
        errors: [
          {
            path: '$',
            code: 'NO_MIGRATION_PATH',
            message: `No migration path from ${currentVersion} to ${targetVersion}`,
            suggestion: 'Check that required migrations are registered',
          },
        ],
        metadata: {
          migratedAt: new Date().toISOString(),
          migrationId: 'none',
          fromVersion: currentVersion,
          toVersion: targetVersion,
          transformations: [],
        },
      };
    }

    // Apply migrations sequentially
    let current = schema;
    const allTransformations: TransformationLog[] = [];
    const allWarnings: MigrationWarning[] = [];

    for (const migration of path) {
      const result = migration.migrate(current);
      if (!result.success) {
        return result;  // Propagate failure
      }

      current = result.schema;
      allTransformations.push(...(result.metadata.transformations || []));
      if (result.warnings) {
        allWarnings.push(...result.warnings);
      }
    }

    return {
      success: true,
      schema: current as LiquidSchema,
      warnings: allWarnings.length > 0 ? allWarnings : undefined,
      metadata: {
        migratedAt: new Date().toISOString(),
        migrationId: path.map(m => m.id).join('->'),
        fromVersion: currentVersion,
        toVersion: targetVersion,
        transformations: allTransformations,
      },
    };
  }

  canMigrate(schema: unknown, targetVersion: string): boolean {
    const currentVersion = (schema as any)?.version;
    if (!currentVersion) return false;
    if (currentVersion === targetVersion) return true;

    const path = this.findMigrationPath(currentVersion, targetVersion);
    return path !== null;
  }

  listMigrations(): MigrationInfo[] {
    return Array.from(this.migrations.values()).map(m => ({
      id: m.id,
      from: m.from,
      to: m.to,
      description: m.description,
      breaking: m.breaking,
    }));
  }
}

/**
 * Usage Example
 */

/*
const registry = new DefaultMigrationRegistry();
registry.register(new Migration_v1_to_v2());

const oldSchema = { version: '1.0', blocks: [...] };
const result = registry.migrate(oldSchema, '2.0');

if (result.success) {
  console.log('Migrated successfully:', result.schema);
  console.log('Transformations:', result.metadata.transformations);
} else {
  console.error('Migration failed:', result.errors);
}
*/
```

**Integration with B.5.4 Coherence Gate:**

When coherence checks detect version mismatches:

```typescript
function checkVersionCoherence(
  fragment: CachedFragment,
  targetVersion: string,
  registry: MigrationRegistry
): CoherenceResult {
  if (fragment.version === targetVersion) {
    return { pass: true, confidence: 1.0, repairs: [] };
  }

  if (!registry.canMigrate(fragment, targetVersion)) {
    return {
      pass: false,
      confidence: 0.0,
      repairs: [],
      reason: `No migration path from ${fragment.version} to ${targetVersion}`,
    };
  }

  return {
    pass: true,
    confidence: 0.8,  // Slightly lower confidence after migration
    repairs: [
      {
        type: 'migration',
        scope: 'schema',
        issue: `Schema version ${fragment.version} requires migration to ${targetVersion}`,
      },
    ],
  };
}
```

## Verification Checklist
- [x] Change addresses the identified issue (complete migration interface with all methods)
- [x] No new inconsistencies introduced (integrates with existing version types)
- [x] Cross-references remain valid (references to B.5.4 coherence gate integrated)

## Confidence
**HIGH** - Resolution provides:
- Complete Migration interface with all required methods
- MigrationRegistry for managing migration paths (including multi-hop)
- Full v1.0 → v2.0 example implementation
- Error handling with detailed error codes and suggestions
- Transformation logging for auditability
- Complexity estimation
- Integration with coherence gate (B.5.4)
- BFS algorithm for finding migration paths
